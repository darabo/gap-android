From d975b846be412468ac34e464da85f1f6d1f17411 Mon Sep 17 00:00:00 2001
From: callebtc <93376500+callebtc@users.noreply.github.com>
Date: Fri, 9 Jan 2026 23:56:16 +0700
Subject: [PATCH 01/10] fix: MessageRouter uses stale BluetoothMeshService
 reference (#571)

* fix: MessageRouter uses stale BluetoothMeshService reference

* fix: unconditionally update mesh reference in MessageRouter.getInstance
---
 .../bitchat/android/services/MessageRouter.kt | 30 +++++++++----------
 1 file changed, 15 insertions(+), 15 deletions(-)

diff --git a/app/src/main/java/com/gap/droid/services/MessageRouter.kt b/app/src/main/java/com/gap/droid/services/MessageRouter.kt
index 8166487..a6bac09 100644
--- a/app/src/main/java/com/gap/droid/services/MessageRouter.kt
+++ b/app/src/main/java/com/gap/droid/services/MessageRouter.kt
@@ -11,7 +11,7 @@ import com.gap.droid.nostr.NostrTransport
  */
 class MessageRouter private constructor(
     private val context: Context,
-    private val mesh: BluetoothMeshService,
+    private var mesh: BluetoothMeshService,
     private val nostr: NostrTransport
 ) {
     companion object {
@@ -19,22 +19,22 @@ class MessageRouter private constructor(
         @Volatile private var INSTANCE: MessageRouter? = null
         fun tryGetInstance(): MessageRouter? = INSTANCE
         fun getInstance(context: Context, mesh: BluetoothMeshService): MessageRouter {
-            return INSTANCE ?: synchronized(this) {
-                val nostr = NostrTransport.getInstance(context)
-                INSTANCE?.also {
-                    // Update mesh reference if needed and keep senderPeerID in sync
-                    it.nostr.senderPeerID = mesh.myPeerID
-                    return it
-                }
-                MessageRouter(context.applicationContext, mesh, nostr).also { instance ->
-                    instance.nostr.senderPeerID = mesh.myPeerID
-                    // Register for favorites changes to flush outbox
-                    try {
-                        com.gap.droid.favorites.FavoritesPersistenceService.shared.addListener(instance.favoriteListener)
-                    } catch (_: Exception) {}
-                    INSTANCE = instance
+            val instance = INSTANCE ?: synchronized(this) {
+                INSTANCE ?: run {
+                    val nostr = NostrTransport.getInstance(context)
+                    MessageRouter(context.applicationContext, mesh, nostr).also { instance ->
+                        // Register for favorites changes to flush outbox
+                        try {
+                            com.gap.droid.favorites.FavoritesPersistenceService.shared.addListener(instance.favoriteListener)
+                        } catch (_: Exception) {}
+                        INSTANCE = instance
+                    }
                 }
             }
+            // Always update mesh reference and sync peer ID
+            instance.mesh = mesh
+            instance.nostr.senderPeerID = mesh.myPeerID
+            return instance
         }
     }
 
-- 
2.50.1 (Apple Git-155)


From 0306ed4f34176553df049d0fab4dc386c2559f49 Mon Sep 17 00:00:00 2001
From: callebtc <93376500+callebtc@users.noreply.github.com>
Date: Sat, 10 Jan 2026 01:04:48 +0700
Subject: [PATCH 02/10] fix camera button (#572)

* fix camera button

* fix

* Fix: Add runtime camera permission check for image picker
---
 .../android/ui/media/ImagePickerButton.kt     | 23 ++++++++++++++++---
 1 file changed, 20 insertions(+), 3 deletions(-)

diff --git a/app/src/main/java/com/gap/droid/ui/media/ImagePickerButton.kt b/app/src/main/java/com/gap/droid/ui/media/ImagePickerButton.kt
index 78c9f78..eb1f5d8 100644
--- a/app/src/main/java/com/gap/droid/ui/media/ImagePickerButton.kt
+++ b/app/src/main/java/com/gap/droid/ui/media/ImagePickerButton.kt
@@ -1,5 +1,7 @@
 package com.gap.droid.ui.media
 
+import android.Manifest
+import android.content.pm.PackageManager
 import android.net.Uri
 import androidx.activity.compose.rememberLauncherForActivityResult
 import androidx.activity.result.contract.ActivityResultContracts
@@ -19,6 +21,7 @@ import androidx.compose.ui.graphics.Color
 import androidx.compose.ui.platform.LocalContext
 import androidx.compose.ui.res.stringResource
 import androidx.compose.ui.unit.dp
+import androidx.core.content.ContextCompat
 import androidx.core.content.FileProvider
 import com.gap.droid.features.media.ImageUtils
 import java.io.File
@@ -70,8 +73,16 @@ fun ImagePickerButton(
             )
             capturedImagePath = file.absolutePath
             takePictureLauncher.launch(uri)
-        } catch (_: Exception) {
-            // Ignore errors; no-op
+        } catch (e: Exception) {
+            android.util.Log.e("ImagePickerButton", "Camera capture failed", e)
+        }
+    }
+
+    val permissionLauncher = rememberLauncherForActivityResult(
+        contract = ActivityResultContracts.RequestPermission()
+    ) { isGranted ->
+        if (isGranted) {
+            startCameraCapture()
         }
     }
 
@@ -80,7 +91,13 @@ fun ImagePickerButton(
             .size(32.dp)
             .combinedClickable(
                 onClick = { imagePicker.launch("image/*") },
-                onLongClick = { startCameraCapture() }
+                onLongClick = {
+                    if (ContextCompat.checkSelfPermission(context, Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED) {
+                        startCameraCapture()
+                    } else {
+                        permissionLauncher.launch(Manifest.permission.CAMERA)
+                    }
+                }
             ),
         contentAlignment = Alignment.Center
     ) {
-- 
2.50.1 (Apple Git-155)


From fbcc289e927121c865fa60e5d03cbc38a98bd253 Mon Sep 17 00:00:00 2001
From: GitHub Action <action@github.com>
Date: Sun, 11 Jan 2026 06:07:53 +0000
Subject: [PATCH 03/10] Automated update of relay data - Sun Jan 11 06:07:53
 UTC 2026

---
 app/src/main/assets/nostr_relays.csv | 529 ++++++++++++++-------------
 1 file changed, 266 insertions(+), 263 deletions(-)

diff --git a/app/src/main/assets/nostr_relays.csv b/app/src/main/assets/nostr_relays.csv
index 345b731..023ba63 100644
--- a/app/src/main/assets/nostr_relays.csv
+++ b/app/src/main/assets/nostr_relays.csv
@@ -1,290 +1,293 @@
 Relay URL,Latitude,Longitude
-alien.macneilmediagroup.com,43.6532,-79.3832
-v-relay.d02.vrtmrz.net,34.6937,135.502
-relay.thebluepulse.com,49.4521,11.0767
+ribo.us.nostria.app,41.5868,-93.625
+relay.credenso.cafe,43.3601,-80.3127
+nostr-02.uid.ovh,43.6532,-79.3832
+nostr-2.21crypto.ch,47.5356,8.73209
+relay.primal.net,43.6532,-79.3832
+relay.davidebtc.me,50.1109,8.68213
+nostr.hekster.org,37.3986,-121.964
+theoutpost.life,64.1476,-21.9392
+nostr-relayrs.gateway.in.th,15.2634,100.344
+nostr.mikoshi.de,50.1109,8.68213
+yabu.me,35.6092,139.73
+nproxy.kristapsk.lv,60.1699,24.9384
+relayone.soundhsa.com,33.1384,-95.6011
+nos.lol,50.4754,12.3683
+relay.angor.io,48.1046,11.6002
+relay.arx-ccn.com,50.4754,12.3683
+nostr.ovia.to,43.6532,-79.3832
+bitsat.molonlabe.holdings,51.4012,-1.3147
+relay.magiccity.live,25.7975,-80.23
+satsage.xyz,37.3986,-121.964
+vault.iris.to,43.6532,-79.3832
+nostr.oxtr.dev,50.4754,12.3683
+nostr.hifish.org,47.4244,8.57658
+relay.minibolt.info,43.6532,-79.3832
+nostr.robosats.org,64.1476,-21.9392
+nostr.lkjsxc.com,43.6532,-79.3832
+relay.puresignal.news,43.6532,-79.3832
+ynostr.yael.at,60.1699,24.9384
+orangepiller.org,60.1699,24.9384
+relay02.lnfi.network,39.0997,-94.5786
+nostr-relay-1.trustlessenterprise.com,43.6532,-79.3832
 relay.guggero.org,47.3769,8.54169
-relay.lumina.rocks,49.0291,8.35695
-relay-freeharmonypeople.space,38.7223,-9.13934
-nostr-relay.online,43.6532,-79.3832
-shu05.shugur.net,48.8566,2.35222
+nostrcity-club.fly.dev,48.8566,2.35222
+nostr.agentcampfire.com,52.3676,4.90414
+nostr.dler.com,25.0367,121.524
+nostr.ps1829.com,33.8851,130.883
+nostr.blankfors.se,60.1699,24.9384
+nostr.na.social,43.6532,-79.3832
+nostr.luisschwab.net,43.6532,-79.3832
+relay.mostro.network,40.8302,-74.1299
+nostr.21crypto.ch,47.5356,8.73209
+relay.dwadziesciajeden.pl,52.2297,21.0122
+relay.comcomponent.com,34.7062,135.493
+nostr.bond,50.1109,8.68213
+wot.yesnostr.net,50.9871,2.12554
+chat-relay.zap-work.com,43.6532,-79.3832
+nostr-relay.psfoundation.info,39.0438,-77.4874
+relay.smies.me,33.7501,-84.3885
+relay.cosmicbolt.net,37.3986,-121.964
+nostr.night7.space,50.4754,12.3683
+dev-relay.lnfi.network,39.0997,-94.5786
+nostr.mom,50.4754,12.3683
+nostr.spicyz.io,43.6532,-79.3832
+nostr.rikmeijer.nl,50.4754,12.3683
+relay.origin.land,35.6673,139.751
+czas.xyz,48.8566,2.35222
+nostr-01.uid.ovh,43.6532,-79.3832
+relaynostr.breadslice.com,43.6532,-79.3832
+black.nostrcity.club,48.8566,2.35222
+nostr.sathoarder.com,48.5734,7.75211
+bucket.coracle.social,37.7775,-122.397
 relay.evanverma.com,40.8302,-74.1299
-relay2.angor.io,48.1046,11.6002
-relay.arx-ccn.com,50.4754,12.3683
-relay.davidebtc.me,51.5072,-0.127586
-temp.iris.to,43.6532,-79.3832
-nostr.superfriends.online,43.6532,-79.3832
-vitor.nostr1.com,40.7057,-74.0136
-relay.moinsen.com,50.4754,12.3683
-ithurtswhenip.ee,51.223,6.78245
-nostr.tadryanom.me,43.6532,-79.3832
-relay.nostr.wirednet.jp,34.706,135.493
 relay.0xchat.com,1.35208,103.82
-nostrcheck.tnsor.network,43.6532,-79.3832
-relay.ngengine.org,43.6532,-79.3832
-relay.mitchelltribe.com,39.0438,-77.4874
-wotr.relatr.xyz,53.3498,-6.26031
-relay.chorus.community,50.1109,8.68213
-orly.ft.hn,50.4754,12.3683
+espelho.girino.org,43.6532,-79.3832
+relay.satlantis.io,32.8769,-80.0114
+relay.damus.io,43.6532,-79.3832
+nostr.bitcoiner.social,39.1585,-94.5728
+relay.trustroots.org,43.6532,-79.3832
+notemine.io,52.2026,20.9397
+wot.dergigi.com,64.1476,-21.9392
+relay.bullishbounty.com,43.6532,-79.3832
+relay.getsafebox.app,43.6532,-79.3832
+relay.fundstr.me,42.3601,-71.0589
+nostr.now,36.55,139.733
+x.kojira.io,43.6532,-79.3832
+relay.lumina.rocks,49.0291,8.35695
+nostr.openhoofd.nl,51.9229,4.40833
+relay04.lnfi.network,39.0997,-94.5786
+nostr.coincards.com,53.5501,-113.469
+relay.nostrcheck.me,43.6532,-79.3832
+nostr-relay.xbytez.io,50.6924,3.20113
+relay.bitcoinveneto.org,64.1466,-21.9426
+r.bitcoinhold.net,43.6532,-79.3832
+prl.plus,42.6978,23.3246
+relay.goodmorningbitcoin.com,43.6532,-79.3832
+wons.calva.dev,37.3986,-121.964
+cyberspace.nostr1.com,40.7057,-74.0136
+relay-testnet.k8s.layer3.news,37.3387,-121.885
+temp.iris.to,43.6532,-79.3832
+nostr.nodesmap.com,59.3327,18.0656
+v-relay.d02.vrtmrz.net,34.6937,135.502
+relay-freeharmonypeople.space,38.7223,-9.13934
+relayb.uid.ovh,43.6532,-79.3832
+nostr.bgbitcoin.club,50.4754,12.3683
 nostr.stakey.net,52.3676,4.90414
-relay.malxte.de,52.52,13.405
-nostrelay.circum.space,52.3676,4.90414
-nostrcheck.me,43.6532,-79.3832
-wot.sudocarlos.com,51.5072,-0.127586
-relay.routstr.com,43.6532,-79.3832
+nostr-relay.corb.net,38.8353,-104.822
+relayone.geektank.ai,18.2148,-63.0574
+relay.21e6.cz,50.7383,15.0648
+strfry.openhoofd.nl,51.9229,4.40833
+nostrelites.org,41.8781,-87.6298
+discovery.eu.nostria.app,52.3676,4.90414
+no.str.cr,9.92857,-84.0528
+nostr-pub.wellorder.net,45.5201,-122.99
+wot.nostr.place,32.7767,-96.797
+relay.bitcoindistrict.org,43.6532,-79.3832
+relay.ditto.pub,43.6532,-79.3832
 relay.siamdev.cc,13.8434,100.363
+relay.javi.space,43.4633,11.8796
 wot.sovbit.host,64.1466,-21.9426
-strfry.bonsai.com,37.8715,-122.273
-freeben666.fr,43.7221,7.15296
-okn.czas.top,51.267,6.81738
-relay.nostar.org,43.6532,-79.3832
-relay.jeffg.fyi,43.6532,-79.3832
-nostr-02.uid.ovh,43.6532,-79.3832
-relay.fr13nd5.com,52.5233,13.3426
-srtrelay.c-stellar.net,43.6532,-79.3832
-relay.dwadziesciajeden.pl,52.2297,21.0122
-relay.sigit.io,50.4754,12.3683
-nostr.girino.org,43.6532,-79.3832
-bitsat.molonlabe.holdings,51.4012,-1.3147
-nostream.breadslice.com,1.35208,103.82
-nostr.rtvslawenia.com,49.4543,11.0746
-nostr.openhoofd.nl,51.9229,4.40833
-librerelay.aaroniumii.com,43.6532,-79.3832
-relay.etch.social,41.2619,-95.8608
-strfry.felixzieger.de,50.1013,8.62643
-relay.wavlake.com,41.2619,-95.8608
-relay.fundstr.me,42.3601,-71.0589
-slick.mjex.me,39.048,-77.4817
-relay.upleb.uk,51.9194,19.1451
-nos4smartnkind.tech,40.1872,44.5152
-discovery.eu.nostria.app,52.3676,4.90414
+relay.btcforplebs.com,43.6532,-79.3832
 nostr.tac.lol,47.4748,-122.273
-wot.nostr.net,43.6532,-79.3832
-nostr-dev.wellorder.net,45.5201,-122.99
-fanfares.nostr1.com,40.7128,-74.006
-relay.bitcoindistrict.org,43.6532,-79.3832
-nostr-relay.nextblockvending.com,47.2343,-119.853
-relay-rpi.edufeed.org,49.4521,11.0767
-relay.nsnip.io,60.1699,24.9384
-black.nostrcity.club,48.8575,2.35138
-nostr-02.czas.top,51.2277,6.77346
+nostr.noones.com,50.1109,8.68213
+nostr.snowbla.de,60.1699,24.9384
+relay.endfiat.money,43.6532,-79.3832
+relay.ru.ac.th,13.7607,100.627
+relay.vantis.ninja,43.6532,-79.3832
+relay.olas.app,50.4754,12.3683
+nostr.azzamo.net,52.2633,21.0283
+relay.lightning.pub,39.0438,-77.4874
+nostr-rs-relay-ishosta.phamthanh.me,43.6532,-79.3832
+shu05.shugur.net,48.8566,2.35222
+nostr.calitabby.net,39.9268,-75.0246
+relay1.nostrchat.io,60.1699,24.9384
 schnorr.me,43.6532,-79.3832
+relay.npubhaus.com,43.6532,-79.3832
+relay.seq1.net,43.6532,-79.3832
+inbox.azzamo.net,52.2633,21.0283
+nostr-relay.cbrx.io,43.6532,-79.3832
+nostr.coincrowd.fund,39.0438,-77.4874
 relay.fountain.fm,39.0997,-94.5786
-nostr-verified.wellorder.net,45.5201,-122.99
-relay.divine.video,43.6532,-79.3832
-relay.thibautduchene.fr,43.6532,-79.3832
-nostr.plantroon.com,50.1013,8.62643
-relay.hasenpfeffr.com,39.0438,-77.4874
-relay.chakany.systems,43.6532,-79.3832
-nostr-01.yakihonne.com,1.32123,103.695
-nostr.azzamo.net,52.2633,21.0283
-nostr.bond,50.1109,8.68213
-nostr.coincards.com,53.5501,-113.469
-relay.nostrhub.tech,49.0291,8.35696
-relay.cosmicbolt.net,37.3986,-121.964
-nostr.21crypto.ch,47.5356,8.73209
+strfry.shock.network,39.0438,-77.4874
+relay.nostr.wirednet.jp,34.706,135.493
 relay-dev.satlantis.io,40.8302,-74.1299
-offchain.pub,47.6743,-117.112
-relay.orangepill.ovh,49.1689,-0.358841
-nostr-relay.gateway.in.th,15.2634,100.344
-nostr.now,36.55,139.733
-relay.usefusion.ai,38.7134,-78.1591
-nostr.lkjsxc.com,43.6532,-79.3832
-nproxy.kristapsk.lv,60.1699,24.9384
+relay.sigit.io,50.4754,12.3683
+nostr.chaima.info,50.1109,8.68213
+nostream.breadslice.com,1.35208,103.82
+librerelay.aaroniumii.com,43.6532,-79.3832
 relay.nostrverse.net,43.6532,-79.3832
-relay.zone667.com,60.1699,24.9384
-relay.origin.land,35.6673,139.751
-relay.damus.io,43.6532,-79.3832
-relay.bnos.space,1.35208,103.82
-relay.endfiat.money,43.6532,-79.3832
-relay.bullishbounty.com,43.6532,-79.3832
-wot.nostr.party,36.1627,-86.7816
-nostr.huszonegy.world,47.4979,19.0402
-theoutpost.life,64.1476,-21.9392
-nostr.noones.com,50.1109,8.68213
-relay.21e6.cz,50.7383,15.0648
-nostr-relay.xbytez.io,50.6924,3.20113
-wot.shaving.kiwi,43.6532,-79.3832
-relay.trustroots.org,43.6532,-79.3832
-wot.dtonon.com,43.6532,-79.3832
-nostr.camalolo.com,24.1469,120.684
-czas.xyz,48.8566,2.35222
-relayrs.notoshi.win,43.6532,-79.3832
-skeme.vanderwarker.family,40.8218,-74.45
-nostr.red5d.dev,43.6532,-79.3832
-relay.javi.space,43.4633,11.8796
-relay.nuts.cash,34.0362,-118.443
-nostr.commonshub.brussels,49.4543,11.0746
-relay.artx.market,43.652,-79.3633
-satsage.xyz,37.3986,-121.964
-relay.nostx.io,43.6532,-79.3832
-shu02.shugur.net,21.4902,39.2246
-strfry.ymir.cloud,34.0965,-117.585
-relay.nostr-check.me,43.6532,-79.3832
-relay04.lnfi.network,39.0997,-94.5786
-kotukonostr.onrender.com,37.7775,-122.397
-nostr.davidebtc.me,51.5072,-0.127586
-relay2.ngengine.org,43.6532,-79.3832
-ribo.us.nostria.app,41.5868,-93.625
-nostr.czas.top,50.1109,8.68213
-relay.nostrzh.org,43.6532,-79.3832
-relay.angor.io,48.1046,11.6002
-alienos.libretechsystems.xyz,55.4724,9.87335
-vault.iris.to,43.6532,-79.3832
-relay.mccormick.cx,52.3563,4.95714
+relay.bitcoinartclock.com,50.4754,12.3683
+relay.coinos.io,43.6532,-79.3832
+relay2.angor.io,48.1046,11.6002
+relay.threenine.services,51.5524,-0.29686
 nostr.quali.chat,60.1699,24.9384
-wheat.happytavern.co,43.6532,-79.3832
-relay.olas.app,50.4754,12.3683
-nostr-relayrs.gateway.in.th,15.2634,100.344
-relay.snort.social,53.3498,-6.26031
-nostr-2.21crypto.ch,47.5356,8.73209
-pyramid.treegaze.com,43.6532,-79.3832
-relay.smies.me,33.7501,-84.3885
-wot.dergigi.com,64.1476,-21.9392
-nostr-relay.zimage.com,34.0549,-118.243
-nostr-rs-relay.dev.fedibtc.com,39.0438,-77.4874
+wot.dtonon.com,43.6532,-79.3832
+kitchen.zap.cooking,43.6532,-79.3832
+relay.nostrdice.com,-33.8688,151.209
+relay.degmods.com,50.4754,12.3683
 nostr.jerrynya.fun,31.2304,121.474
-purplerelay.com,50.1109,8.68213
-relay.comcomponent.com,34.7062,135.493
+nostr-02.czas.top,51.2277,6.77346
+bcast.seutoba.com.br,43.6532,-79.3832
+relay.jeffg.fyi,43.6532,-79.3832
+relay.nostriot.com,41.5695,-83.9786
+relay.fr13nd5.com,52.5233,13.3426
+nostr.n7ekb.net,47.4941,-122.294
+nostr-relay.gateway.in.th,15.2634,100.344
+slick.mjex.me,39.048,-77.4817
+relay.tagayasu.xyz,45.4215,-75.6972
+nostr.superfriends.online,43.6532,-79.3832
+relay.chorus.community,50.1109,8.68213
 relay.unitypay.cash,41.4513,-81.7021
-nostr.mikoshi.de,50.1109,8.68213
-prl.plus,42.6978,23.3246
-shu04.shugur.net,25.2604,55.2989
-nostr-relay-1.trustlessenterprise.com,43.6532,-79.3832
-nostr.zoracle.org,45.6018,-121.185
-nostriches.club,43.6532,-79.3832
-nostr.notribe.net,40.8302,-74.1299
-nostr.vulpem.com,49.4543,11.0746
-bucket.coracle.social,37.7775,-122.397
-wot.yesnostr.net,50.9871,2.12554
-wot.nostr.place,32.7767,-96.797
+wot.sudocarlos.com,43.6532,-79.3832
+wot.nostr.party,36.1512,-86.7835
+relay.routstr.com,43.6532,-79.3832
+strfry.felixzieger.de,50.1013,8.62643
+ephemeral.snowflare.cc,43.6532,-79.3832
+bcast.girino.org,43.6532,-79.3832
+relay.openfarmtools.org,60.1699,24.9384
 nostr.mehdibekhtaoui.com,49.4939,-1.54813
-relay.getsafebox.app,43.6532,-79.3832
-nostr2.girino.org,43.6532,-79.3832
-nostr.blankfors.se,60.1699,24.9384
-premium.primal.net,43.6532,-79.3832
-nostr.rikmeijer.nl,50.4754,12.3683
-relay-fra.zombi.cloudrodion.com,48.8566,2.35222
-adre.su,59.9311,30.3609
-nostr.n7ekb.net,47.4941,-122.294
-nostr.hekster.org,37.3986,-121.964
-relay.jabato.space,52.52,13.405
-fenrir-s.notoshi.win,43.6532,-79.3832
-notemine.io,52.2026,20.9397
-r.bitcoinhold.net,43.6532,-79.3832
-nostr-pub.wellorder.net,45.5201,-122.99
+relay.cypherflow.ai,48.8566,2.35222
+nostr-verified.wellorder.net,45.5201,-122.99
+rele.speyhard.vip,50.1109,8.68213
+nostr.girino.org,43.6532,-79.3832
+relay.nuts.cash,34.0362,-118.443
+nostr.zoracle.org,45.6018,-121.185
+purplerelay.com,50.1109,8.68213
+nostr-03.dorafactory.org,1.35208,103.82
+relay.illuminodes.com,47.6061,-122.333
+relay.nsnip.io,60.1699,24.9384
+ribo.eu.nostria.app,52.3676,4.90414
+wot.geektank.ai,18.2148,-63.0574
+relay.upleb.uk,52.2297,21.0122
+relay.libernet.app,43.6532,-79.3832
+santo.iguanatech.net,40.8302,-74.1299
 articles.layer3.news,37.3387,-121.885
-relays.diggoo.com,43.6532,-79.3832
-relayb.uid.ovh,43.6532,-79.3832
-nostr.thebiglake.org,32.71,-96.6745
-chat-relay.zap-work.com,43.6532,-79.3832
-nr.yay.so,46.2126,6.1154
+relay-fra.zombi.cloudrodion.com,48.8566,2.35222
+nostr.tadryanom.me,43.6532,-79.3832
 shu01.shugur.net,21.4902,39.2246
-khatru.nostrver.se,51.1792,5.89444
-relay.openfarmtools.org,60.1699,24.9384
-relay01.lnfi.network,39.0997,-94.5786
-nostrja-kari.heguro.com,43.6532,-79.3832
-nostr.snowbla.de,60.1699,24.9384
-relay.satlantis.io,32.8769,-80.0114
-relay.vrtmrz.net,43.6532,-79.3832
+alienos.libretechsystems.xyz,55.4724,9.87335
+nostr-rs-relay.dev.fedibtc.com,39.0438,-77.4874
+nostr.bilthon.dev,25.7975,-80.23
+relay.islandbitcoin.com,12.8498,77.6545
+relay03.lnfi.network,39.0997,-94.5786
+nostr-dev.wellorder.net,45.5201,-122.99
+nostr.rtvslawenia.com,49.4543,11.0746
 purpura.cloud,43.6532,-79.3832
-orangepiller.org,60.1699,24.9384
-relay.coinos.io,43.6532,-79.3832
-relay.layer.systems,49.0291,8.35695
-relay.toastr.net,40.8054,-74.0241
-ynostr.yael.at,60.1699,24.9384
-ribo.eu.nostria.app,52.3676,4.90414
-relay.nostrcheck.me,43.6532,-79.3832
-relay.primal.net,43.6532,-79.3832
-relay-testnet.k8s.layer3.news,37.3387,-121.885
-relay.threenine.services,51.5524,-0.29686
-relay.nostr.net,43.6532,-79.3832
-nostr.middling.mydns.jp,35.8099,140.12
-soloco.nl,43.6532,-79.3832
+relay.artx.market,43.6532,-79.3832
+relay.westernbtc.com,44.5401,-123.368
+relay.orangepill.ovh,49.1689,-0.358841
+nostr.vulpem.com,49.4543,11.0746
 nostr.4rs.nl,49.0291,8.35696
-no.str.cr,9.92857,-84.0528
-espelho.girino.org,43.6532,-79.3832
-nostr.hifish.org,47.4043,8.57398
+premium.primal.net,43.6532,-79.3832
+relay.vrtmrz.net,43.6532,-79.3832
+relay.nostar.org,43.6532,-79.3832
+strfry.ymir.cloud,34.0965,-117.585
+relay.wellorder.net,45.5201,-122.99
+nostrja-kari.heguro.com,43.6532,-79.3832
+relay.wavlake.com,41.2619,-95.8608
+relay.wavefunc.live,34.0362,-118.443
+relay.nostr.band,60.1699,24.9384
 wot.sebastix.social,51.1792,5.89444
-relay03.lnfi.network,39.0997,-94.5786
-relay.nosto.re,51.1792,5.89444
-relay.nostrdice.com,-33.8688,151.209
-nostr.agentcampfire.com,52.3676,4.90414
-nostr.night7.space,50.4754,12.3683
-nostr.nodesmap.com,59.3327,18.0656
-relayone.soundhsa.com,33.1384,-95.6011
-relay.illuminodes.com,47.6061,-122.333
-nostr-rs-relay-ishosta.phamthanh.me,43.6532,-79.3832
-nostr.robosats.org,64.1476,-21.9392
-relay.seq1.net,43.6532,-79.3832
-strfry.shock.network,39.0438,-77.4874
-nostr.ovia.to,43.6532,-79.3832
-relay.holzeis.me,43.6532,-79.3832
-bcast.seutoba.com.br,43.6532,-79.3832
-relay.libernet.app,43.6532,-79.3832
-nostr-01.uid.ovh,43.6532,-79.3832
-nostr.luisschwab.net,43.6532,-79.3832
-strfry.elswa-dev.online,50.1109,8.68213
-relay.nostriot.com,41.5695,-83.9786
-nostr.oxtr.dev,50.4754,12.3683
-nostr.mom,50.4754,12.3683
-nostr-03.dorafactory.org,1.35208,103.82
-relay.camelus.app,45.5201,-122.99
-strfry.openhoofd.nl,51.9229,4.40833
-nos.lol,50.4754,12.3683
-nostr.bitcoiner.social,39.1585,-94.5728
-relay.islandbitcoin.com,12.8498,77.6545
-relay.tagayasu.xyz,43.6715,-79.38
-dev-nostr.bityacht.io,25.0797,121.234
-relay.nostrhub.fr,48.1045,11.6004
-relay.satmaxt.xyz,43.6532,-79.3832
-yabu.me,35.6092,139.73
+relay.nostrhub.tech,49.0291,8.35696
+nostr.myshosholoza.co.za,52.3676,4.90414
+relay.toastr.net,40.8054,-74.0241
+relay2.ngengine.org,43.6532,-79.3832
+relay.nostr.place,32.7767,-96.797
+relay.notoshi.win,13.4166,101.335
+relay.etch.social,41.2619,-95.8608
+relay.bnos.space,1.35208,103.82
+nostr.0x7e.xyz,47.4988,8.72369
+relay.ngengine.org,43.6532,-79.3832
+strfry.bonsai.com,37.8715,-122.273
+relay.zone667.com,60.1699,24.9384
+nostr2.girino.org,43.6532,-79.3832
+nostr-relay.zimage.com,34.0549,-118.243
+wheat.happytavern.co,43.6532,-79.3832
+nostr.thebiglake.org,32.71,-96.6745
 relay.samt.st,40.8302,-74.1299
-relay02.lnfi.network,39.0997,-94.5786
-nostr.88mph.life,51.5072,-0.127586
-dev-relay.lnfi.network,39.0997,-94.5786
-relay.goodmorningbitcoin.com,43.6532,-79.3832
-nostrelay.memory-art.xyz,43.6532,-79.3832
-relay.degmods.com,50.4754,12.3683
+nostr.huszonegy.world,47.4979,19.0402
+relay.nostrzh.org,43.6532,-79.3832
+nostr.red5d.dev,43.6532,-79.3832
+nostr-01.yakihonne.com,1.29524,103.79
 nostr-02.yakihonne.com,1.32123,103.695
-nostr.spicyz.io,43.6532,-79.3832
-relay.minibolt.info,43.6532,-79.3832
-bcast.girino.org,43.6532,-79.3832
-nostr.bilthon.dev,25.8128,-80.2377
-relay.bitcoinartclock.com,50.4754,12.3683
-cyberspace.nostr1.com,40.7128,-74.006
-nostr.data.haus,50.4754,12.3683
+nostr-relay.online,43.6532,-79.3832
+strfry.elswa-dev.online,50.1109,8.68213
 relay.agora.social,50.7383,15.0648
-relay.wavefunc.live,34.0362,-118.443
-nostr.casa21.space,43.6532,-79.3832
-relay.mostro.network,40.8302,-74.1299
-relay.ditto.pub,43.6532,-79.3832
-nostr-relay.amethyst.name,39.0438,-77.4874
-relay.credenso.cafe,43.3601,-80.3127
-nostr.calitabby.net,39.9268,-75.0246
-relay.magiccity.live,25.8128,-80.2377
-nostr.chaima.info,51.223,6.78245
-wot.brightbolt.net,47.6735,-116.781
-nostr.sathoarder.com,48.5734,7.75211
-inbox.azzamo.net,52.2633,21.0283
-nostr.na.social,43.6532,-79.3832
-nostr.myshosholoza.co.za,52.3676,4.90414
+nostr-relay.nextblockvending.com,47.2343,-119.853
+relay.usefusion.ai,38.7134,-78.1591
+relay.divine.video,43.6532,-79.3832
+freeben666.fr,43.7221,7.15296
+nostrcheck.tnsor.network,43.6532,-79.3832
+nostrelay.circum.space,52.3676,4.90414
+nostr.bitczat.pl,60.1699,24.9384
+wot.nostr.net,43.6532,-79.3832
+wot.shaving.kiwi,43.6532,-79.3832
+shu04.shugur.net,25.2048,55.2708
+okn.czas.top,50.1109,8.68213
+nr.yay.so,46.2126,6.1154
+relay.mitchelltribe.com,39.0438,-77.4874
+relay.snort.social,53.3498,-6.26031
+nostr.faultables.net,43.6532,-79.3832
+0m0sef4nb45q6.cloreai.ru,43.6532,-79.3832
 nostr.spaceshell.xyz,43.6532,-79.3832
-relay.wellorder.net,45.5201,-122.99
-nostr.0x7e.xyz,47.4988,8.72369
-nostr-relay.cbrx.io,43.6532,-79.3832
-relay.btcforplebs.com,43.6532,-79.3832
-bitcoiner.social,39.1585,-94.5728
-relaynostr.breadslice.com,43.6532,-79.3832
+fanfares.nostr1.com,40.7057,-74.0136
+relay.layer.systems,49.0291,8.35695
+freelay.sovbit.host,64.1476,-21.9392
+relay.moinsen.com,50.4754,12.3683
+relay.nostx.io,43.6532,-79.3832
+relay-rpi.edufeed.org,49.4521,11.0767
+relay.nostrhub.fr,48.1045,11.6004
+nostr.czas.top,50.1109,8.68213
+relay.satmaxt.xyz,43.6532,-79.3832
+relay.chakany.systems,43.6532,-79.3832
+soloco.nl,43.6532,-79.3832
+nostr.davidebtc.me,50.1109,8.68213
 nostr.overmind.lol,43.6532,-79.3832
-santo.iguanatech.net,40.8302,-74.1299
-relay.lightning.pub,39.0438,-77.4874
+relay.mccormick.cx,52.3563,4.95714
+dev-nostr.bityacht.io,25.0797,121.234
+khatru.nostrver.se,51.1792,5.89444
+relay.nosto.re,51.1792,5.89444
+pyramid.aaro.cc,32.7767,-96.797
 nostr.rblb.it,43.7094,10.6582
-relay.bitcoinveneto.org,64.1466,-21.9426
-relay.wolfcoil.com,35.6092,139.73
-nostr-relay.corb.net,38.8353,-104.822
-relay.nostr.place,32.7767,-96.797
-wot.soundhsa.com,33.1384,-95.6011
-relay.npubhaus.com,43.6532,-79.3832
-nostr-relay.psfoundation.info,39.0438,-77.4874
-x.kojira.io,43.6532,-79.3832
-relay.cypherflow.ai,48.8566,2.35222
+relay.malxte.de,52.52,13.405
+kotukonostr.onrender.com,37.7775,-122.397
+nostrcheck.me,43.6532,-79.3832
+orly.ft.hn,50.4754,12.3683
+nostr.notribe.net,40.8302,-74.1299
+offchain.pub,47.6743,-117.112
+shu02.shugur.net,21.4902,39.2246
+adre.su,59.8845,30.3184
+ithurtswhenip.ee,51.223,6.78245
+nos4smartnkind.tech,40.1872,44.5152
+relay.cyphernomad.com,60.1699,24.9384
+bitcoiner.social,39.1585,-94.5728
+nostr-relay.amethyst.name,39.0438,-77.4874
+nostr.casa21.space,43.6532,-79.3832
+nostr.88mph.life,51.5072,-0.127586
+relay.thebluepulse.com,49.4521,11.0767
+relay01.lnfi.network,39.0997,-94.5786
+relay.nostr.net,43.6532,-79.3832
+relay.contextvm.org,53.3498,-6.26031
+srtrelay.c-stellar.net,43.6532,-79.3832
+nostr.data.haus,50.4754,12.3683
-- 
2.50.1 (Apple Git-155)


From cbe7a2fc95b248a17ce3f8be19ca61496bcde27b Mon Sep 17 00:00:00 2001
From: yet300 <96379204+yet300@users.noreply.github.com>
Date: Mon, 12 Jan 2026 11:43:28 +0400
Subject: [PATCH 04/10] Fix scroll bug(#568) (#570)

* Automated update of relay data - Sun Sep 21 06:21:05 UTC 2025

* Automated update of relay data - Sun Sep 28 06:20:40 UTC 2025

* refactor: new close button like ios(but not liquid glass)

* Automated update of relay data - Sun Oct  5 06:20:09 UTC 2025

* Automated update of relay data - Sun Oct 12 06:20:12 UTC 2025

* Automated update of relay data - Sun Oct 19 06:21:51 UTC 2025

* Automated update of relay data - Sun Oct 26 06:21:31 UTC 2025

* Automated update of relay data - Sun Nov  2 06:22:16 UTC 2025

* Automated update of relay data - Sun Nov  9 06:21:43 UTC 2025

* Automated update of relay data - Sun Nov 16 06:22:37 UTC 2025

* Automated update of relay data - Sun Nov 23 06:22:51 UTC 2025

* Automated update of relay data - Sun Nov 30 06:24:08 UTC 2025

* Automated update of relay data - Sun Dec  7 06:22:59 UTC 2025

* Automated update of relay data - Sun Dec 14 06:24:33 UTC 2025

* Automated update of relay data - Sun Dec 21 06:24:49 UTC 2025

* Automated update of relay data - Sun Dec 28 06:25:38 UTC 2025

* Automated update of relay data - Sun Jan  4 06:26:28 UTC 2026

* fix bug(568): Improve scroll-to-bottom logic

Replaced the "smart scroll" mechanism with a simpler "follow" behavior. The message list now automatically scrolls to the latest message unless the user has scrolled up.

- A new `followIncomingMessages` state tracks whether to auto-scroll.
- Scrolling now uses `scrollToItem` instead of `animateScrollToItem` for immediate updates.

---------

Co-authored-by: GitHub Action <action@github.com>
---
 .../com/bitchat/android/ui/MessageComponents.kt | 17 +++++++----------
 1 file changed, 7 insertions(+), 10 deletions(-)

diff --git a/app/src/main/java/com/gap/droid/ui/MessageComponents.kt b/app/src/main/java/com/gap/droid/ui/MessageComponents.kt
index e155b56..986c8c6 100644
--- a/app/src/main/java/com/gap/droid/ui/MessageComponents.kt
+++ b/app/src/main/java/com/gap/droid/ui/MessageComponents.kt
@@ -71,19 +71,14 @@ fun MessagesList(
     
     // Track if this is the first time messages are being loaded
     var hasScrolledToInitialPosition by remember { mutableStateOf(false) }
+    var followIncomingMessages by remember { mutableStateOf(true) }
     
-    // Smart scroll: auto-scroll to bottom for initial load, then only when user is at or near the bottom
+    // Smart scroll: auto-scroll to bottom for initial load, then follow unless user scrolls away
     LaunchedEffect(messages.size) {
         if (messages.isNotEmpty()) {
-            val layoutInfo = listState.layoutInfo
-            val firstVisibleIndex = layoutInfo.visibleItemsInfo.firstOrNull()?.index ?: -1
-            
-            // With reverseLayout=true and reversed data, index 0 is the latest message at the bottom
             val isFirstLoad = !hasScrolledToInitialPosition
-            val isNearLatest = firstVisibleIndex <= 2
-            
-            if (isFirstLoad || isNearLatest) {
-                listState.animateScrollToItem(0)
+            if (isFirstLoad || followIncomingMessages) {
+                listState.scrollToItem(0)
                 if (isFirstLoad) {
                     hasScrolledToInitialPosition = true
                 }
@@ -99,6 +94,7 @@ fun MessagesList(
         }
     }
     LaunchedEffect(isAtLatest) {
+        followIncomingMessages = isAtLatest
         onScrolledUpChanged?.invoke(!isAtLatest)
     }
     
@@ -106,7 +102,8 @@ fun MessagesList(
     LaunchedEffect(forceScrollToBottom) {
         if (messages.isNotEmpty()) {
             // With reverseLayout=true and reversed data, latest is at index 0
-            listState.animateScrollToItem(0)
+            followIncomingMessages = true
+            listState.scrollToItem(0)
         }
     }
     
-- 
2.50.1 (Apple Git-155)


From c7e20a9590b4220a72a4b1cb02bd7cd64e92c375 Mon Sep 17 00:00:00 2001
From: a1denvalu3 <43107113+a1denvalu3@users.noreply.github.com>
Date: Mon, 12 Jan 2026 08:53:53 +0100
Subject: [PATCH 05/10] fix nostr private messages processing (#563)

* fix nostr private messages processing

* persisted geohash registry

---------

Co-authored-by: a1denvalu3 <>
---
 .../com/bitchat/android/BitchatApplication.kt |  6 ++++
 .../android/nostr/GeohashAliasRegistry.kt     | 30 +++++++++++++++--
 .../nostr/GeohashConversationRegistry.kt      | 33 +++++++++++++++++--
 .../bitchat/android/ui/GeohashViewModel.kt    |  8 +++--
 .../bitchat/android/ui/PrivateChatManager.kt  | 10 ++++++
 5 files changed, 81 insertions(+), 6 deletions(-)

diff --git a/app/src/main/java/com/gap/droid/BitchatApplication.kt b/app/src/main/java/com/gap/droid/BitchatApplication.kt
index b120b21..59cb7ec 100644
--- a/app/src/main/java/com/gap/droid/BitchatApplication.kt
+++ b/app/src/main/java/com/gap/droid/BitchatApplication.kt
@@ -41,6 +41,12 @@ class BitchatApplication : Application() {
         // Initialize debug preference manager (persists debug toggles)
         try { com.gap.droid.ui.debug.DebugPreferenceManager.init(this) } catch (_: Exception) { }
 
+        // Initialize Geohash Registries for persistence
+        try {
+            com.gap.droid.nostr.GeohashAliasRegistry.initialize(this)
+            com.gap.droid.nostr.GeohashConversationRegistry.initialize(this)
+        } catch (_: Exception) { }
+
         // Initialize mesh service preferences
         try { com.gap.droid.service.MeshServicePreferences.init(this) } catch (_: Exception) { }
 
diff --git a/app/src/main/java/com/gap/droid/nostr/GeohashAliasRegistry.kt b/app/src/main/java/com/gap/droid/nostr/GeohashAliasRegistry.kt
index ea2ab0b..9ead248 100644
--- a/app/src/main/java/com/gap/droid/nostr/GeohashAliasRegistry.kt
+++ b/app/src/main/java/com/gap/droid/nostr/GeohashAliasRegistry.kt
@@ -1,17 +1,40 @@
 package com.gap.droid.nostr
 
+import android.content.Context
+import android.content.SharedPreferences
 import java.util.concurrent.ConcurrentHashMap
 
 /**
  * GeohashAliasRegistry
  * - Global, thread-safe registry for alias->Nostr pubkey mappings (e.g., nostr_<pub16> -> pubkeyHex)
- * - Allows non-UI components (e.g., MessageRouter) to resolve geohash DM aliases without depending on UI ViewModels
+ * - Persisted to SharedPreferences to survive app restarts.
  */
 object GeohashAliasRegistry {
     private val map: MutableMap<String, String> = ConcurrentHashMap()
+    private const val PREFS_NAME = "geohash_alias_registry"
+    private var prefs: SharedPreferences? = null
+
+    fun initialize(context: Context) {
+        if (prefs == null) {
+            prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
+            loadFromPrefs()
+        }
+    }
+
+    private fun loadFromPrefs() {
+        prefs?.let { p ->
+            val allEntries = p.all
+            for ((key, value) in allEntries) {
+                if (key is String && value is String) {
+                    map[key] = value
+                }
+            }
+        }
+    }
 
     fun put(alias: String, pubkeyHex: String) {
         map[alias] = pubkeyHex
+        prefs?.edit()?.putString(alias, pubkeyHex)?.apply()
     }
 
     fun get(alias: String): String? = map[alias]
@@ -20,5 +43,8 @@ object GeohashAliasRegistry {
 
     fun snapshot(): Map<String, String> = HashMap(map)
 
-    fun clear() { map.clear() }
+    fun clear() {
+        map.clear()
+        prefs?.edit()?.clear()?.apply()
+    }
 }
diff --git a/app/src/main/java/com/gap/droid/nostr/GeohashConversationRegistry.kt b/app/src/main/java/com/gap/droid/nostr/GeohashConversationRegistry.kt
index 0ae2a6d..68c1b29 100644
--- a/app/src/main/java/com/gap/droid/nostr/GeohashConversationRegistry.kt
+++ b/app/src/main/java/com/gap/droid/nostr/GeohashConversationRegistry.kt
@@ -1,22 +1,51 @@
 package com.gap.droid.nostr
 
+import android.content.Context
+import android.content.SharedPreferences
 import java.util.concurrent.ConcurrentHashMap
 
 /**
  * GeohashConversationRegistry
  * - Global, thread-safe registry of conversationKey (e.g., "nostr_<pub16>") -> source geohash
  * - Enables routing geohash DMs from anywhere by providing the correct geohash identity
+ * - Persisted to SharedPreferences to survive app restarts.
  */
 object GeohashConversationRegistry {
     private val map = ConcurrentHashMap<String, String>()
+    private const val PREFS_NAME = "geohash_conversation_registry"
+    private var prefs: SharedPreferences? = null
+
+    fun initialize(context: Context) {
+        if (prefs == null) {
+            prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
+            loadFromPrefs()
+        }
+    }
+
+    private fun loadFromPrefs() {
+        prefs?.let { p ->
+            val allEntries = p.all
+            for ((key, value) in allEntries) {
+                if (key is String && value is String) {
+                    map[key] = value
+                }
+            }
+        }
+    }
 
     fun set(convKey: String, geohash: String) {
-        if (geohash.isNotEmpty()) map[convKey] = geohash
+        if (geohash.isNotEmpty()) {
+            map[convKey] = geohash
+            prefs?.edit()?.putString(convKey, geohash)?.apply()
+        }
     }
 
     fun get(convKey: String): String? = map[convKey]
 
     fun snapshot(): Map<String, String> = map.toMap()
 
-    fun clear() = map.clear()
+    fun clear() {
+        map.clear()
+        prefs?.edit()?.clear()?.apply()
+    }
 }
diff --git a/app/src/main/java/com/gap/droid/ui/GeohashViewModel.kt b/app/src/main/java/com/gap/droid/ui/GeohashViewModel.kt
index 52e00ed..4d66e30 100644
--- a/app/src/main/java/com/gap/droid/ui/GeohashViewModel.kt
+++ b/app/src/main/java/com/gap/droid/ui/GeohashViewModel.kt
@@ -12,6 +12,8 @@ import com.gap.droid.nostr.NostrProtocol
 import com.gap.droid.nostr.NostrRelayManager
 import com.gap.droid.nostr.NostrSubscriptionManager
 import com.gap.droid.nostr.PoWPreferenceManager
+import com.gap.droid.nostr.GeohashAliasRegistry
+import com.gap.droid.nostr.GeohashConversationRegistry
 import kotlinx.coroutines.Job
 import kotlinx.coroutines.delay
 import kotlinx.coroutines.flow.StateFlow
@@ -93,6 +95,8 @@ class GeohashViewModel(
 
     fun panicReset() {
         repo.clearAll()
+        GeohashAliasRegistry.clear()
+        GeohashConversationRegistry.clear()
         subscriptionManager.disconnect()
         currentGeohashSubId = null
         currentDmSubId = null
@@ -168,7 +172,7 @@ class GeohashViewModel(
         val gh = (current as? com.gap.droid.geohash.ChannelID.Location)?.channel?.geohash
         if (!gh.isNullOrEmpty()) {
             repo.setConversationGeohash(convKey, gh)
-            com.gap.droid.nostr.GeohashConversationRegistry.set(convKey, gh)
+            GeohashConversationRegistry.set(convKey, gh)
         }
         onStartPrivateChat(convKey)
         Log.d(TAG, "ðŸ—¨ï¸ Started geohash DM with ${pubkeyHex} -> ${convKey} (geohash=${gh})")
@@ -260,7 +264,7 @@ class GeohashViewModel(
                         handler = { event -> dmHandler.onGiftWrap(event, geohash, dmIdentity) }
                     )
                     // Also register alias in global registry for routing convenience
-                    com.gap.droid.nostr.GeohashAliasRegistry.put("nostr_${dmIdentity.publicKeyHex.take(16)}", dmIdentity.publicKeyHex)
+                    GeohashAliasRegistry.put("nostr_${dmIdentity.publicKeyHex.take(16)}", dmIdentity.publicKeyHex)
                 }
             }
             null -> {
diff --git a/app/src/main/java/com/gap/droid/ui/PrivateChatManager.kt b/app/src/main/java/com/gap/droid/ui/PrivateChatManager.kt
index 098a83d..53cc22b 100644
--- a/app/src/main/java/com/gap/droid/ui/PrivateChatManager.kt
+++ b/app/src/main/java/com/gap/droid/ui/PrivateChatManager.kt
@@ -298,6 +298,16 @@ class PrivateChatManager(
             if (!isPeerBlocked(senderPeerID)) {
                 // Ensure chat exists
                 messageManager.initializePrivateChat(senderPeerID)
+
+                // Exception: Nostr messages (nostr_ prefix) originate in Kotlin layer and MUST be added here.
+                if (senderPeerID.startsWith("nostr_")) {
+                    if (suppressUnread) {
+                        messageManager.addPrivateMessageNoUnread(senderPeerID, message)
+                    } else {
+                        messageManager.addPrivateMessage(senderPeerID, message)
+                    }
+                }
+
                 // Track as unread for read receipt purposes if not focused
                 if (!suppressUnread && state.getSelectedPrivateChatPeerValue() != senderPeerID) {
                     val unreadList = unreadReceivedMessages.getOrPut(senderPeerID) { mutableListOf() }
-- 
2.50.1 (Apple Git-155)


From e40fd106d73c8cbddd3b45e76ac8b8ebb19dcdd0 Mon Sep 17 00:00:00 2001
From: yet300 <96379204+yet300@users.noreply.github.com>
Date: Mon, 12 Jan 2026 12:10:07 +0400
Subject: [PATCH 06/10] New MeshPeerListSheet as Ios like  (#498)

* Automated update of relay data - Sun Sep 21 06:21:05 UTC 2025

* Automated update of relay data - Sun Sep 28 06:20:40 UTC 2025

* refactor: new close button like ios(but not liquid glass)

* Automated update of relay data - Sun Oct  5 06:20:09 UTC 2025

* Automated update of relay data - Sun Oct 12 06:20:12 UTC 2025

* Automated update of relay data - Sun Oct 19 06:21:51 UTC 2025

* Refactor: Redesign peer and channel list as a bottom sheet

Replaced the right-hand sidebar with a Material 3 `ModalBottomSheet` for displaying mesh peers and channels. This modernizes the UI and improves usability.

- Renamed `SidebarComponents.kt` to `MeshPeerListSheet.kt`.
- Replaced the custom sidebar implementation with `ModalBottomSheet`.
- Added a floating top bar to the sheet that appears on scroll, displaying the title and a close button.
- Updated the row layouts for both channels and peers to use `Surface` for better visual grouping and selection state handling.
- Added a checkmark icon to indicate the currently selected channel or private chat peer.
- Improved styling for section headers, unread badges, and empty-state text.
- Removed the `SignalStrengthIndicator` as it was no longer used.

* Refactor: Remove sidebar state management from ViewModel

This commit removes the state management for the sidebar's visibility from `ChatViewModel` and `ChatState`.

The sidebar's visibility is now a purely UI-level concern and is no longer coupled with the ViewModel's logic. This change simplifies the ViewModel by removing unnecessary LiveData and related methods (`showSidebar`, `hideSidebar`). The back navigation handler has also been updated to remove the case for closing the sidebar.

* Refactor: Replace Sidebar with MeshPeerList Bottom Sheet

* feat: Add nested private chat sheet

* Feat: Enhance UI/UX of LocationNotesSheet

This commit refactors the `LocationNotesSheet` to more closely align with its iOS counterpart, improving both its appearance and user experience.

The layout has been updated to use a `Box` with aligned elements instead of a single `Column`, allowing for a floating input section at the bottom and a floating close button at the top right.

**Key Changes:**

-   **Floating Top Bar and Input:**
    -   The main content is now a `LazyColumn` that scrolls underneath a new floating top bar and a floating input section at the bottom.
    -   The top bar's background animates from transparent to semi-opaque as the user scrolls, providing a "blur" effect.

-   **iOS-Style Close Button:**
    -   The close button is moved from the header row to the top-right corner of the sheet, where it remains fixed.

-   **Structural Refinements:**
    -   Replaced the main `Column` with a `Box` to manage the layout of the scrollable content, top bar, and input section.
    -   Removed the `onClose` parameter from `LocationNotesHeader` as the close button is now managed separately.
    -   Added `statusBarsPadding` to the `ModalBottomSheet` to prevent content from rendering under the system status bar.
    -   Adjusted spacing and padding for better visual consistency.

* refactor: Use collectAsStateWithLifecycle

Migrates LiveData observation from `observeAsState` to `collectAsStateWithLifecycle` for improved lifecycle-aware state collection in `MeshPeerListSheet`.

This also includes the following related changes:
*   Removes an unused `showSidebar` state flow from `ChatViewModel`.
*   Replaces fully qualified `com.gap.droid.ui.splitSuffix` calls with a direct `splitSuffix` call.
*   Updates resource string access to use the `R` import.

* feat: Add verification status indicators

- Add peer verification status icons to the peer list.
- Add a button to the channel list to show the verification QR code.
- Remove the unused `SidebarComponents.kt` file.

* Refactor: Add state for mesh peer list visibility

* Refactor: Move mesh peer list state to ViewModel

* refactor: Move QR code icon from channel items to footer

The verification (QR code) icon is relocated from being repeated on each channel list item to a single, centralized position in the sheet's footer.

This icon is now only displayed when not in a location-based channel. The `onShowVerification` parameter has been removed from `ChannelListItem` as it's no longer needed there.

* feat: Show verified status for peers

---------

Co-authored-by: GitHub Action <action@github.com>
---
 .../java/com/bitchat/android/ui/ChatScreen.kt |   71 +-
 .../java/com/bitchat/android/ui/ChatState.kt  |   24 +-
 .../com/bitchat/android/ui/ChatViewModel.kt   |   32 +-
 .../bitchat/android/ui/LocationNotesSheet.kt  |  241 ++--
 .../bitchat/android/ui/MeshPeerListSheet.kt   | 1045 +++++++++++++++++
 .../bitchat/android/ui/SidebarComponents.kt   |  753 ------------
 6 files changed, 1211 insertions(+), 955 deletions(-)
 create mode 100644 app/src/main/java/com/gap/droid/ui/MeshPeerListSheet.kt
 delete mode 100644 app/src/main/java/com/gap/droid/ui/SidebarComponents.kt

diff --git a/app/src/main/java/com/gap/droid/ui/ChatScreen.kt b/app/src/main/java/com/gap/droid/ui/ChatScreen.kt
index bf6a73b..9b26573 100644
--- a/app/src/main/java/com/gap/droid/ui/ChatScreen.kt
+++ b/app/src/main/java/com/gap/droid/ui/ChatScreen.kt
@@ -5,7 +5,6 @@ package com.gap.droid.ui
 
 
 import androidx.compose.animation.*
-import androidx.compose.animation.core.*
 import androidx.compose.foundation.*
 import androidx.compose.foundation.layout.*
 import androidx.compose.material3.*
@@ -51,12 +50,12 @@ fun ChatScreen(viewModel: ChatViewModel) {
     val hasUnreadPrivateMessages by viewModel.unreadPrivateMessages.collectAsStateWithLifecycle()
     val privateChats by viewModel.privateChats.collectAsStateWithLifecycle()
     val channelMessages by viewModel.channelMessages.collectAsStateWithLifecycle()
-    val showSidebar by viewModel.showSidebar.collectAsStateWithLifecycle()
     val showCommandSuggestions by viewModel.showCommandSuggestions.collectAsStateWithLifecycle()
     val commandSuggestions by viewModel.commandSuggestions.collectAsStateWithLifecycle()
     val showMentionSuggestions by viewModel.showMentionSuggestions.collectAsStateWithLifecycle()
     val mentionSuggestions by viewModel.mentionSuggestions.collectAsStateWithLifecycle()
     val showAppInfo by viewModel.showAppInfo.collectAsStateWithLifecycle()
+    val showMeshPeerListSheet by viewModel.showMeshPeerList.collectAsStateWithLifecycle()
     val showVerificationSheet by viewModel.showVerificationSheet.collectAsStateWithLifecycle()
     val showSecurityVerificationSheet by viewModel.showSecurityVerificationSheet.collectAsStateWithLifecycle()
 
@@ -249,7 +248,7 @@ fun ChatScreen(viewModel: ChatViewModel) {
             nickname = nickname,
             viewModel = viewModel,
             colorScheme = colorScheme,
-            onSidebarToggle = { viewModel.showSidebar() },
+            onSidebarToggle = { viewModel.showMeshPeerList() },
             onShowAppInfo = { viewModel.showAppInfo() },
             onPanicClear = { viewModel.panicClearAllData() },
             onLocationChannelsClick = { showLocationChannelsSheet = true },
@@ -266,28 +265,9 @@ fun ChatScreen(viewModel: ChatViewModel) {
             color = colorScheme.outline.copy(alpha = 0.3f)
         )
 
-        val alpha by animateFloatAsState(
-            targetValue = if (showSidebar) 0.5f else 0f,
-            animationSpec = tween(
-                durationMillis = 300,
-                easing = EaseOutCubic
-            ), label = "overlayAlpha"
-        )
-
-        // Only render the background if it's visible
-        if (alpha > 0f) {
-            Box(
-                modifier = Modifier
-                    .fillMaxSize()
-                    .background(Color.Black.copy(alpha = alpha))
-                    .clickable { viewModel.hideSidebar() }
-                    .zIndex(1f)
-            )
-        }
-
         // Scroll-to-bottom floating button
         AnimatedVisibility(
-            visible = isScrolledUp && !showSidebar,
+            visible = isScrolledUp,
             enter = slideInVertically(initialOffsetY = { it / 2 }) + fadeIn(),
             exit = slideOutVertically(targetOffsetY = { it / 2 }) + fadeOut(),
             modifier = Modifier
@@ -313,29 +293,6 @@ fun ChatScreen(viewModel: ChatViewModel) {
                 }
             }
         }
-
-        AnimatedVisibility(
-            visible = showSidebar,
-            enter = slideInHorizontally(
-                initialOffsetX = { it },
-                animationSpec = tween(300, easing = EaseOutCubic)
-            ) + fadeIn(animationSpec = tween(300)),
-            exit = slideOutHorizontally(
-                targetOffsetX = { it },
-                animationSpec = tween(250, easing = EaseInCubic)
-            ) + fadeOut(animationSpec = tween(250)),
-            modifier = Modifier.zIndex(2f)
-        ) {
-            SidebarOverlay(
-                viewModel = viewModel,
-                onDismiss = { viewModel.hideSidebar() },
-                onShowVerification = {
-                    viewModel.showVerificationSheet(fromSidebar = true)
-                    viewModel.hideSidebar()
-                },
-                modifier = Modifier.fillMaxSize()
-            )
-        }
     }
 
     // Full-screen image viewer - separate from other sheets to allow image browsing without navigation
@@ -383,12 +340,14 @@ fun ChatScreen(viewModel: ChatViewModel) {
         showVerificationSheet = showVerificationSheet,
         onVerificationSheetDismiss = viewModel::hideVerificationSheet,
         showSecurityVerificationSheet = showSecurityVerificationSheet,
-        onSecurityVerificationSheetDismiss = viewModel::hideSecurityVerificationSheet
+        onSecurityVerificationSheetDismiss = viewModel::hideSecurityVerificationSheet,
+        showMeshPeerListSheet = showMeshPeerListSheet,
+        onMeshPeerListDismiss = viewModel::hideMeshPeerList,
     )
 }
 
 @Composable
-private fun ChatInputSection(
+fun ChatInputSection(
     messageText: TextFieldValue,
     onMessageTextChange: (TextFieldValue) -> Unit,
     onSend: () -> Unit,
@@ -527,7 +486,9 @@ private fun ChatDialogs(
     showVerificationSheet: Boolean,
     onVerificationSheetDismiss: () -> Unit,
     showSecurityVerificationSheet: Boolean,
-    onSecurityVerificationSheetDismiss: () -> Unit
+    onSecurityVerificationSheetDismiss: () -> Unit,
+    showMeshPeerListSheet: Boolean,
+    onMeshPeerListDismiss: () -> Unit,
 ) {
     // Password dialog
     PasswordPromptDialog(
@@ -581,6 +542,18 @@ private fun ChatDialogs(
             viewModel = viewModel
         )
     }
+    // MeshPeerList sheet (network view)
+    if (showMeshPeerListSheet){
+        MeshPeerListSheet(
+            isPresented = showMeshPeerListSheet,
+            viewModel = viewModel,
+            onDismiss = onMeshPeerListDismiss,
+            onShowVerification = {
+                onMeshPeerListDismiss()
+                viewModel.showVerificationSheet(fromSidebar = true)
+            }
+        )
+    }
 
     if (showVerificationSheet) {
         VerificationSheet(
diff --git a/app/src/main/java/com/gap/droid/ui/ChatState.kt b/app/src/main/java/com/gap/droid/ui/ChatState.kt
index c4ae3db..50a77f5 100644
--- a/app/src/main/java/com/gap/droid/ui/ChatState.kt
+++ b/app/src/main/java/com/gap/droid/ui/ChatState.kt
@@ -76,11 +76,7 @@ class ChatState(
     
     private val _passwordPromptChannel = MutableStateFlow<String?>(null)
     val passwordPromptChannel: StateFlow<String?> = _passwordPromptChannel.asStateFlow()
-    
-    // Sidebar state
-    private val _showSidebar = MutableStateFlow(false)
-    val showSidebar: StateFlow<Boolean> = _showSidebar.asStateFlow()
-    
+
     // Command autocomplete
     private val _showCommandSuggestions = MutableStateFlow(false)
     val showCommandSuggestions: StateFlow<Boolean> = _showCommandSuggestions.asStateFlow()
@@ -123,6 +119,9 @@ class ChatState(
     private val _showAppInfo = MutableStateFlow<Boolean>(false)
     val showAppInfo: StateFlow<Boolean> = _showAppInfo.asStateFlow()
 
+    private val _showMeshPeerList = MutableStateFlow(false)
+    val showMeshPeerList: StateFlow<Boolean> = _showMeshPeerList.asStateFlow()
+
     private val _showVerificationSheet = MutableStateFlow(false)
     val showVerificationSheet: StateFlow<Boolean> = _showVerificationSheet.asStateFlow()
 
@@ -155,7 +154,7 @@ class ChatState(
             started = WhileSubscribed(5_000),
             initialValue = false
         )
-    
+
     val hasUnreadPrivateMessages: StateFlow<Boolean> = _unreadPrivateMessages
         .map { unreadSet -> unreadSet.isNotEmpty() }
         .stateIn(
@@ -178,7 +177,6 @@ class ChatState(
     fun getPasswordProtectedChannelsValue() = _passwordProtectedChannels.value
     fun getShowPasswordPromptValue() = _showPasswordPrompt.value
     fun getPasswordPromptChannelValue() = _passwordPromptChannel.value
-    fun getShowSidebarValue() = _showSidebar.value
     fun getShowCommandSuggestionsValue() = _showCommandSuggestions.value
     fun getCommandSuggestionsValue() = _commandSuggestions.value
     fun getShowMentionSuggestionsValue() = _showMentionSuggestions.value
@@ -188,6 +186,9 @@ class ChatState(
     fun getPeerFingerprintsValue() = _peerFingerprints.value
     fun getShowAppInfoValue() = _showAppInfo.value
     fun getGeohashPeopleValue() = _geohashPeople.value
+
+    fun getShowMeshPeerListValue() = _showMeshPeerList.value
+
     fun getTeleportedGeoValue() = _teleportedGeo.value
     fun getGeohashParticipantCountsValue() = _geohashParticipantCounts.value
     
@@ -251,11 +252,7 @@ class ChatState(
     fun setPasswordPromptChannel(channel: String?) {
         _passwordPromptChannel.value = channel
     }
-    
-    fun setShowSidebar(show: Boolean) {
-        _showSidebar.value = show
-    }
-    
+
     fun setShowCommandSuggestions(show: Boolean) {
         _showCommandSuggestions.value = show
     }
@@ -337,4 +334,7 @@ class ChatState(
         _geohashParticipantCounts.value = counts
     }
 
+    fun setShowMeshPeerList(show: Boolean) {
+        _showMeshPeerList.value = show
+    }
 }
diff --git a/app/src/main/java/com/gap/droid/ui/ChatViewModel.kt b/app/src/main/java/com/gap/droid/ui/ChatViewModel.kt
index 7510189..07a5eea 100644
--- a/app/src/main/java/com/gap/droid/ui/ChatViewModel.kt
+++ b/app/src/main/java/com/gap/droid/ui/ChatViewModel.kt
@@ -157,7 +157,6 @@ class ChatViewModel(
     val passwordProtectedChannels: StateFlow<Set<String>> = state.passwordProtectedChannels
     val showPasswordPrompt: StateFlow<Boolean> = state.showPasswordPrompt
     val passwordPromptChannel: StateFlow<String?> = state.passwordPromptChannel
-    val showSidebar: StateFlow<Boolean> = state.showSidebar
     val hasUnreadChannels = state.hasUnreadChannels
     val hasUnreadPrivateMessages = state.hasUnreadPrivateMessages
     val showCommandSuggestions: StateFlow<Boolean> = state.showCommandSuggestions
@@ -171,6 +170,7 @@ class ChatViewModel(
     val peerRSSI: StateFlow<Map<String, Int>> = state.peerRSSI
     val peerDirect: StateFlow<Map<String, Boolean>> = state.peerDirect
     val showAppInfo: StateFlow<Boolean> = state.showAppInfo
+    val showMeshPeerList: StateFlow<Boolean> = state.showMeshPeerList
     val showVerificationSheet: StateFlow<Boolean> = state.showVerificationSheet
     val showSecurityVerificationSheet: StateFlow<Boolean> = state.showSecurityVerificationSheet
     val selectedLocationChannel: StateFlow<com.gap.droid.geohash.ChannelID?> = state.selectedLocationChannel
@@ -452,11 +452,6 @@ class ChatViewModel(
             }
 
             startPrivateChat(openPeer)
-
-            // If sidebar visible, hide it to focus on the private chat
-            if (state.getShowSidebarValue()) {
-                state.setShowSidebar(false)
-            }
         } catch (e: Exception) {
             Log.w(TAG, "openLatestUnreadPrivateChat failed: ${e.message}")
         }
@@ -783,7 +778,7 @@ class ChatViewModel(
         state.setShowVerificationSheet(false)
         if (reopenSidebarAfterVerification) {
             reopenSidebarAfterVerification = false
-            state.setShowSidebar(true)
+            state.setShowMeshPeerList(true)
         }
     }
 
@@ -795,6 +790,14 @@ class ChatViewModel(
         state.setShowSecurityVerificationSheet(false)
     }
 
+    fun showMeshPeerList() {
+        state.setShowMeshPeerList(true)
+    }
+
+    fun hideMeshPeerList() {
+        state.setShowMeshPeerList(false)
+    }
+
     fun getPeerFingerprintForDisplay(peerID: String): String? {
         return verificationHandler.getPeerFingerprintForDisplay(peerID)
     }
@@ -1027,15 +1030,7 @@ class ChatViewModel(
     fun hideAppInfo() {
         state.setShowAppInfo(false)
     }
-    
-    fun showSidebar() {
-        state.setShowSidebar(true)
-    }
-    
-    fun hideSidebar() {
-        state.setShowSidebar(false)
-    }
-    
+
     /**
      * Handle Android back navigation
      * Returns true if the back press was handled, false if it should be passed to the system
@@ -1047,11 +1042,6 @@ class ChatViewModel(
                 hideAppInfo()
                 true
             }
-            // Close sidebar
-            state.getShowSidebarValue() -> {
-                hideSidebar()
-                true
-            }
             // Close password dialog
             state.getShowPasswordPromptValue() -> {
                 state.setShowPasswordPrompt(false)
diff --git a/app/src/main/java/com/gap/droid/ui/LocationNotesSheet.kt b/app/src/main/java/com/gap/droid/ui/LocationNotesSheet.kt
index 461796d..93b6d51 100644
--- a/app/src/main/java/com/gap/droid/ui/LocationNotesSheet.kt
+++ b/app/src/main/java/com/gap/droid/ui/LocationNotesSheet.kt
@@ -1,5 +1,6 @@
 package com.gap.droid.ui
 
+import androidx.compose.animation.core.animateFloatAsState
 import androidx.compose.foundation.background
 import androidx.compose.foundation.clickable
 import androidx.compose.foundation.isSystemInDarkTheme
@@ -12,6 +13,7 @@ import androidx.compose.material.icons.Icons
 import androidx.compose.material.icons.filled.ArrowUpward
 import androidx.compose.material3.*
 import androidx.compose.runtime.*
+import androidx.compose.runtime.getValue
 import androidx.compose.ui.Alignment
 import androidx.compose.ui.Modifier
 import androidx.compose.ui.draw.clip
@@ -76,7 +78,16 @@ fun LocationNotesSheet(
     
     // Scroll state
     val listState = rememberLazyListState()
-    
+    val isScrolled by remember {
+        derivedStateOf {
+            listState.firstVisibleItemIndex > 0 || listState.firstVisibleItemScrollOffset > 0
+        }
+    }
+    val topBarAlpha by animateFloatAsState(
+        targetValue = if (isScrolled) 0.95f else 0f,
+        label = "topBarAlpha"
+    )
+
     // Effect to set geohash when sheet opens
     LaunchedEffect(geohash) {
         notesManager.setGeohash(geohash)
@@ -91,102 +102,118 @@ fun LocationNotesSheet(
     
     ModalBottomSheet(
         onDismissRequest = onDismiss,
-        modifier = modifier,
+        modifier = modifier.statusBarsPadding(),
         sheetState = rememberModalBottomSheetState(skipPartiallyExpanded = true),
+        dragHandle = null,
         containerColor = backgroundColor,
         contentColor = if (isDark) Color.White else Color.Black
     ) {
-        Column(
-            modifier = Modifier
-                .fillMaxWidth()
-                .fillMaxHeight(0.9f)
-        ) {
-            // Header section (matches iOS headerSection)
-            LocationNotesHeader(
-                geohash = geohash,
-                count = count,
-                locationName = displayLocationName,
-                state = state,
-                accentGreen = accentGreen,
-                backgroundColor = backgroundColor,
-                onClose = onDismiss
-            )
-            
-            // ScrollView with notes content
-            Box(
-                modifier = Modifier
-                    .weight(1f)
-                    .fillMaxWidth()
-                    .background(backgroundColor)
+        Box(modifier = Modifier.fillMaxWidth()) {
+            LazyColumn(
+                state = listState,
+                modifier = Modifier.fillMaxSize().padding(horizontal = 16.dp),
+                contentPadding = PaddingValues(top = 64.dp, bottom = 20.dp)
             ) {
-                LazyColumn(
-                    state = listState,
-                    modifier = Modifier.fillMaxSize(),
-                    contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp)
-                ) {
-                    // Notes content (matches iOS notesContent)
-                    when {
-                        state == LocationNotesManager.State.NO_RELAYS -> {
-                            item {
-                                NoRelaysRow(
-                                    onRetry = { notesManager.refresh() }
-                                )
-                            }
+                item(key = "notes_header") {
+                    LocationNotesHeader(
+                        geohash = geohash,
+                        count = count,
+                        locationName = displayLocationName,
+                        state = state,
+                        accentGreen = accentGreen,
+                        backgroundColor = backgroundColor
+                    )
+                }
+
+                // Notes content (matches iOS notesContent)
+                when {
+                    state == LocationNotesManager.State.NO_RELAYS -> {
+                        item {
+                            NoRelaysRow(
+                                onRetry = { notesManager.refresh() }
+                            )
                         }
-                        state == LocationNotesManager.State.LOADING && !initialLoadComplete -> {
-                            item {
-                                LoadingRow()
-                            }
+                    }
+                    state == LocationNotesManager.State.LOADING && !initialLoadComplete -> {
+                        item {
+                            LoadingRow()
                         }
-                        notes.isEmpty() -> {
-                            item {
-                                EmptyRow()
-                            }
+                    }
+                    notes.isEmpty() -> {
+                        item {
+                            EmptyRow()
                         }
-                        else -> {
-                            items(notes, key = { it.id }) { note ->
-                                NoteRow(note = note)
-                                Spacer(modifier = Modifier.height(12.dp))
-                            }
+                    }
+                    else -> {
+                        items(notes, key = { it.id }) { note ->
+                            NoteRow(note = note)
+                            Spacer(modifier = Modifier.height(24.dp))
+                        }
+                        item {
+                            Spacer(modifier = Modifier.height(24.dp))
                         }
                     }
-                    
-                    // Error row (matches iOS errorRow)
-                    errorMessage?.let { error ->
-                        if (state != LocationNotesManager.State.NO_RELAYS) {
-                            item {
-                                ErrorRow(
-                                    message = error,
-                                    onDismiss = { notesManager.clearError() }
-                                )
-                            }
+                }
+
+                // Error row (matches iOS errorRow)
+                errorMessage?.let { error ->
+                    if (state != LocationNotesManager.State.NO_RELAYS) {
+                        item {
+                            ErrorRow(
+                                message = error,
+                                onDismiss = { notesManager.clearError() }
+                            )
                         }
                     }
                 }
             }
-            
-            // Divider before input (matches iOS overlay)
-            HorizontalDivider(
-                modifier = Modifier.fillMaxWidth(),
-                color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f),
-                thickness = 1.dp
-            )
-            
-            // Input section (matches iOS inputSection)
-            LocationNotesInputSection(
-                draft = draft,
-                onDraftChange = { draft = it },
-                sendButtonEnabled = sendButtonEnabled,
-                accentGreen = accentGreen,
-                backgroundColor = backgroundColor,
-                onSend = {
-                    val content = draft.trim()
-                    if (content.isNotEmpty()) {
-                        notesManager.send(content, nickname)
-                        draft = ""
-                    }
+
+            // TopBar (animated)
+            Box(
+                modifier = Modifier
+                    .align(Alignment.TopCenter)
+                    .fillMaxWidth()
+                    .height(64.dp)
+                    .background(MaterialTheme.colorScheme.background.copy(alpha = topBarAlpha))
+            ) {
+                CloseButton(
+                    onClick = onDismiss,
+                    modifier = Modifier
+                        .align(Alignment.CenterEnd)
+                        .padding(horizontal = 16.dp)
+                )
+            }
+
+            Box(
+                modifier = Modifier
+                    .align(Alignment.BottomCenter)
+                    .fillMaxWidth()
+            ){
+                Column {
+                    // Divider before input (matches iOS overlay)
+                    HorizontalDivider(
+                        modifier = Modifier.fillMaxWidth(),
+                        color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f),
+                        thickness = 1.dp
+                    )
+
+                    // Input section (matches iOS inputSection)
+                    LocationNotesInputSection(
+                        draft = draft,
+                        onDraftChange = { draft = it },
+                        sendButtonEnabled = sendButtonEnabled,
+                        accentGreen = accentGreen,
+                        backgroundColor = backgroundColor,
+                        onSend = {
+                            val content = draft.trim()
+                            if (content.isNotEmpty()) {
+                                notesManager.send(content, nickname)
+                                draft = ""
+                            }
+                        }
+                    )
                 }
-            )
+            }
         }
     }
 }
@@ -203,51 +230,25 @@ private fun LocationNotesHeader(
     state: LocationNotesManager.State,
     accentGreen: Color,
     backgroundColor: Color,
-    onClose: () -> Unit
 ) {
     Column(
         modifier = Modifier
             .fillMaxWidth()
             .background(backgroundColor)
-            .padding(horizontal = 16.dp)
             .padding(top = 16.dp, bottom = 12.dp)
     ) {
-        // Title row with close button
-        Row(
-            modifier = Modifier.fillMaxWidth(),
-            horizontalArrangement = Arrangement.SpaceBetween,
-            verticalAlignment = Alignment.CenterVertically
-        ) {
-            // Localized title with Â±1 and note count
-            Text(
-                text = pluralStringResource(
-                    id = R.plurals.location_notes_title,
-                    count = count,
-                    geohash,
-                    count
-                ),
-                fontFamily = FontFamily.Monospace,
-                fontSize = 18.sp,
-                color = MaterialTheme.colorScheme.onSurface
-            )
-            
-            // Close button - iOS style with xmark icon
-            Box(
-                modifier = Modifier
-                    .size(32.dp)
-                    .clickable(onClick = onClose),
-                contentAlignment = Alignment.Center
-            ) {
-                Text(
-                    text = "âœ•",
-                    fontFamily = FontFamily.Monospace,
-                    fontSize = 13.sp,
-                    fontWeight = FontWeight.SemiBold,
-                    color = MaterialTheme.colorScheme.onSurface
-                )
-            }
-        }
-        
+        // Localized title with Â±1 and note count
+        Text(
+            text = pluralStringResource(
+                id = R.plurals.location_notes_title,
+                count = count,
+                geohash,
+                count
+            ),
+            fontFamily = FontFamily.Monospace,
+            fontSize = 18.sp,
+            color = MaterialTheme.colorScheme.onSurface
+        )
         Spacer(modifier = Modifier.height(8.dp))
         
         // Location name in green (building or block)
diff --git a/app/src/main/java/com/gap/droid/ui/MeshPeerListSheet.kt b/app/src/main/java/com/gap/droid/ui/MeshPeerListSheet.kt
new file mode 100644
index 0000000..e2f1694
--- /dev/null
+++ b/app/src/main/java/com/gap/droid/ui/MeshPeerListSheet.kt
@@ -0,0 +1,1045 @@
+package com.gap.droid.ui
+
+import com.gap.droid.R
+import android.util.Log
+import androidx.compose.animation.core.animateFloatAsState
+import androidx.compose.foundation.*
+import androidx.compose.foundation.layout.*
+import androidx.compose.foundation.lazy.LazyColumn
+import androidx.compose.foundation.lazy.items
+import androidx.compose.foundation.lazy.rememberLazyListState
+import androidx.compose.foundation.shape.RoundedCornerShape
+import androidx.compose.material.icons.Icons
+import androidx.compose.material.icons.automirrored.filled.ArrowBack
+import androidx.compose.material.icons.filled.*
+import androidx.compose.material.icons.outlined.*
+import androidx.compose.material3.*
+import androidx.compose.runtime.*
+import androidx.compose.ui.Alignment
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.graphics.Color
+import androidx.compose.ui.res.stringResource
+import androidx.compose.ui.text.font.FontFamily
+import androidx.compose.ui.text.font.FontWeight
+import androidx.compose.ui.unit.dp
+import androidx.compose.ui.unit.sp
+import androidx.compose.ui.text.style.TextOverflow
+import androidx.lifecycle.compose.collectAsStateWithLifecycle
+import com.gap.droid.geohash.ChannelID
+import com.gap.droid.ui.theme.BASE_FONT_SIZE
+
+
+/**
+ * Sheet components for ChatScreen
+ * Extracted from ChatScreen.kt for better organization
+ */
+
+@OptIn(ExperimentalMaterial3Api::class)
+@Composable
+fun MeshPeerListSheet(
+    isPresented: Boolean,
+    viewModel: ChatViewModel,
+    onDismiss: () -> Unit,
+    onShowVerification: () -> Unit,
+    modifier: Modifier = Modifier
+) {
+    val colorScheme = MaterialTheme.colorScheme
+
+    val connectedPeers by viewModel.connectedPeers.collectAsStateWithLifecycle()
+    val joinedChannels by viewModel.joinedChannels.collectAsStateWithLifecycle()
+    val currentChannel by viewModel.currentChannel.collectAsStateWithLifecycle()
+    val selectedPrivatePeer by viewModel.selectedPrivateChatPeer.collectAsStateWithLifecycle()
+    val nickname by viewModel.nickname.collectAsStateWithLifecycle()
+    val unreadChannelMessages by viewModel.unreadChannelMessages.collectAsStateWithLifecycle()
+    val peerNicknames by viewModel.peerNicknames.collectAsStateWithLifecycle()
+    val peerRSSI by viewModel.peerRSSI.collectAsStateWithLifecycle()
+    val selectedLocationChannel by viewModel.selectedLocationChannel.collectAsStateWithLifecycle()
+
+    // Track nested private chat sheet state
+    var showPrivateChatSheet by remember { mutableStateOf(false) }
+    var privateChatPeerID by remember { mutableStateOf<String?>(null) }
+
+    // Bottom sheet state
+    val sheetState = rememberModalBottomSheetState(
+        skipPartiallyExpanded = true
+    )
+
+    // Scroll state for animated top bar
+    val listState = rememberLazyListState()
+    val isScrolled by remember {
+        derivedStateOf {
+            listState.firstVisibleItemIndex > 0 || listState.firstVisibleItemScrollOffset > 0
+        }
+    }
+    val topBarAlpha by animateFloatAsState(
+        targetValue = if (isScrolled) 0.95f else 0f,
+        label = "topBarAlpha"
+    )
+
+    if (isPresented) {
+        ModalBottomSheet(
+            modifier = modifier.statusBarsPadding(),
+            onDismissRequest = onDismiss,
+            sheetState = sheetState,
+            containerColor = MaterialTheme.colorScheme.background,
+            dragHandle = null
+        ) {
+            Box(modifier = Modifier.fillMaxWidth()) {
+                LazyColumn(
+                    state = listState,
+                    modifier = Modifier.fillMaxSize(),
+                    contentPadding = PaddingValues(top = 64.dp, bottom = 20.dp)
+                ) {
+                    // Channels section
+                    if (joinedChannels.isNotEmpty()) {
+                        item(key = "channels_header") {
+                            Text(
+                                text = stringResource(id = R.string.channels).uppercase(),
+                                style = MaterialTheme.typography.labelLarge,
+                                color = colorScheme.onSurface.copy(alpha = 0.7f),
+                                fontWeight = FontWeight.Bold,
+                                modifier = Modifier
+                                    .fillMaxWidth()
+                                    .padding(horizontal = 24.dp)
+                                    .padding(top = 8.dp, bottom = 4.dp)
+                            )
+                        }
+
+                        items(
+                            items = joinedChannels.toList(),
+                            key = { "channel_$it" }
+                        ) { channel ->
+                            val isSelected = channel == currentChannel
+                            val unreadCount = unreadChannelMessages[channel] ?: 0
+
+                            ChannelRow(
+                                channel = channel,
+                                isSelected = isSelected,
+                                unreadCount = unreadCount,
+                                colorScheme = colorScheme,
+                                onChannelClick = {
+                                    // Check if this is a DM channel (starts with @)
+                                    if (channel.startsWith("@")) {
+                                        // Extract peer name and find the peer ID
+                                        val peerName = channel.removePrefix("@")
+                                        val peerID =
+                                            peerNicknames.entries.firstOrNull { it.value == peerName }?.key
+                                        if (peerID != null) {
+                                            privateChatPeerID = peerID
+                                            showPrivateChatSheet = true
+                                        }
+                                    } else {
+                                        // Regular channel switch
+                                        viewModel.switchToChannel(channel)
+                                        onDismiss()
+                                    }
+                                },
+                                onLeaveChannel = {
+                                    viewModel.leaveChannel(channel)
+                                },
+                            )
+                        }
+                    }
+
+                    // People section - switch between mesh and geohash lists (iOS-compatible)
+                    item(key = "people_section") {
+                        when (selectedLocationChannel) {
+                            is ChannelID.Location -> {
+                                // Show geohash people list when in location channel
+                                GeohashPeopleList(
+                                    viewModel = viewModel,
+                                    onTapPerson = onDismiss
+                                )
+                            }
+
+                            else -> {
+                                // Show mesh peer list when in mesh channel (default)
+                                PeopleSection(
+                                    modifier = Modifier.padding(top = if (joinedChannels.isNotEmpty()) 16.dp else 0.dp),
+                                    connectedPeers = connectedPeers,
+                                    peerNicknames = peerNicknames,
+                                    peerRSSI = peerRSSI,
+                                    nickname = nickname,
+                                    colorScheme = colorScheme,
+                                    selectedPrivatePeer = selectedPrivatePeer,
+                                    viewModel = viewModel,
+                                    onPrivateChatStart = { peerID ->
+                                        viewModel.startPrivateChat(peerID)
+                                        privateChatPeerID = peerID
+                                        showPrivateChatSheet = true
+                                    }
+                                )
+                            }
+                        }
+                    }
+                }
+
+                // TopBar (animated)
+                Box(
+                    modifier = Modifier
+                        .align(Alignment.TopCenter)
+                        .fillMaxWidth()
+                        .height(64.dp)
+                        .background(colorScheme.background.copy(alpha = topBarAlpha))
+                ) {
+                    Text(
+                        text = stringResource(id = R.string.your_network).uppercase(),
+                        style = MaterialTheme.typography.titleMedium.copy(
+                            fontWeight = FontWeight.Bold,
+                            fontFamily = FontFamily.Monospace
+                        ),
+                        color = colorScheme.onSurface,
+                        modifier = Modifier
+                            .align(Alignment.CenterStart)
+                            .padding(horizontal = 24.dp)
+                    )
+
+                    Row(
+                        modifier = Modifier
+                            .align(Alignment.CenterEnd)
+                            .padding(horizontal = 16.dp),
+                        horizontalArrangement = Arrangement.spacedBy(8.dp),
+                        verticalAlignment = Alignment.CenterVertically
+                    ) {
+                        if (selectedLocationChannel !is ChannelID.Location) {
+                            IconButton(
+                                onClick = onShowVerification,
+                                modifier = Modifier.size(24.dp)
+                            ) {
+                                Icon(
+                                    imageVector = Icons.Outlined.QrCode,
+                                    contentDescription = stringResource(R.string.verify_title),
+                                    tint = colorScheme.onSurface.copy(alpha = 0.8f),
+                                    modifier = Modifier.size(18.dp)
+                                )
+                            }
+                        }
+
+                        CloseButton(
+                            onClick = onDismiss
+                        )
+                    }
+                }
+            }
+        }
+
+        // Nested Private Chat Sheet (iOS-style)
+        if (showPrivateChatSheet && privateChatPeerID != null) {
+            PrivateChatSheet(
+                isPresented = showPrivateChatSheet,
+                peerID = privateChatPeerID!!,
+                viewModel = viewModel,
+                onDismiss = {
+                    showPrivateChatSheet = false
+                    privateChatPeerID = null
+                    viewModel.endPrivateChat()
+                }
+            )
+        }
+    }
+}
+
+@Composable
+private fun ChannelRow(
+    channel: String,
+    isSelected: Boolean,
+    unreadCount: Int,
+    colorScheme: ColorScheme,
+    onChannelClick: () -> Unit,
+    onLeaveChannel: () -> Unit,
+) {
+    Surface(
+        onClick = onChannelClick,
+        color = if (isSelected) {
+            colorScheme.primaryContainer.copy(alpha = 0.15f)
+        } else {
+            Color.Transparent
+        },
+        shape = MaterialTheme.shapes.medium,
+        modifier = Modifier
+            .fillMaxWidth()
+            .padding(horizontal = 24.dp, vertical = 2.dp)
+    ) {
+        Row(
+            modifier = Modifier
+                .fillMaxWidth()
+                .padding(horizontal = 16.dp, vertical = 12.dp),
+            horizontalArrangement = Arrangement.SpaceBetween,
+            verticalAlignment = Alignment.CenterVertically
+        ) {
+            Row(
+                modifier = Modifier.weight(1f),
+                horizontalArrangement = Arrangement.spacedBy(8.dp),
+                verticalAlignment = Alignment.CenterVertically
+            ) {
+                // Unread badge
+                if (unreadCount > 0) {
+                    UnreadBadge(
+                        count = unreadCount,
+                        colorScheme = colorScheme
+                    )
+                }
+                
+                Text(
+                    text = channel,
+                    style = MaterialTheme.typography.bodyMedium.copy(
+                        fontFamily = FontFamily.Monospace,
+                        fontSize = BASE_FONT_SIZE.sp
+                    ),
+                    color = if (isSelected) colorScheme.primary else colorScheme.onSurface,
+                    fontWeight = if (isSelected) FontWeight.Medium else FontWeight.Normal
+                )
+            }
+
+            Row(
+                horizontalArrangement = Arrangement.spacedBy(4.dp),
+                verticalAlignment = Alignment.CenterVertically
+            ) {
+                // Selection indicator
+                if (isSelected) {
+                    Icon(
+                        imageVector = Icons.Default.Check,
+                        contentDescription = stringResource(R.string.cd_selected),
+                        tint = Color(0xFF32D74B), // iOS green
+                        modifier = Modifier.size(20.dp)
+                    )
+                }
+
+                // Leave channel button
+                CloseButton(
+                    onClick = onLeaveChannel,
+                )
+            }
+        }
+    }
+}
+
+
+
+@Composable
+fun PeopleSection(
+    modifier: Modifier  = Modifier,
+    connectedPeers: List<String>,
+    peerNicknames: Map<String, String>,
+    peerRSSI: Map<String, Int>,
+    nickname: String,
+    colorScheme: ColorScheme,
+    selectedPrivatePeer: String?,
+    viewModel: ChatViewModel,
+    onPrivateChatStart: (String) -> Unit
+) {
+    Column(modifier = modifier) {
+        Text(
+            text = stringResource(id = R.string.people).uppercase(),
+            style = MaterialTheme.typography.labelLarge,
+            color = colorScheme.onSurface.copy(alpha = 0.7f),
+            fontWeight = FontWeight.Bold,
+            modifier = Modifier
+                .fillMaxWidth()
+                .padding(horizontal = 24.dp)
+                .padding(top = 8.dp, bottom = 4.dp)
+        )
+
+        if (connectedPeers.isEmpty()) {
+            Text(
+                text = stringResource(id = R.string.no_one_connected),
+                style = MaterialTheme.typography.bodyMedium.copy(
+                    fontFamily = FontFamily.Monospace,
+                    fontSize = 12.sp
+                ),
+                color = colorScheme.onSurface.copy(alpha = 0.5f),
+                modifier = Modifier
+                    .fillMaxWidth()
+                    .padding(horizontal = 40.dp, vertical = 12.dp)
+            )
+        }
+
+        // Observe reactive state for favorites and fingerprints
+        val hasUnreadPrivateMessages by viewModel.unreadPrivateMessages.collectAsStateWithLifecycle()
+        val privateChats by viewModel.privateChats.collectAsStateWithLifecycle()
+        val favoritePeers by viewModel.favoritePeers.collectAsStateWithLifecycle()
+        val peerFingerprints by viewModel.peerFingerprints.collectAsStateWithLifecycle()
+        val verifiedFingerprints by viewModel.verifiedFingerprints.collectAsStateWithLifecycle()
+
+        // Reactive favorite computation for all peers
+        val peerFavoriteStates = remember(favoritePeers, peerFingerprints, connectedPeers) {
+            connectedPeers.associateWith { peerID ->
+                // Reactive favorite computation - same as ChatHeader
+                val fingerprint = peerFingerprints[peerID]
+                fingerprint != null && favoritePeers.contains(fingerprint)
+            }
+        }
+
+        val peerVerifiedStates = remember(verifiedFingerprints, peerFingerprints, connectedPeers) {
+            connectedPeers.associateWith { peerID ->
+                viewModel.isPeerVerified(peerID, verifiedFingerprints)
+            }
+        }
+
+        // Build mapping of connected peerID -> noise key hex to unify with offline favorites
+        val noiseHexByPeerID: Map<String, String> = connectedPeers.associateWith { pid ->
+            try {
+                viewModel.meshService.getPeerInfo(pid)?.noisePublicKey?.joinToString("") { b -> "%02x".format(b) }
+            } catch (_: Exception) { null }
+        }.filterValues { it != null }.mapValues { it.value!! }
+
+        Log.d("SidebarComponents", "Recomposing with ${favoritePeers.size} favorites, peer states: $peerFavoriteStates")
+
+        // Smart sorting: unread DMs first, then by most recent DM, then favorites, then alphabetical
+        val sortedPeers = connectedPeers.sortedWith(
+            compareBy<String> { !hasUnreadPrivateMessages.contains(it) } // Unread DM senders first
+            .thenByDescending { privateChats[it]?.maxByOrNull { msg -> msg.timestamp }?.timestamp?.time ?: 0L } // Most recent DM (convert Date to Long)
+            .thenBy { !(peerFavoriteStates[it] ?: false) } // Favorites first
+            .thenBy { (if (it == nickname) "You" else (peerNicknames[it] ?: it)).lowercase() } // Alphabetical
+        )
+        
+        // Build a map of base name counts across all people shown in the list (connected + offline + nostr)
+        val hex64Regex = Regex("^[0-9a-fA-F]{64}$")
+
+        // Helper to compute display name used for a given key
+        fun computeDisplayNameForPeerId(key: String): String {
+            return if (key == nickname) "You" else (peerNicknames[key] ?: (privateChats[key]?.lastOrNull()?.sender ?: key.take(12)))
+        }
+
+        val baseNameCounts = mutableMapOf<String, Int>()
+
+        // Connected peers
+        sortedPeers.forEach { pid ->
+            val dn = computeDisplayNameForPeerId(pid)
+            val (b, _) = splitSuffix(dn)
+            if (b != "You") baseNameCounts[b] = (baseNameCounts[b] ?: 0) + 1
+        }
+
+        // Offline favorites (exclude ones mapped to connected)
+        val offlineFavorites = com.gap.droid.favorites.FavoritesPersistenceService.shared.getOurFavorites()
+        offlineFavorites.forEach { fav ->
+            val favPeerID = fav.peerNoisePublicKey.joinToString("") { b -> "%02x".format(b) }
+            val isMappedToConnected = noiseHexByPeerID.values.any { it.equals(favPeerID, ignoreCase = true) }
+            if (!isMappedToConnected) {
+                val dn = peerNicknames[favPeerID] ?: fav.peerNickname
+                val (b, _) = splitSuffix(dn)
+                if (b != "You") baseNameCounts[b] = (baseNameCounts[b] ?: 0) + 1
+            }
+        }
+
+        // Nostr-only conversations
+        val connectedIds = sortedPeers.toSet()
+        val appendedOfflineIds = mutableSetOf<String>()
+        privateChats.keys
+            .filter { key ->
+                (key.startsWith("nostr_") || hex64Regex.matches(key)) &&
+                        !connectedIds.contains(key) &&
+                        !noiseHexByPeerID.values.any { it.equals(key, ignoreCase = true) }
+            }
+            .forEach { convKey ->
+                val dn = peerNicknames[convKey] ?: (privateChats[convKey]?.lastOrNull()?.sender ?: convKey.take(12))
+                val (b, _) = splitSuffix(dn)
+                if (b != "You") baseNameCounts[b] = (baseNameCounts[b] ?: 0) + 1
+            }
+
+        sortedPeers.forEach { peerID ->
+            val isFavorite = peerFavoriteStates[peerID] ?: false
+            val isVerified = peerVerifiedStates[peerID] ?: false
+            // fingerprint and favorite relationship resolution not needed here; UI will show Nostr globe for appended offline favorites below
+
+            val noiseHex = noiseHexByPeerID[peerID]
+            val meshUnread = hasUnreadPrivateMessages.contains(peerID)
+            val nostrUnread = if (noiseHex != null) hasUnreadPrivateMessages.contains(noiseHex) else false
+            val combinedHasUnread = meshUnread || nostrUnread
+            val combinedUnreadCount = (
+                privateChats[peerID]?.count { msg -> msg.sender != nickname && meshUnread } ?: 0
+            ) + (
+                if (noiseHex != null) privateChats[noiseHex]?.count { msg -> msg.sender != nickname && nostrUnread } ?: 0 else 0
+            )
+
+            val displayName = if (peerID == nickname) "You" else (peerNicknames[peerID] ?: (privateChats[peerID]?.lastOrNull()?.sender ?: peerID.take(12)))
+            val (bName, _) = splitSuffix(displayName)
+            val showHash = (baseNameCounts[bName] ?: 0) > 1
+
+            val directMap by viewModel.peerDirect.collectAsStateWithLifecycle()
+            val isDirectLive = directMap[peerID] ?: try { viewModel.meshService.getPeerInfo(peerID)?.isDirectConnection == true } catch (_: Exception) { false }
+            PeerItem(
+                peerID = peerID,
+                displayName = displayName,
+                isDirect = isDirectLive,
+                isSelected = peerID == selectedPrivatePeer,
+                isFavorite = isFavorite,
+                isVerified = isVerified,
+                hasUnreadDM = combinedHasUnread,
+                colorScheme = colorScheme,
+                viewModel = viewModel,
+                onItemClick = { onPrivateChatStart(peerID) },
+                onToggleFavorite = { 
+                    Log.d("SidebarComponents", "Sidebar toggle favorite: peerID=$peerID, currentFavorite=$isFavorite")
+                    viewModel.toggleFavorite(peerID) 
+                },
+                unreadCount = if (combinedUnreadCount > 0) combinedUnreadCount else if (combinedHasUnread) 1 else 0,
+                showNostrGlobe = false,
+                showHashSuffix = showHash
+            )
+        }
+
+        // Append offline favorites we actively favorite (and not currently connected)
+        offlineFavorites.forEach { fav ->
+            val favPeerID = fav.peerNoisePublicKey.joinToString("") { b -> "%02x".format(b) }
+            // If any connected peer maps to this noise key, skip showing the offline entry
+            val isMappedToConnected = noiseHexByPeerID.values.any { it.equals(favPeerID, ignoreCase = true) }
+            if (isMappedToConnected) return@forEach
+
+            // Resolve potential Nostr conversation key for this favorite (for unread detection)
+            val nostrConvKey: String? = try {
+                val npubOrHex = com.gap.droid.favorites.FavoritesPersistenceService.shared.findNostrPubkey(fav.peerNoisePublicKey)
+                if (npubOrHex != null) {
+                    val hex = if (npubOrHex.startsWith("npub")) {
+                        val (hrp, data) = com.gap.droid.nostr.Bech32.decode(npubOrHex)
+                        if (hrp == "npub") data.joinToString("") { "%02x".format(it) } else null
+                    } else {
+                        npubOrHex.lowercase()
+                    }
+                    hex?.let { "nostr_${it.take(16)}" }
+                } else null
+            } catch (_: Exception) { null }
+
+            val hasUnread = hasUnreadPrivateMessages.contains(favPeerID) || (nostrConvKey != null && hasUnreadPrivateMessages.contains(nostrConvKey))
+
+            // If user clicks an offline favorite and the mapped peer is currently connected under a different ID,
+            // open chat with the connected peerID instead of the noise hex for a seamless window
+            val mappedConnectedPeerID = noiseHexByPeerID.entries.firstOrNull { it.value.equals(favPeerID, ignoreCase = true) }?.key
+            val dn = peerNicknames[favPeerID] ?: fav.peerNickname
+            val (bName, _) = splitSuffix(dn)
+            val showHash = (baseNameCounts[bName] ?: 0) > 1
+
+            val isVerified = viewModel.isNoisePublicKeyVerified(fav.peerNoisePublicKey, verifiedFingerprints)
+
+            // Compute unreadCount from either noise conversation or Nostr conversation
+            val unreadCount = (
+                privateChats[favPeerID]?.count { msg -> msg.sender != nickname && hasUnreadPrivateMessages.contains(favPeerID) } ?: 0
+            ) + (
+                if (nostrConvKey != null) privateChats[nostrConvKey]?.count { msg -> msg.sender != nickname && hasUnreadPrivateMessages.contains(nostrConvKey) } ?: 0 else 0
+            )
+
+            PeerItem(
+                peerID = favPeerID,
+                displayName = dn,
+                isDirect = false,
+                isSelected = (mappedConnectedPeerID ?: favPeerID) == selectedPrivatePeer,
+                isFavorite = true,
+                isVerified = isVerified,
+                hasUnreadDM = hasUnread,
+                colorScheme = colorScheme,
+                viewModel = viewModel,
+                onItemClick = { onPrivateChatStart(mappedConnectedPeerID ?: favPeerID) },
+                onToggleFavorite = { 
+                    Log.d("SidebarComponents", "Sidebar toggle favorite (offline): peerID=$favPeerID")
+                    viewModel.toggleFavorite(favPeerID)
+                },
+                unreadCount = if (unreadCount > 0) unreadCount else if (hasUnread) 1 else 0,
+                showNostrGlobe = (fav.isMutual && fav.peerNostrPublicKey != null),
+                showHashSuffix = showHash
+            )
+            appendedOfflineIds.add(favPeerID)
+        }
+
+        // NOTE: Do NOT append Nostr-only (nostr_*) conversations to the mesh people list.
+        // Geohash DMs should appear in the GeohashPeople list for the active geohash, not in mesh offline contacts.
+        // We intentionally remove previously-added behavior that mixed geohash DMs into mesh sidebar.
+        // If you need to surface non-geohash offline mesh conversations in the future, do it here for 64-hex noise IDs only.
+        /*
+        val alreadyShownIds = connectedIds + appendedOfflineIds
+        privateChats.keys
+            .filter { key ->
+                // Only include 64-hex noise IDs (mesh identities); exclude any nostr_* aliases
+                hex64Regex.matches(key) &&
+                !alreadyShownIds.contains(key) &&
+                // Skip if this key maps to a connected peer via noiseHex mapping
+                !noiseHexByPeerID.values.any { it.equals(key, ignoreCase = true) }
+            }
+            .sortedBy { key -> privateChats[key]?.lastOrNull()?.timestamp }
+            .forEach { convKey ->
+                val lastSender = privateChats[convKey]?.lastOrNull()?.sender
+                val dn = peerNicknames[convKey] ?: (lastSender ?: convKey.take(12))
+                val (bName, _) = splitSuffix(dn)
+                val showHash = (baseNameCounts[bName] ?: 0) > 1
+
+                PeerItem(
+                    peerID = convKey,
+                    displayName = dn,
+                    isDirect = false,
+                    isSelected = convKey == selectedPrivatePeer,
+                    isFavorite = false,
+                    hasUnreadDM = hasUnreadPrivateMessages.contains(convKey),
+                    colorScheme = colorScheme,
+                    viewModel = viewModel,
+                    onItemClick = { onPrivateChatStart(convKey) },
+                    onToggleFavorite = { viewModel.toggleFavorite(convKey) },
+                    unreadCount = privateChats[convKey]?.count { msg ->
+                        msg.sender != nickname && hasUnreadPrivateMessages.contains(convKey)
+                    } ?: if (hasUnreadPrivateMessages.contains(convKey)) 1 else 0,
+                    showNostrGlobe = false,
+                    showHashSuffix = showHash
+                )
+            }
+        */
+        // End intentional removal
+        
+    }
+}
+
+@Composable
+private fun PeerItem(
+    peerID: String,
+    displayName: String,
+    isDirect: Boolean,
+    isSelected: Boolean,
+    isFavorite: Boolean,
+    isVerified: Boolean,
+    hasUnreadDM: Boolean,
+    colorScheme: ColorScheme,
+    viewModel: ChatViewModel,
+    onItemClick: () -> Unit,
+    onToggleFavorite: () -> Unit,
+    unreadCount: Int = 0,
+    showNostrGlobe: Boolean = false,
+    showHashSuffix: Boolean = true
+) {
+    val currentNickname by viewModel.nickname.collectAsStateWithLifecycle()
+    // Split display name for hashtag suffix support (iOS-compatible)
+    val (baseNameRaw, suffixRaw) = splitSuffix(displayName)
+    val baseName = truncateNickname(baseNameRaw)
+    val suffix = if (showHashSuffix) suffixRaw else ""
+    val isMe = displayName == "You" || peerID == currentNickname
+
+    // Get consistent peer color (iOS-compatible)
+    val isDark = colorScheme.background.red + colorScheme.background.green + colorScheme.background.blue < 1.5f
+    val assignedColor = viewModel.colorForMeshPeer(peerID, isDark)
+    val baseColor = if (isMe) Color(0xFFFF9500) else assignedColor
+
+    Surface(
+        onClick = onItemClick,
+        color = if (isSelected) {
+            colorScheme.primaryContainer.copy(alpha = 0.15f)
+        } else {
+            Color.Transparent
+        },
+        shape = MaterialTheme.shapes.medium,
+        modifier = Modifier
+            .fillMaxWidth()
+            .padding(horizontal = 24.dp, vertical = 2.dp)
+    ) {
+        Row(
+            modifier = Modifier
+                .fillMaxWidth()
+                .padding(horizontal = 16.dp, vertical = 12.dp),
+            horizontalArrangement = Arrangement.SpaceBetween,
+            verticalAlignment = Alignment.CenterVertically
+        ) {
+            Row(
+                modifier = Modifier.weight(1f),
+                horizontalArrangement = Arrangement.spacedBy(8.dp),
+                verticalAlignment = Alignment.CenterVertically
+            ) {
+                // Connection/status indicator
+                if (hasUnreadDM) {
+                    // Show mail icon for unread DMs (iOS orange)
+                    Icon(
+                        imageVector = Icons.Filled.Email,
+                        contentDescription = stringResource(R.string.cd_unread_message),
+                        modifier = Modifier.size(16.dp),
+                        tint = Color(0xFFFF9500) // iOS orange
+                    )
+                } else if (showNostrGlobe) {
+                    // Purple globe to indicate Nostr availability
+                    Icon(
+                        imageVector = Icons.Filled.Public,
+                        contentDescription = stringResource(R.string.cd_reachable_via_nostr),
+                        modifier = Modifier.size(16.dp),
+                        tint = Color(0xFF9C27B0) // Purple
+                    )
+                } else if (!isDirect && isFavorite) {
+                    // Offline favorited user: show outlined circle icon
+                    Icon(
+                        imageVector = Icons.Outlined.Circle,
+                        contentDescription = stringResource(R.string.cd_offline_favorite),
+                        modifier = Modifier.size(16.dp),
+                        tint = Color.Gray
+                    )
+                } else {
+                    Icon(
+                        imageVector = if (isDirect) Icons.Outlined.SettingsInputAntenna else Icons.Filled.Route,
+                        contentDescription = if (isDirect) "Direct Bluetooth" else "Routed",
+                        modifier = Modifier.size(16.dp),
+                        tint = colorScheme.onSurface.copy(alpha = 0.6f)
+                    )
+                }
+
+                // Display name with iOS-style color and hashtag suffix support
+                Row(verticalAlignment = Alignment.CenterVertically) {
+                    // Base name with peer-specific color
+                    Text(
+                        text = baseName,
+                        style = MaterialTheme.typography.bodyMedium.copy(
+                            fontFamily = FontFamily.Monospace,
+                            fontSize = BASE_FONT_SIZE.sp,
+                            fontWeight = if (isMe) FontWeight.Bold else FontWeight.Normal
+                        ),
+                        color = baseColor,
+                        maxLines = 1,
+                        overflow = TextOverflow.Ellipsis
+                    )
+
+                    // Hashtag suffix in lighter shade (iOS-style)
+                    if (suffix.isNotEmpty()) {
+                        Text(
+                            text = suffix,
+                            style = MaterialTheme.typography.bodyMedium.copy(
+                                fontFamily = FontFamily.Monospace,
+                                fontSize = BASE_FONT_SIZE.sp
+                            ),
+                            color = baseColor.copy(alpha = 0.6f)
+                        )
+                    }
+                }
+            }
+
+            if (isVerified) {
+                Spacer(modifier = Modifier.width(4.dp))
+                Icon(
+                    imageVector = Icons.Filled.Verified,
+                    contentDescription = null,
+                    modifier = Modifier.size(14.dp),
+                    tint = Color(0xFF32D74B) // iOS Green
+                )
+            }
+
+            Row(
+                horizontalArrangement = Arrangement.spacedBy(4.dp),
+                verticalAlignment = Alignment.CenterVertically
+            ) {
+                // Selection indicator
+                if (isSelected) {
+                    Icon(
+                        imageVector = Icons.Default.Check,
+                        contentDescription = stringResource(R.string.cd_selected),
+                        tint = Color(0xFF32D74B), // iOS green
+                        modifier = Modifier.size(20.dp)
+                    )
+                }
+
+                // Favorite star with proper filled/outlined states
+                IconButton(
+                    onClick = onToggleFavorite,
+                    modifier = Modifier.size(32.dp)
+                ) {
+                    Icon(
+                        imageVector = if (isFavorite) Icons.Filled.Star else Icons.Outlined.Star,
+                        contentDescription = if (isFavorite) "Remove from favorites" else "Add to favorites",
+                        modifier = Modifier.size(16.dp),
+                        tint = if (isFavorite) Color(0xFFFFD700) else Color(0xFF4CAF50)
+                    )
+                }
+            }
+        }
+    }
+}
+
+/**
+ * Reusable unread badge component for both channels and private messages
+ */
+@Composable
+private fun UnreadBadge(
+    count: Int,
+    colorScheme: ColorScheme,
+    modifier: Modifier = Modifier
+) {
+    if (count > 0) {
+        Box(
+            modifier = modifier
+                .background(
+                    color = Color(0xFFFFD700), // Yellow color
+                    shape = RoundedCornerShape(10.dp)
+                )
+                .padding(horizontal = 6.dp, vertical = 2.dp)
+                .defaultMinSize(minWidth = 18.dp, minHeight = 18.dp),
+            contentAlignment = Alignment.Center
+        ) {
+            Text(
+                text = if (count > 99) "99+" else count.toString(),
+                style = MaterialTheme.typography.labelSmall.copy(
+                    fontSize = 10.sp,
+                    fontWeight = FontWeight.Bold,
+                    fontFamily = FontFamily.Monospace
+                ),
+                color = Color.Black // Black text on yellow background
+            )
+        }
+    }
+}
+
+/**
+ * Convert RSSI value (dBm) to signal strength percentage (0-100)
+ * RSSI typically ranges from -30 (excellent) to -100 (very poor)
+ * Maps to 0-100 scale where:
+ * - 0-32: No signal (0 bars)
+ * - 33-65: Weak (1 bar) 
+ * - 66-98: Good (2 bars)
+ * - 99-100: Excellent (3 bars)
+ */
+private fun convertRSSIToSignalStrength(rssi: Int?): Int {
+    if (rssi == null) return 0
+    
+    return when {
+        rssi >= -40 -> 100  // Excellent signal
+        rssi >= -55 -> 85   // Very good signal  
+        rssi >= -70 -> 70   // Good signal
+        rssi >= -85 -> 50   // Fair signal
+        rssi >= -100 -> 25  // Poor signal
+        else -> 0           // Very poor or no signal
+    }
+}
+
+/**
+ * Nested Private Chat Sheet - iOS-style nested bottom sheet
+ */
+@OptIn(ExperimentalMaterial3Api::class)
+@Composable
+private fun PrivateChatSheet(
+    isPresented: Boolean,
+    peerID: String,
+    viewModel: ChatViewModel,
+    onDismiss: () -> Unit
+) {
+    val colorScheme = MaterialTheme.colorScheme
+    val privateChats by viewModel.privateChats.collectAsStateWithLifecycle()
+    val peerNicknames by viewModel.peerNicknames.collectAsStateWithLifecycle()
+    val nickname by viewModel.nickname.collectAsStateWithLifecycle()
+    val connectedPeers by viewModel.connectedPeers.collectAsStateWithLifecycle()
+    val peerDirectMap by viewModel.peerDirect.collectAsStateWithLifecycle()
+    val peerSessionStates by viewModel.peerSessionStates.collectAsStateWithLifecycle()
+    val favoritePeers by viewModel.favoritePeers.collectAsStateWithLifecycle()
+    val peerFingerprints by viewModel.peerFingerprints.collectAsStateWithLifecycle()
+
+    val verifiedFingerprints by viewModel.verifiedFingerprints.collectAsStateWithLifecycle()
+
+    // Start private chat when screen opens
+    LaunchedEffect(peerID) {
+        viewModel.startPrivateChat(peerID)
+    }
+
+    val displayName = peerNicknames[peerID] ?: peerID.take(12)
+    val messages = privateChats[peerID] ?: emptyList()
+    val isDirect = peerDirectMap[peerID] == true
+    val isConnected = connectedPeers.contains(peerID) || isDirect
+    val isNostrPeer = peerID.startsWith("nostr_") || peerID.startsWith("nostr:")
+    val sessionState = peerSessionStates[peerID]
+    val fingerprint = peerFingerprints[peerID]
+    val isFavorite = remember(favoritePeers, fingerprint) {
+        if (fingerprint != null) favoritePeers.contains(fingerprint) else viewModel.isFavorite(peerID)
+    }
+
+    val isVerified = remember(peerID, verifiedFingerprints) {
+        viewModel.isPeerVerified(peerID, verifiedFingerprints)
+    }
+
+    val securityModifier = if (!isNostrPeer) {
+        Modifier.clickable { viewModel.showSecurityVerificationSheet() }
+    } else {
+        Modifier
+    }
+
+    val sheetState = rememberModalBottomSheetState(
+        skipPartiallyExpanded = true
+    )
+
+    if (isPresented) {
+        ModalBottomSheet(
+            modifier = Modifier.statusBarsPadding(),
+            onDismissRequest = onDismiss,
+            sheetState = sheetState,
+            containerColor = colorScheme.background,
+            dragHandle = null
+        ) {
+            Box(modifier = Modifier.fillMaxSize()) {
+                Column(
+                    modifier = Modifier.fillMaxSize()
+                ) {
+                    Spacer(modifier = Modifier.height(64.dp))
+
+                    HorizontalDivider(color = colorScheme.outline.copy(alpha = 0.3f))
+
+                    // Messages list
+                    var forceScrollToBottom by remember { mutableStateOf(false) }
+                    var isScrolledUp by remember { mutableStateOf(false) }
+
+                    MessagesList(
+                        messages = messages,
+                        currentUserNickname = nickname,
+                        meshService = viewModel.meshService,
+                        modifier = Modifier.weight(1f),
+                        forceScrollToBottom = forceScrollToBottom,
+                        onScrolledUpChanged = { isUp -> isScrolledUp = isUp },
+                        onNicknameClick = { /* handle mention */ },
+                        onMessageLongPress = { /* handle long press */ },
+                        onCancelTransfer = { msg -> viewModel.cancelMediaSend(msg.id) },
+                        onImageClick = { _, _, _ -> /* handle image click */ }
+                    )
+
+                    HorizontalDivider(color = colorScheme.outline.copy(alpha = 0.3f))
+
+                    // Input section
+                    var messageText by remember {
+                        mutableStateOf(
+                            androidx.compose.ui.text.input.TextFieldValue(
+                                ""
+                            )
+                        )
+                    }
+
+                    ChatInputSection(
+                        messageText = messageText,
+                        onMessageTextChange = { newText ->
+                            messageText = newText
+                            viewModel.updateMentionSuggestions(newText.text)
+                        },
+                        onSend = {
+                            if (messageText.text.trim().isNotEmpty()) {
+                                viewModel.sendMessage(messageText.text.trim())
+                                messageText = androidx.compose.ui.text.input.TextFieldValue("")
+                                forceScrollToBottom = !forceScrollToBottom
+                            }
+                        },
+                        onSendVoiceNote = { peer, channel, path ->
+                            viewModel.sendVoiceNote(peer, channel, path)
+                        },
+                        onSendImageNote = { peer, channel, path ->
+                            viewModel.sendImageNote(peer, channel, path)
+                        },
+                        onSendFileNote = { peer, channel, path ->
+                            viewModel.sendFileNote(peer, channel, path)
+                        },
+                        showCommandSuggestions = false,
+                        commandSuggestions = emptyList(),
+                        showMentionSuggestions = false,
+                        mentionSuggestions = emptyList(),
+                        onCommandSuggestionClick = { },
+                        onMentionSuggestionClick = { },
+                        selectedPrivatePeer = peerID,
+                        currentChannel = null,
+                        nickname = nickname,
+                        colorScheme = colorScheme,
+                        showMediaButtons = true
+                    )
+                }
+
+                // TopBar (fixed at top, iOS-style)
+                Box(
+                    modifier = Modifier
+                        .align(Alignment.TopCenter)
+                        .fillMaxWidth()
+                        .height(64.dp)
+                        .background(colorScheme.background),
+                    contentAlignment = Alignment.Center
+                ) {
+                    // Back button
+                    IconButton(
+                        onClick = onDismiss,
+                        modifier = Modifier
+                            .align(Alignment.CenterStart)
+                            .padding(start = 16.dp)
+                            .size(32.dp)
+                    ) {
+                        Icon(
+                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,
+                            contentDescription = stringResource(R.string.chat_back),
+                            tint = colorScheme.onSurface
+                        )
+                    }
+
+                    // Center content: connection status + name + encryption
+                    Row(
+                        modifier = Modifier.align(Alignment.Center),
+                        verticalAlignment = Alignment.CenterVertically,
+                        horizontalArrangement = Arrangement.spacedBy(6.dp)
+                    ) {
+                        when {
+                            isDirect -> {
+                                Icon(
+                                    imageVector = Icons.Outlined.SettingsInputAntenna,
+                                    contentDescription = stringResource(R.string.cd_connected_peers),
+                                    modifier = Modifier.size(14.dp),
+                                    tint = colorScheme.onSurface.copy(alpha = 0.6f)
+                                )
+                            }
+                            isConnected -> {
+                                Icon(
+                                    imageVector = Icons.Filled.Route,
+                                    contentDescription = stringResource(R.string.cd_ready_for_handshake),
+                                    modifier = Modifier.size(14.dp),
+                                    tint = colorScheme.onSurface.copy(alpha = 0.6f)
+                                )
+                            }
+                            isNostrPeer -> {
+                                Icon(
+                                    imageVector = Icons.Filled.Public,
+                                    contentDescription = stringResource(R.string.cd_nostr_reachable),
+                                    modifier = Modifier.size(14.dp),
+                                    tint = Color(0xFF9C27B0)
+                                )
+                            }
+                        }
+
+                        Text(
+                            text = displayName,
+                            style = MaterialTheme.typography.titleMedium.copy(
+                                fontWeight = FontWeight.Bold,
+                                fontFamily = FontFamily.Monospace
+                            ),
+                            color = colorScheme.onSurface
+                        )
+
+                        Row(
+                            verticalAlignment = Alignment.CenterVertically,
+                            modifier = Modifier.then(securityModifier)
+                        ) {
+                            if (!isNostrPeer) {
+                                NoiseSessionIcon(
+                                    sessionState = sessionState,
+                                    modifier = Modifier.size(14.dp)
+                                )
+                            }
+
+                            if (isVerified) {
+                                Spacer(modifier = Modifier.width(4.dp))
+                                Icon(
+                                    imageVector = Icons.Filled.Verified,
+                                    contentDescription = stringResource(R.string.verify_title),
+                                    modifier = Modifier.size(14.dp),
+                                    tint = Color(0xFF32D74B) // iOS Green
+                                )
+                            }
+                        }
+
+                        IconButton(
+                            onClick = { viewModel.toggleFavorite(peerID) },
+                            modifier = Modifier.size(28.dp)
+                        ) {
+                            Icon(
+                                imageVector = if (isFavorite) Icons.Filled.Star else Icons.Outlined.Star,
+                                contentDescription = if (isFavorite) stringResource(R.string.cd_remove_favorite) else stringResource(R.string.cd_add_favorite),
+                                modifier = Modifier.size(16.dp),
+                                tint = if (isFavorite) Color(0xFFFFD700) else colorScheme.onSurface.copy(alpha = 0.6f)
+                            )
+                        }
+                    }
+
+                    CloseButton(
+                        onClick = onDismiss,
+                        modifier = Modifier
+                            .align(Alignment.CenterEnd)
+                            .padding(horizontal = 16.dp)
+                    )
+
+                }
+            }
+        }
+    }
+}
diff --git a/app/src/main/java/com/gap/droid/ui/SidebarComponents.kt b/app/src/main/java/com/gap/droid/ui/SidebarComponents.kt
deleted file mode 100644
index 9b8328d..0000000
--- a/app/src/main/java/com/gap/droid/ui/SidebarComponents.kt
+++ /dev/null
@@ -1,753 +0,0 @@
-package com.gap.droid.ui
-
-import com.gap.droid.R
-import android.util.Log
-import androidx.compose.foundation.*
-import androidx.compose.foundation.interaction.MutableInteractionSource
-import androidx.compose.foundation.layout.*
-import androidx.compose.foundation.lazy.LazyColumn
-import androidx.compose.foundation.shape.RoundedCornerShape
-import androidx.compose.material.icons.Icons
-import androidx.compose.material.icons.filled.*
-import androidx.compose.material.icons.outlined.*
-import androidx.compose.material3.*
-import androidx.compose.runtime.*
-import androidx.compose.ui.Alignment
-import androidx.compose.ui.Modifier
-import androidx.compose.ui.graphics.Color
-import androidx.compose.ui.res.stringResource
-import androidx.compose.ui.text.font.FontFamily
-import androidx.compose.ui.text.font.FontWeight
-import androidx.compose.ui.unit.dp
-import androidx.compose.ui.unit.sp
-import androidx.compose.ui.text.style.TextOverflow
-import androidx.lifecycle.compose.collectAsStateWithLifecycle
-import com.gap.droid.ui.theme.BASE_FONT_SIZE
-import com.gap.droid.util.hexEncodedString
-
-
-/**
- * Sidebar components for ChatScreen
- * Extracted from ChatScreen.kt for better organization
- */
-
-@Composable
-fun SidebarOverlay(
-    viewModel: ChatViewModel,
-    onDismiss: () -> Unit,
-    onShowVerification: () -> Unit,
-    modifier: Modifier = Modifier
-) {
-    val colorScheme = MaterialTheme.colorScheme
-    val interactionSource = remember { MutableInteractionSource() }
-
-    val connectedPeers by viewModel.connectedPeers.collectAsStateWithLifecycle()
-    val joinedChannels by viewModel.joinedChannels.collectAsStateWithLifecycle()
-    val currentChannel by viewModel.currentChannel.collectAsStateWithLifecycle()
-    val selectedPrivatePeer by viewModel.selectedPrivateChatPeer.collectAsStateWithLifecycle()
-    val nickname by viewModel.nickname.collectAsStateWithLifecycle()
-    val unreadChannelMessages by viewModel.unreadChannelMessages.collectAsStateWithLifecycle()
-    val peerNicknames by viewModel.peerNicknames.collectAsStateWithLifecycle()
-    val peerRSSI by viewModel.peerRSSI.collectAsStateWithLifecycle()
-
-    Box(
-        modifier = modifier
-            .background(Color.Black.copy(alpha = 0.5f))
-            .clickable(indication = null, interactionSource = interactionSource) { onDismiss() }
-    ) {
-        Row(
-            modifier = Modifier
-                .fillMaxHeight()
-                .width(280.dp)
-                .align(Alignment.CenterEnd)
-                .clickable { /* Prevent dismissing when clicking sidebar */ }
-        ) {
-            // Grey vertical bar for visual continuity (matches iOS)
-            Box(
-                modifier = Modifier
-                    .fillMaxHeight()
-                    .width(1.dp)
-                    .background(Color.Gray.copy(alpha = 0.3f))
-            )
-            
-            Column(
-                modifier = Modifier
-                    .fillMaxHeight()
-                    .weight(1f)
-                    .background(colorScheme.background.copy(alpha = 0.95f))
-                    .windowInsetsPadding(WindowInsets.statusBars) // Add status bar padding
-            ) {
-                SidebarHeader()
-
-                HorizontalDivider()
-                
-                // Scrollable content
-                LazyColumn(
-                    modifier = Modifier.fillMaxSize(),
-                    contentPadding = PaddingValues(vertical = 8.dp),
-                    verticalArrangement = Arrangement.spacedBy(12.dp)
-                ) {
-                    // Channels section
-                    if (joinedChannels.isNotEmpty()) {
-                        item {
-                            ChannelsSection(
-                                channels = joinedChannels.toList(), // Convert Set to List
-                                currentChannel = currentChannel,
-                                colorScheme = colorScheme,
-                                onChannelClick = { channel ->
-                                    viewModel.switchToChannel(channel)
-                                    onDismiss()
-                                },
-                                onLeaveChannel = { channel ->
-                                    viewModel.leaveChannel(channel)
-                                },
-                                unreadChannelMessages = unreadChannelMessages
-                            )
-                        }
-                        
-                        item {
-                            HorizontalDivider(modifier = Modifier.padding(vertical = 4.dp))
-                        }
-                    }
-                    
-                    // People section - switch between mesh and geohash lists (iOS-compatible)
-                    item {
-                        val selectedLocationChannel by viewModel.selectedLocationChannel.collectAsState()
-                        
-                        when (selectedLocationChannel) {
-                            is com.gap.droid.geohash.ChannelID.Location -> {
-                                // Show geohash people list when in location channel
-                                GeohashPeopleList(
-                                    viewModel = viewModel,
-                                    onTapPerson = onDismiss
-                                )
-                            }
-                            else -> {
-                                // Show mesh peer list when in mesh channel (default)
-                                PeopleSection(
-                                    modifier = modifier.padding(bottom = 16.dp),
-                                    connectedPeers = connectedPeers,
-                                    peerNicknames = peerNicknames,
-                                    peerRSSI = peerRSSI,
-                                    nickname = nickname,
-                                    colorScheme = colorScheme,
-                                    selectedPrivatePeer = selectedPrivatePeer,
-                                    viewModel = viewModel,
-                                    onShowVerification = onShowVerification,
-                                    onPrivateChatStart = { peerID ->
-                                        viewModel.startPrivateChat(peerID)
-                                        onDismiss()
-                                    }
-                                )
-                            }
-                        }
-                    }
-                }
-            }
-        }
-    }
-}
-
-@Composable
-private fun SidebarHeader() {
-    val colorScheme = MaterialTheme.colorScheme
-    
-    Row(
-        modifier = Modifier
-            .height(42.dp) // Match reduced main header height
-            .fillMaxWidth()
-            .background(colorScheme.background.copy(alpha = 0.95f))
-            .padding(horizontal = 12.dp),
-        verticalAlignment = Alignment.CenterVertically
-    ) {
-        Text(
-            text = stringResource(id = R.string.your_network).uppercase(),
-            style = MaterialTheme.typography.titleMedium.copy(
-                fontWeight = FontWeight.Bold,
-                fontFamily = FontFamily.Monospace
-            ),
-            color = colorScheme.onSurface
-        )
-        Spacer(modifier = Modifier.weight(1f))
-    }
-}
-
-@Composable
-fun ChannelsSection(
-    channels: List<String>,
-    currentChannel: String?,
-    colorScheme: ColorScheme,
-    onChannelClick: (String) -> Unit,
-    onLeaveChannel: (String) -> Unit,
-    unreadChannelMessages: Map<String, Int> = emptyMap()
-) {
-    Column {
-        Row(
-            modifier = Modifier
-                .fillMaxWidth()
-                .padding(horizontal = 16.dp, vertical = 8.dp),
-            verticalAlignment = Alignment.CenterVertically
-        ) {
-            Icon(
-                imageVector = Icons.Default.Person, // Using Person icon as placeholder
-                contentDescription = null,
-                modifier = Modifier.size(10.dp),
-                tint = colorScheme.onSurface.copy(alpha = 0.6f)
-            )
-            Spacer(modifier = Modifier.width(6.dp))
-            Text(
-                text = stringResource(id = R.string.channels).uppercase(),
-                style = MaterialTheme.typography.labelSmall,
-                color = colorScheme.onSurface.copy(alpha = 0.6f),
-                fontWeight = FontWeight.Bold
-            )
-        }
-        
-        channels.forEach { channel ->
-            val isSelected = channel == currentChannel
-            val unreadCount = unreadChannelMessages[channel] ?: 0
-            
-            Row(
-                modifier = Modifier
-                    .fillMaxWidth()
-                    .clickable { onChannelClick(channel) }
-                    .background(
-                        if (isSelected) colorScheme.primaryContainer.copy(alpha = 0.3f)
-                        else Color.Transparent
-                    )
-                    .padding(horizontal = 24.dp, vertical = 8.dp),
-                verticalAlignment = Alignment.CenterVertically
-            ) {
-                // Unread badge for channels
-                UnreadBadge(
-                    count = unreadCount,
-                    colorScheme = colorScheme,
-                    modifier = Modifier.padding(end = 8.dp)
-                )
-                
-                Text(
-                    text = channel, // Channel already contains the # prefix
-                    style = MaterialTheme.typography.bodyMedium,
-                    color = if (isSelected) colorScheme.primary else colorScheme.onSurface,
-                    fontWeight = if (isSelected) FontWeight.Medium else FontWeight.Normal,
-                    modifier = Modifier.weight(1f)
-                )
-                
-                // Leave channel button
-                IconButton(
-                    onClick = { onLeaveChannel(channel) },
-                    modifier = Modifier.size(24.dp)
-                ) {
-                    Icon(
-                        imageVector = Icons.Default.Close,
-                        contentDescription = stringResource(com.gap.droid.R.string.cd_leave_channel),
-                        modifier = Modifier.size(14.dp),
-                        tint = colorScheme.onSurface.copy(alpha = 0.5f)
-                    )
-                }
-            }
-        }
-    }
-}
-
-@Composable
-fun PeopleSection(
-    modifier: Modifier  = Modifier,
-    connectedPeers: List<String>,
-    peerNicknames: Map<String, String>,
-    peerRSSI: Map<String, Int>,
-    nickname: String,
-    colorScheme: ColorScheme,
-    selectedPrivatePeer: String?,
-    viewModel: ChatViewModel,
-    onShowVerification: () -> Unit,
-    onPrivateChatStart: (String) -> Unit
-) {
-    val selectedLocationChannel by viewModel.selectedLocationChannel.collectAsStateWithLifecycle()
-
-    Column(modifier = modifier) {
-        Row(
-            modifier = Modifier
-                .fillMaxWidth()
-                .padding(horizontal = 16.dp, vertical = 8.dp),
-            verticalAlignment = Alignment.CenterVertically
-        ) {
-            Icon(
-                imageVector = Icons.Default.Group, // Using Person icon for people
-                contentDescription = null,
-                modifier = Modifier.size(12.dp),
-                tint = colorScheme.onSurface.copy(alpha = 0.6f)
-            )
-            Spacer(modifier = Modifier.width(6.dp))
-            Text(
-                text = stringResource(id = R.string.people).uppercase(),
-                style = MaterialTheme.typography.labelSmall,
-                color = colorScheme.onSurface.copy(alpha = 0.6f),
-                fontWeight = FontWeight.Bold
-            )
-            Spacer(modifier = Modifier.weight(1f))
-            if (selectedLocationChannel !is com.gap.droid.geohash.ChannelID.Location) {
-                IconButton(onClick = onShowVerification, modifier = Modifier.size(24.dp)) {
-                    Icon(
-                        imageVector = Icons.Outlined.QrCode,
-                        contentDescription = stringResource(R.string.verify_title),
-                        tint = colorScheme.onSurface.copy(alpha = 0.8f),
-                        modifier = Modifier.size(16.dp)
-                    )
-                }
-            }
-        }
-        
-        if (connectedPeers.isEmpty()) {
-            Text(
-                text = stringResource(id = R.string.no_one_connected),
-                style = MaterialTheme.typography.bodyMedium,
-                color = colorScheme.onSurface.copy(alpha = 0.5f),
-                modifier = Modifier.padding(horizontal = 24.dp, vertical = 8.dp)
-            )
-        }
-
-        // Observe reactive state for favorites and fingerprints
-        val hasUnreadPrivateMessages by viewModel.unreadPrivateMessages.collectAsStateWithLifecycle()
-        val privateChats by viewModel.privateChats.collectAsStateWithLifecycle()
-        val favoritePeers by viewModel.favoritePeers.collectAsStateWithLifecycle()
-        val peerFingerprints by viewModel.peerFingerprints.collectAsStateWithLifecycle()
-        val verifiedFingerprints by viewModel.verifiedFingerprints.collectAsStateWithLifecycle()
-        
-        // Reactive favorite computation for all peers
-        val peerFavoriteStates = remember(favoritePeers, peerFingerprints, connectedPeers) {
-            connectedPeers.associateWith { peerID ->
-                // Reactive favorite computation - same as ChatHeader
-                val fingerprint = peerFingerprints[peerID]
-                fingerprint != null && favoritePeers.contains(fingerprint)
-            }
-        }
-        
-        // Build mapping of connected peerID -> noise key hex to unify with offline favorites
-        val noiseHexByPeerID: Map<String, String> = connectedPeers.associateWith { pid ->
-            try {
-                viewModel.meshService.getPeerInfo(pid)?.noisePublicKey?.hexEncodedString()
-            } catch (_: Exception) { null }
-        }.filterValues { it != null }.mapValues { it.value!! }
-
-        val peerVerifiedStates = remember(verifiedFingerprints, peerFingerprints, connectedPeers) {
-            connectedPeers.associateWith { peerID ->
-                viewModel.isPeerVerified(peerID, verifiedFingerprints)
-            }
-        }
-
-        Log.d("SidebarComponents", "Recomposing with ${favoritePeers.size} favorites, peer states: $peerFavoriteStates")
-
-        // Smart sorting: unread DMs first, then by most recent DM, then favorites, then alphabetical
-        val sortedPeers = connectedPeers.sortedWith(
-            compareBy<String> { !hasUnreadPrivateMessages.contains(it) } // Unread DM senders first
-            .thenByDescending { privateChats[it]?.maxByOrNull { msg -> msg.timestamp }?.timestamp?.time ?: 0L } // Most recent DM (convert Date to Long)
-            .thenBy { !(peerFavoriteStates[it] ?: false) } // Favorites first
-            .thenBy { (if (it == nickname) "You" else (peerNicknames[it] ?: it)).lowercase() } // Alphabetical
-        )
-        
-        // Build a map of base name counts across all people shown in the list (connected + offline + nostr)
-        val hex64Regex = Regex("^[0-9a-fA-F]{64}$")
-
-        // Helper to compute display name used for a given key
-        fun computeDisplayNameForPeerId(key: String): String {
-            return if (key == nickname) "You" else (peerNicknames[key] ?: (privateChats[key]?.lastOrNull()?.sender ?: key.take(12)))
-        }
-
-        val baseNameCounts = mutableMapOf<String, Int>()
-
-        // Connected peers
-        sortedPeers.forEach { pid ->
-            val dn = computeDisplayNameForPeerId(pid)
-            val (b, _) = com.gap.droid.ui.splitSuffix(dn)
-            if (b != "You") baseNameCounts[b] = (baseNameCounts[b] ?: 0) + 1
-        }
-
-        // Offline favorites (exclude ones mapped to connected)
-        val offlineFavorites = com.gap.droid.favorites.FavoritesPersistenceService.shared.getOurFavorites()
-        offlineFavorites.forEach { fav ->
-            val favPeerID = fav.peerNoisePublicKey.hexEncodedString()
-            val isMappedToConnected = noiseHexByPeerID.values.any { it.equals(favPeerID, ignoreCase = true) }
-            if (!isMappedToConnected) {
-                val dn = peerNicknames[favPeerID] ?: fav.peerNickname
-                val (b, _) = com.gap.droid.ui.splitSuffix(dn)
-                if (b != "You") baseNameCounts[b] = (baseNameCounts[b] ?: 0) + 1
-            }
-        }
-
-        // Nostr-only conversations
-        val connectedIds = sortedPeers.toSet()
-        val appendedOfflineIds = mutableSetOf<String>()
-        privateChats.keys
-            .filter { key ->
-                (key.startsWith("nostr_") || hex64Regex.matches(key)) &&
-                !connectedIds.contains(key) &&
-                !noiseHexByPeerID.values.any { it.equals(key, ignoreCase = true) }
-            }
-            .forEach { convKey ->
-                val dn = peerNicknames[convKey] ?: (privateChats[convKey]?.lastOrNull()?.sender ?: convKey.take(12))
-                val (b, _) = com.gap.droid.ui.splitSuffix(dn)
-                if (b != "You") baseNameCounts[b] = (baseNameCounts[b] ?: 0) + 1
-            }
-
-        sortedPeers.forEach { peerID ->
-            val isFavorite = peerFavoriteStates[peerID] ?: false
-            val isVerified = peerVerifiedStates[peerID] ?: false
-            // fingerprint and favorite relationship resolution not needed here; UI will show Nostr globe for appended offline favorites below
-            
-            val noiseHex = noiseHexByPeerID[peerID]
-            val meshUnread = hasUnreadPrivateMessages.contains(peerID)
-            val nostrUnread = if (noiseHex != null) hasUnreadPrivateMessages.contains(noiseHex) else false
-            val combinedHasUnread = meshUnread || nostrUnread
-            val combinedUnreadCount = (
-                privateChats[peerID]?.count { msg -> msg.sender != nickname && meshUnread } ?: 0
-            ) + (
-                if (noiseHex != null) privateChats[noiseHex]?.count { msg -> msg.sender != nickname && nostrUnread } ?: 0 else 0
-            )
-
-            val displayName = if (peerID == nickname) "You" else (peerNicknames[peerID] ?: (privateChats[peerID]?.lastOrNull()?.sender ?: peerID.take(12)))
-            val (bName, _) = com.gap.droid.ui.splitSuffix(displayName)
-            val showHash = (baseNameCounts[bName] ?: 0) > 1
-
-            val directMap by viewModel.peerDirect.collectAsStateWithLifecycle()
-            val isDirectLive = directMap[peerID] ?: try { viewModel.meshService.getPeerInfo(peerID)?.isDirectConnection == true } catch (_: Exception) { false }
-            PeerItem(
-                peerID = peerID,
-                displayName = displayName,
-                isDirect = isDirectLive,
-                isSelected = peerID == selectedPrivatePeer,
-                isFavorite = isFavorite,
-                isVerified = isVerified,
-                hasUnreadDM = combinedHasUnread,
-                colorScheme = colorScheme,
-                viewModel = viewModel,
-                onItemClick = { onPrivateChatStart(peerID) },
-                onToggleFavorite = { 
-                    Log.d("SidebarComponents", "Sidebar toggle favorite: peerID=$peerID, currentFavorite=$isFavorite")
-                    viewModel.toggleFavorite(peerID) 
-                },
-                unreadCount = if (combinedUnreadCount > 0) combinedUnreadCount else if (combinedHasUnread) 1 else 0,
-                showNostrGlobe = false,
-                showHashSuffix = showHash
-            )
-        }
-
-        // Append offline favorites we actively favorite (and not currently connected)
-        offlineFavorites.forEach { fav ->
-            val favPeerID = fav.peerNoisePublicKey.hexEncodedString()
-            // If any connected peer maps to this noise key, skip showing the offline entry
-            val isMappedToConnected = noiseHexByPeerID.values.any { it.equals(favPeerID, ignoreCase = true) }
-            if (isMappedToConnected) return@forEach
-
-            // Resolve potential Nostr conversation key for this favorite (for unread detection)
-            val nostrConvKey: String? = try {
-                val npubOrHex = com.gap.droid.favorites.FavoritesPersistenceService.shared.findNostrPubkey(fav.peerNoisePublicKey)
-                if (npubOrHex != null) {
-                    val hex = if (npubOrHex.startsWith("npub")) {
-                        val (hrp, data) = com.gap.droid.nostr.Bech32.decode(npubOrHex)
-                        if (hrp == "npub") data.hexEncodedString() else null
-                    } else {
-                        npubOrHex.lowercase()
-                    }
-                    hex?.let { "nostr_${it.take(16)}" }
-                } else null
-            } catch (_: Exception) { null }
-
-            val hasUnread = hasUnreadPrivateMessages.contains(favPeerID) || (nostrConvKey != null && hasUnreadPrivateMessages.contains(nostrConvKey))
-
-            // If user clicks an offline favorite and the mapped peer is currently connected under a different ID,
-            // open chat with the connected peerID instead of the noise hex for a seamless window
-            val mappedConnectedPeerID = noiseHexByPeerID.entries.firstOrNull { it.value.equals(favPeerID, ignoreCase = true) }?.key
-            val dn = peerNicknames[favPeerID] ?: fav.peerNickname
-            val (bName, _) = com.gap.droid.ui.splitSuffix(dn)
-            val showHash = (baseNameCounts[bName] ?: 0) > 1
-            val isVerified = viewModel.isNoisePublicKeyVerified(fav.peerNoisePublicKey, verifiedFingerprints)
-
-            // Compute unreadCount from either noise conversation or Nostr conversation
-            val unreadCount = (
-                privateChats[favPeerID]?.count { msg -> msg.sender != nickname && hasUnreadPrivateMessages.contains(favPeerID) } ?: 0
-            ) + (
-                if (nostrConvKey != null) privateChats[nostrConvKey]?.count { msg -> msg.sender != nickname && hasUnreadPrivateMessages.contains(nostrConvKey) } ?: 0 else 0
-            )
-
-            PeerItem(
-                peerID = favPeerID,
-                displayName = dn,
-                isDirect = false,
-                isSelected = (mappedConnectedPeerID ?: favPeerID) == selectedPrivatePeer,
-                isFavorite = true,
-                isVerified = isVerified,
-                hasUnreadDM = hasUnread,
-                colorScheme = colorScheme,
-                viewModel = viewModel,
-                onItemClick = { onPrivateChatStart(mappedConnectedPeerID ?: favPeerID) },
-                onToggleFavorite = { 
-                    Log.d("SidebarComponents", "Sidebar toggle favorite (offline): peerID=$favPeerID")
-                    viewModel.toggleFavorite(favPeerID)
-                },
-                unreadCount = if (unreadCount > 0) unreadCount else if (hasUnread) 1 else 0,
-                showNostrGlobe = (fav.isMutual && fav.peerNostrPublicKey != null),
-                showHashSuffix = showHash
-            )
-            appendedOfflineIds.add(favPeerID)
-        }
-
-        // NOTE: Do NOT append Nostr-only (nostr_*) conversations to the mesh people list.
-        // Geohash DMs should appear in the GeohashPeople list for the active geohash, not in mesh offline contacts.
-        // We intentionally remove previously-added behavior that mixed geohash DMs into mesh sidebar.
-        // If you need to surface non-geohash offline mesh conversations in the future, do it here for 64-hex noise IDs only.
-        /*
-        val alreadyShownIds = connectedIds + appendedOfflineIds
-        privateChats.keys
-            .filter { key ->
-                // Only include 64-hex noise IDs (mesh identities); exclude any nostr_* aliases
-                hex64Regex.matches(key) &&
-                !alreadyShownIds.contains(key) &&
-                // Skip if this key maps to a connected peer via noiseHex mapping
-                !noiseHexByPeerID.values.any { it.equals(key, ignoreCase = true) }
-            }
-            .sortedBy { key -> privateChats[key]?.lastOrNull()?.timestamp }
-            .forEach { convKey ->
-                val lastSender = privateChats[convKey]?.lastOrNull()?.sender
-                val dn = peerNicknames[convKey] ?: (lastSender ?: convKey.take(12))
-                val (bName, _) = com.gap.droid.ui.splitSuffix(dn)
-                val showHash = (baseNameCounts[bName] ?: 0) > 1
-
-                PeerItem(
-                    peerID = convKey,
-                    displayName = dn,
-                    isDirect = false,
-                    isSelected = convKey == selectedPrivatePeer,
-                    isFavorite = false,
-                    hasUnreadDM = hasUnreadPrivateMessages.contains(convKey),
-                    colorScheme = colorScheme,
-                    viewModel = viewModel,
-                    onItemClick = { onPrivateChatStart(convKey) },
-                    onToggleFavorite = { viewModel.toggleFavorite(convKey) },
-                    unreadCount = privateChats[convKey]?.count { msg ->
-                        msg.sender != nickname && hasUnreadPrivateMessages.contains(convKey)
-                    } ?: if (hasUnreadPrivateMessages.contains(convKey)) 1 else 0,
-                    showNostrGlobe = false,
-                    showHashSuffix = showHash
-                )
-            }
-        */
-        // End intentional removal
-        
-    }
-}
-
-@Composable
-private fun PeerItem(
-    peerID: String,
-    displayName: String,
-    isDirect: Boolean,
-    isSelected: Boolean,
-    isFavorite: Boolean,
-    isVerified: Boolean,
-    hasUnreadDM: Boolean,
-    colorScheme: ColorScheme,
-    viewModel: ChatViewModel,
-    onItemClick: () -> Unit,
-    onToggleFavorite: () -> Unit,
-    unreadCount: Int = 0,
-    showNostrGlobe: Boolean = false,
-    showHashSuffix: Boolean = true
-) {
-    // Split display name for hashtag suffix support (iOS-compatible)
-    val (baseNameRaw, suffixRaw) = com.gap.droid.ui.splitSuffix(displayName)
-    val baseName = truncateNickname(baseNameRaw)
-    val suffix = if (showHashSuffix) suffixRaw else ""
-    val isMe = displayName == "You" || peerID == viewModel.nickname.value
-    
-    // Get consistent peer color (iOS-compatible)
-    val isDark = colorScheme.background.red + colorScheme.background.green + colorScheme.background.blue < 1.5f
-    val assignedColor = viewModel.colorForMeshPeer(peerID, isDark)
-    val baseColor = if (isMe) Color(0xFFFF9500) else assignedColor
-    
-    Row(
-        modifier = Modifier
-            .fillMaxWidth()
-            .clickable { onItemClick() }
-            .background(
-                if (isSelected) colorScheme.primaryContainer.copy(alpha = 0.3f)
-                else Color.Transparent
-            )
-            .padding(horizontal = 24.dp, vertical = 8.dp),
-        verticalAlignment = Alignment.CenterVertically
-    ) {
-        // Show unread badge or signal strength  
-        if (hasUnreadDM) {
-            // Show mail icon for unread DMs (iOS orange)
-            Icon(
-                imageVector = Icons.Filled.Email,
-                contentDescription = stringResource(com.gap.droid.R.string.cd_unread_message),
-                modifier = Modifier.size(16.dp),
-                tint = Color(0xFFFF9500) // iOS orange
-            )
-        } else {
-            // Connection indicator icons
-            if (showNostrGlobe) {
-                // Purple globe to indicate Nostr availability
-                Icon(
-                    imageVector = Icons.Filled.Public,
-                    contentDescription = stringResource(com.gap.droid.R.string.cd_reachable_via_nostr),
-                    modifier = Modifier.size(16.dp),
-                    tint = Color(0xFF9C27B0) // Purple
-                )
-            } else if (!isDirect && isFavorite) {
-                // Offline favorited user: show outlined circle icon
-                Icon(
-                    //painter = androidx.compose.ui.res.painterResource(id = R.drawable.ic_offline_favorite),
-                    imageVector = Icons.Outlined.Circle,
-                    contentDescription = stringResource(com.gap.droid.R.string.cd_offline_favorite),
-                    modifier = Modifier.size(16.dp),
-                    tint = Color.Gray
-                )
-            } else {
-                Icon(
-                    imageVector = if (isDirect) Icons.Outlined.SettingsInputAntenna else Icons.Filled.Route,
-                    contentDescription = if (isDirect) "Direct Bluetooth" else "Routed",
-                    modifier = Modifier.size(16.dp),
-                    tint = colorScheme.onSurface.copy(alpha = 0.8f)
-                )
-            }
-        }
-        
-        Spacer(modifier = Modifier.width(8.dp))
-        
-        // Display name with iOS-style color and hashtag suffix support
-        Row(
-            modifier = Modifier.weight(1f),
-            verticalAlignment = Alignment.CenterVertically
-        ) {
-            // Base name with peer-specific color
-            Text(
-                text = baseName,
-                style = MaterialTheme.typography.bodyMedium.copy(
-                    fontFamily = FontFamily.Monospace,
-                    fontSize = BASE_FONT_SIZE.sp,
-                    fontWeight = if (isMe) FontWeight.Bold else FontWeight.Normal
-                ),
-                color = baseColor,
-                maxLines = 1,
-                overflow = TextOverflow.Ellipsis
-            )
-            
-            // Hashtag suffix in lighter shade (iOS-style)
-            if (suffix.isNotEmpty()) {
-                Text(
-                    text = suffix,
-                    style = MaterialTheme.typography.bodyMedium.copy(
-                        fontFamily = FontFamily.Monospace,
-                        fontSize = BASE_FONT_SIZE.sp
-                    ),
-                    color = baseColor.copy(alpha = 0.6f)
-                )
-            }
-
-            if (isVerified) {
-                Spacer(modifier = Modifier.width(4.dp))
-                Icon(
-                    imageVector = Icons.Filled.Verified,
-                    contentDescription = null,
-                    modifier = Modifier.size(14.dp),
-                    tint = Color(0xFF32D74B)
-                )
-            }
-        }
-        
-        // Favorite star with proper filled/outlined states
-        IconButton(
-            onClick = onToggleFavorite,
-            modifier = Modifier.size(24.dp)
-        ) {
-            Icon(
-                imageVector = if (isFavorite) Icons.Filled.Star else Icons.Outlined.Star,
-                contentDescription = if (isFavorite) "Remove from favorites" else "Add to favorites",
-                modifier = Modifier.size(16.dp),
-                tint = if (isFavorite) Color(0xFFFFD700) else Color(0xFF4CAF50)
-            )
-        }
-    }
-}
-
-
-
-@Composable
-private fun SignalStrengthIndicator(
-    signalStrength: Int,
-    colorScheme: ColorScheme
-) {
-    Row(modifier = Modifier.width(24.dp)) {
-        repeat(3) { index ->
-            val opacity = when {
-                signalStrength >= (index + 1) * 33 -> 1f
-                else -> 0.2f
-            }
-            Box(
-                modifier = Modifier
-                    .size(width = 3.dp, height = (4 + index * 2).dp)
-                    .background(
-                        colorScheme.onSurface.copy(alpha = opacity),
-                        RoundedCornerShape(1.dp)
-                    )
-            )
-            if (index < 2) Spacer(modifier = Modifier.width(2.dp))
-        }
-    }
-}
-
-/**
- * Reusable unread badge component for both channels and private messages
- */
-@Composable
-private fun UnreadBadge(
-    count: Int,
-    colorScheme: ColorScheme,
-    modifier: Modifier = Modifier
-) {
-    if (count > 0) {
-        Box(
-            modifier = modifier
-                .background(
-                    color = Color(0xFFFFD700), // Yellow color
-                    shape = RoundedCornerShape(10.dp)
-                )
-                .padding(horizontal = 2.dp, vertical = 0.dp)
-                .defaultMinSize(minWidth = 14.dp, minHeight = 14.dp),
-            contentAlignment = Alignment.Center
-        ) {
-            Text(
-                text = if (count > 99) "99+" else count.toString(),
-                style = MaterialTheme.typography.labelSmall.copy(
-                    fontSize = 10.sp,
-                    fontWeight = FontWeight.Bold
-                ),
-                color = Color.Black // Black text on yellow background
-            )
-        }
-    }
-}
-
-/**
- * Convert RSSI value (dBm) to signal strength percentage (0-100)
- * RSSI typically ranges from -30 (excellent) to -100 (very poor)
- * Maps to 0-100 scale where:
- * - 0-32: No signal (0 bars)
- * - 33-65: Weak (1 bar) 
- * - 66-98: Good (2 bars)
- * - 99-100: Excellent (3 bars)
- */
-private fun convertRSSIToSignalStrength(rssi: Int?): Int {
-    if (rssi == null) return 0
-    
-    return when {
-        rssi >= -40 -> 100  // Excellent signal
-        rssi >= -55 -> 85   // Very good signal  
-        rssi >= -70 -> 70   // Good signal
-        rssi >= -85 -> 50   // Fair signal
-        rssi >= -100 -> 25  // Poor signal
-        else -> 0           // Very poor or no signal
-    }
-}
-- 
2.50.1 (Apple Git-155)


From 654d385b6df8a304885950b8c7bf0573de5bf74c Mon Sep 17 00:00:00 2001
From: yet300 <96379204+yet300@users.noreply.github.com>
Date: Mon, 12 Jan 2026 12:29:09 +0400
Subject: [PATCH 07/10] UI Refactor (#562)

* Automated update of relay data - Sun Sep 21 06:21:05 UTC 2025

* Automated update of relay data - Sun Sep 28 06:20:40 UTC 2025

* refactor: new close button like ios(but not liquid glass)

* Automated update of relay data - Sun Oct  5 06:20:09 UTC 2025

* Automated update of relay data - Sun Oct 12 06:20:12 UTC 2025

* Automated update of relay data - Sun Oct 19 06:21:51 UTC 2025

* Automated update of relay data - Sun Oct 26 06:21:31 UTC 2025

* Automated update of relay data - Sun Nov  2 06:22:16 UTC 2025

* Automated update of relay data - Sun Nov  9 06:21:43 UTC 2025

* Automated update of relay data - Sun Nov 16 06:22:37 UTC 2025

* Automated update of relay data - Sun Nov 23 06:22:51 UTC 2025

* Automated update of relay data - Sun Nov 30 06:24:08 UTC 2025

* Automated update of relay data - Sun Dec  7 06:22:59 UTC 2025

* Automated update of relay data - Sun Dec 14 06:24:33 UTC 2025

* Automated update of relay data - Sun Dec 21 06:24:49 UTC 2025

* Automated update of relay data - Sun Dec 28 06:25:38 UTC 2025

* Automated update of relay data - Sun Jan  4 06:26:28 UTC 2026

* refactor: Extract CloseButton to core UI components

* feat: Add BitchatBottomSheet component

* refactor: Use BitchatBottomSheet component and minor ui change(CloseButton, colors)

* Refactor: Use BitchatBottomSheet in MeshPeerListSheet

---------

Co-authored-by: GitHub Action <action@github.com>
---
 .../ui/component/sheet/BitchatBottomSheet.kt  | 32 +++++++++++++++
 .../java/com/bitchat/android/ui/AboutSheet.kt | 39 ++-----------------
 .../com/bitchat/android/ui/ChatUserSheet.kt   | 11 +-----
 .../android/ui/LocationChannelsSheet.kt       |  7 ++--
 .../bitchat/android/ui/LocationNotesSheet.kt  | 21 +++-------
 .../android/ui/LocationNotesSheetPresenter.kt |  6 +--
 .../bitchat/android/ui/MeshPeerListSheet.kt   | 13 +++----
 .../android/ui/SecurityVerificationSheet.kt   | 17 +++-----
 .../bitchat/android/ui/VerificationSheet.kt   | 13 ++-----
 .../android/ui/debug/DebugSettingsSheet.kt    | 13 ++-----
 10 files changed, 67 insertions(+), 105 deletions(-)
 create mode 100644 app/src/main/java/com/gap/droid/core/ui/component/sheet/BitchatBottomSheet.kt

diff --git a/app/src/main/java/com/gap/droid/core/ui/component/sheet/BitchatBottomSheet.kt b/app/src/main/java/com/gap/droid/core/ui/component/sheet/BitchatBottomSheet.kt
new file mode 100644
index 0000000..948fd6d
--- /dev/null
+++ b/app/src/main/java/com/gap/droid/core/ui/component/sheet/BitchatBottomSheet.kt
@@ -0,0 +1,32 @@
+package com.gap.droid.core.ui.component.sheet
+
+import androidx.compose.foundation.layout.ColumnScope
+import androidx.compose.foundation.layout.statusBarsPadding
+import androidx.compose.foundation.shape.RoundedCornerShape
+import androidx.compose.material3.ExperimentalMaterial3Api
+import androidx.compose.material3.MaterialTheme
+import androidx.compose.material3.ModalBottomSheet
+import androidx.compose.material3.SheetState
+import androidx.compose.material3.rememberModalBottomSheetState
+import androidx.compose.runtime.Composable
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.unit.dp
+
+@OptIn(ExperimentalMaterial3Api::class)
+@Composable
+fun BitchatBottomSheet(
+    modifier: Modifier = Modifier,
+    sheetState: SheetState = rememberModalBottomSheetState(skipPartiallyExpanded = true),
+    onDismissRequest: () -> Unit,
+    content: @Composable (ColumnScope.() -> Unit),
+) {
+    ModalBottomSheet(
+        modifier = modifier.statusBarsPadding(),
+        onDismissRequest = onDismissRequest,
+        sheetState = sheetState,
+        dragHandle = null,
+        shape = RoundedCornerShape(topStart = 28.dp, topEnd = 28.dp),
+        containerColor = MaterialTheme.colorScheme.background,
+        content = content,
+    )
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/gap/droid/ui/AboutSheet.kt b/app/src/main/java/com/gap/droid/ui/AboutSheet.kt
index d931c02..f137ac6 100644
--- a/app/src/main/java/com/gap/droid/ui/AboutSheet.kt
+++ b/app/src/main/java/com/gap/droid/ui/AboutSheet.kt
@@ -9,18 +9,14 @@ import androidx.compose.foundation.shape.CircleShape
 import androidx.compose.foundation.shape.RoundedCornerShape
 import androidx.compose.material.icons.Icons
 import androidx.compose.material.icons.filled.Bluetooth
-import androidx.compose.material.icons.filled.Close
 import androidx.compose.material.icons.filled.Lock
 import androidx.compose.material.icons.filled.Public
 import androidx.compose.material.icons.filled.Warning
 import androidx.compose.material.icons.filled.Security
-import androidx.compose.material.icons.filled.NetworkCheck
 import androidx.compose.material.icons.filled.Speed
-import androidx.compose.material.icons.outlined.Info
 import androidx.compose.material3.*
 import androidx.compose.runtime.*
 import androidx.compose.ui.Alignment
-import kotlinx.coroutines.launch
 import androidx.compose.ui.Modifier
 import androidx.compose.ui.graphics.Color
 import androidx.compose.ui.graphics.vector.ImageVector
@@ -28,15 +24,14 @@ import androidx.compose.ui.platform.LocalContext
 import androidx.compose.ui.text.TextStyle
 import androidx.compose.ui.text.font.FontFamily
 import androidx.compose.ui.text.font.FontWeight
-import androidx.compose.ui.text.style.BaselineShift
 import androidx.compose.ui.unit.dp
 import androidx.compose.ui.unit.sp
 import com.gap.droid.nostr.NostrProofOfWork
 import com.gap.droid.nostr.PoWPreferenceManager
 import androidx.compose.ui.res.stringResource
-import androidx.lifecycle.compose.collectAsStateWithLifecycle
 import com.gap.droid.R
 import com.gap.droid.core.ui.component.button.CloseButton
+import com.gap.droid.core.ui.component.sheet.BitchatBottomSheet
 import com.gap.droid.net.TorMode
 import com.gap.droid.net.TorPreferenceManager
 import com.gap.droid.net.ArtiTorManager
@@ -218,10 +213,6 @@ fun AboutSheet(
         }
     }
 
-    val sheetState = rememberModalBottomSheetState(
-        skipPartiallyExpanded = true
-    )
-
     val lazyListState = rememberLazyListState()
     val isScrolled by remember {
         derivedStateOf {
@@ -237,12 +228,9 @@ fun AboutSheet(
     val isDark = colorScheme.background.red + colorScheme.background.green + colorScheme.background.blue < 1.5f
     
     if (isPresented) {
-        ModalBottomSheet(
-            modifier = modifier.statusBarsPadding(),
+        BitchatBottomSheet(
+            modifier = modifier,
             onDismissRequest = onDismiss,
-            sheetState = sheetState,
-            containerColor = colorScheme.background,
-            dragHandle = null
         ) {
             Box(modifier = Modifier.fillMaxWidth()) {
                 LazyColumn(
@@ -682,27 +670,6 @@ fun AboutSheet(
     }
 }
 
-@Composable
-fun CloseButton(
-    onClick: () -> Unit,
-    modifier: Modifier = Modifier
-) {
-    IconButton(
-        onClick = onClick,
-        modifier = modifier
-            .size(32.dp),
-        colors = IconButtonDefaults.iconButtonColors(
-            contentColor = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f),
-            containerColor = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.1f)
-        )
-    ) {
-        Icon(
-            imageVector = Icons.Default.Close,
-            contentDescription = "Close",
-            modifier = Modifier.size(18.dp)
-        )
-    }
-}
 /**
  * Password prompt dialog for password-protected channels
  * Kept as dialog since it requires user input
diff --git a/app/src/main/java/com/gap/droid/ui/ChatUserSheet.kt b/app/src/main/java/com/gap/droid/ui/ChatUserSheet.kt
index 54e7aea..36ff15a 100644
--- a/app/src/main/java/com/gap/droid/ui/ChatUserSheet.kt
+++ b/app/src/main/java/com/gap/droid/ui/ChatUserSheet.kt
@@ -4,7 +4,6 @@ import androidx.compose.foundation.layout.*
 import androidx.compose.foundation.lazy.LazyColumn
 import androidx.compose.material3.*
 import androidx.compose.runtime.*
-import androidx.compose.ui.Alignment
 import androidx.compose.ui.Modifier
 import androidx.compose.ui.graphics.Color
 import androidx.compose.ui.text.font.FontFamily
@@ -16,7 +15,7 @@ import androidx.compose.ui.res.stringResource
 import com.gap.droid.R
 import androidx.compose.ui.platform.LocalClipboardManager
 import androidx.compose.ui.text.AnnotatedString
-import kotlinx.coroutines.launch
+import com.gap.droid.core.ui.component.sheet.BitchatBottomSheet
 import com.gap.droid.model.BitchatMessage
 
 /**
@@ -36,11 +35,6 @@ fun ChatUserSheet(
     val coroutineScope = rememberCoroutineScope()
     val clipboardManager = LocalClipboardManager.current
     
-    // Bottom sheet state
-    val sheetState = rememberModalBottomSheetState(
-        skipPartiallyExpanded = true
-    )
-    
     // iOS system colors (matches LocationChannelsSheet exactly)
     val colorScheme = MaterialTheme.colorScheme
     val isDark = colorScheme.background.red + colorScheme.background.green + colorScheme.background.blue < 1.5f
@@ -50,9 +44,8 @@ fun ChatUserSheet(
     val standardGrey = if (isDark) Color(0xFF8E8E93) else Color(0xFF6D6D70) // iOS grey
     
     if (isPresented) {
-        ModalBottomSheet(
+        BitchatBottomSheet(
             onDismissRequest = onDismiss,
-            sheetState = sheetState,
             modifier = modifier
         ) {
             Column(
diff --git a/app/src/main/java/com/gap/droid/ui/LocationChannelsSheet.kt b/app/src/main/java/com/gap/droid/ui/LocationChannelsSheet.kt
index 6f47d68..495683b 100644
--- a/app/src/main/java/com/gap/droid/ui/LocationChannelsSheet.kt
+++ b/app/src/main/java/com/gap/droid/ui/LocationChannelsSheet.kt
@@ -40,6 +40,7 @@ import androidx.compose.ui.res.stringResource
 import androidx.lifecycle.compose.collectAsStateWithLifecycle
 import com.gap.droid.R
 import com.gap.droid.core.ui.component.button.CloseButton
+import com.gap.droid.core.ui.component.sheet.BitchatBottomSheet
 
 /**
  * Location Channels Sheet for selecting geohash-based location channels
@@ -113,12 +114,10 @@ fun LocationChannelsSheet(
     val standardBlue = Color(0xFF007AFF) // iOS blue
 
     if (isPresented) {
-        ModalBottomSheet(
-            modifier = modifier.statusBarsPadding(),
+        BitchatBottomSheet(
+            modifier = modifier,
             onDismissRequest = onDismiss,
             sheetState = sheetState,
-            containerColor = MaterialTheme.colorScheme.background,
-            dragHandle = null
         ) {
             Box(modifier = Modifier.fillMaxWidth()) {
                 LazyColumn(
diff --git a/app/src/main/java/com/gap/droid/ui/LocationNotesSheet.kt b/app/src/main/java/com/gap/droid/ui/LocationNotesSheet.kt
index 93b6d51..222876f 100644
--- a/app/src/main/java/com/gap/droid/ui/LocationNotesSheet.kt
+++ b/app/src/main/java/com/gap/droid/ui/LocationNotesSheet.kt
@@ -16,7 +16,6 @@ import androidx.compose.runtime.*
 import androidx.compose.runtime.getValue
 import androidx.compose.ui.Alignment
 import androidx.compose.ui.Modifier
-import androidx.compose.ui.draw.clip
 import androidx.compose.ui.graphics.Color
 import androidx.compose.ui.platform.LocalContext
 import androidx.compose.ui.text.font.FontFamily
@@ -27,6 +26,8 @@ import androidx.compose.ui.text.font.FontWeight
 import androidx.compose.ui.unit.dp
 import androidx.compose.ui.unit.sp
 import androidx.lifecycle.compose.collectAsStateWithLifecycle
+import com.gap.droid.core.ui.component.button.CloseButton
+import com.gap.droid.core.ui.component.sheet.BitchatBottomSheet
 import com.gap.droid.geohash.GeohashChannelLevel
 import com.gap.droid.geohash.LocationChannelManager
 import com.gap.droid.nostr.LocationNotesManager
@@ -51,7 +52,6 @@ fun LocationNotesSheet(
     val isDark = isSystemInDarkTheme()
     
     // iOS color scheme
-    val backgroundColor = if (isDark) Color.Black else Color.White
     val accentGreen = if (isDark) Color.Green else Color(0xFF008000) // dark: green, light: dark green (0, 0.5, 0)
     
     // Managers
@@ -99,14 +99,10 @@ fun LocationNotesSheet(
             notesManager.cancel()
         }
     }
-    
-    ModalBottomSheet(
+
+    BitchatBottomSheet(
         onDismissRequest = onDismiss,
-        modifier = modifier.statusBarsPadding(),
-        sheetState = rememberModalBottomSheetState(skipPartiallyExpanded = true),
-        dragHandle = null,
-        containerColor = backgroundColor,
-        contentColor = if (isDark) Color.White else Color.Black
+        modifier = modifier,
     ) {
         Box(modifier = Modifier.fillMaxWidth()) {
             LazyColumn(
@@ -121,7 +117,6 @@ fun LocationNotesSheet(
                         locationName = displayLocationName,
                         state = state,
                         accentGreen = accentGreen,
-                        backgroundColor = backgroundColor
                     )
                 }
 
@@ -203,7 +198,6 @@ fun LocationNotesSheet(
                         onDraftChange = { draft = it },
                         sendButtonEnabled = sendButtonEnabled,
                         accentGreen = accentGreen,
-                        backgroundColor = backgroundColor,
                         onSend = {
                             val content = draft.trim()
                             if (content.isNotEmpty()) {
@@ -229,12 +223,11 @@ private fun LocationNotesHeader(
     locationName: String?,
     state: LocationNotesManager.State,
     accentGreen: Color,
-    backgroundColor: Color,
 ) {
     Column(
         modifier = Modifier
             .fillMaxWidth()
-            .background(backgroundColor)
+            .padding(horizontal = 16.dp)
             .padding(top = 16.dp, bottom = 12.dp)
     ) {
         // Localized title with Â±1 and note count
@@ -470,7 +463,6 @@ private fun LocationNotesInputSection(
     onDraftChange: (String) -> Unit,
     sendButtonEnabled: Boolean,
     accentGreen: Color,
-    backgroundColor: Color,
     onSend: () -> Unit
 ) {
     val isDark = isSystemInDarkTheme()
@@ -479,7 +471,6 @@ private fun LocationNotesInputSection(
     Row(
         modifier = Modifier
             .fillMaxWidth()
-            .background(backgroundColor)
             .padding(horizontal = 12.dp, vertical = 8.dp), // Match main chat padding
         verticalAlignment = Alignment.CenterVertically,
         horizontalArrangement = Arrangement.spacedBy(8.dp) // Match main chat spacing
diff --git a/app/src/main/java/com/gap/droid/ui/LocationNotesSheetPresenter.kt b/app/src/main/java/com/gap/droid/ui/LocationNotesSheetPresenter.kt
index d17b6d7..850fdfd 100644
--- a/app/src/main/java/com/gap/droid/ui/LocationNotesSheetPresenter.kt
+++ b/app/src/main/java/com/gap/droid/ui/LocationNotesSheetPresenter.kt
@@ -10,6 +10,7 @@ import androidx.compose.ui.Modifier
 import androidx.compose.ui.platform.LocalContext
 import androidx.compose.ui.unit.dp
 import androidx.lifecycle.compose.collectAsStateWithLifecycle
+import com.gap.droid.core.ui.component.sheet.BitchatBottomSheet
 import com.gap.droid.geohash.GeohashChannelLevel
 import com.gap.droid.geohash.LocationChannelManager
 
@@ -62,11 +63,8 @@ private fun LocationNotesErrorSheet(
     onDismiss: () -> Unit,
     locationManager: LocationChannelManager
 ) {
-    val sheetState = rememberModalBottomSheetState(skipPartiallyExpanded = true)
-    ModalBottomSheet(
+    BitchatBottomSheet(
         onDismissRequest = onDismiss,
-        sheetState = sheetState,
-        containerColor = MaterialTheme.colorScheme.surface
     ) {
         Column(
             modifier = Modifier
diff --git a/app/src/main/java/com/gap/droid/ui/MeshPeerListSheet.kt b/app/src/main/java/com/gap/droid/ui/MeshPeerListSheet.kt
index e2f1694..eb20efc 100644
--- a/app/src/main/java/com/gap/droid/ui/MeshPeerListSheet.kt
+++ b/app/src/main/java/com/gap/droid/ui/MeshPeerListSheet.kt
@@ -25,6 +25,8 @@ import androidx.compose.ui.unit.dp
 import androidx.compose.ui.unit.sp
 import androidx.compose.ui.text.style.TextOverflow
 import androidx.lifecycle.compose.collectAsStateWithLifecycle
+import com.gap.droid.core.ui.component.button.CloseButton
+import com.gap.droid.core.ui.component.sheet.BitchatBottomSheet
 import com.gap.droid.geohash.ChannelID
 import com.gap.droid.ui.theme.BASE_FONT_SIZE
 
@@ -77,12 +79,10 @@ fun MeshPeerListSheet(
     )
 
     if (isPresented) {
-        ModalBottomSheet(
-            modifier = modifier.statusBarsPadding(),
+        BitchatBottomSheet(
+            modifier = modifier,
             onDismissRequest = onDismiss,
             sheetState = sheetState,
-            containerColor = MaterialTheme.colorScheme.background,
-            dragHandle = null
         ) {
             Box(modifier = Modifier.fillMaxWidth()) {
                 LazyColumn(
@@ -851,12 +851,9 @@ private fun PrivateChatSheet(
     )
 
     if (isPresented) {
-        ModalBottomSheet(
-            modifier = Modifier.statusBarsPadding(),
+        BitchatBottomSheet(
             onDismissRequest = onDismiss,
             sheetState = sheetState,
-            containerColor = colorScheme.background,
-            dragHandle = null
         ) {
             Box(modifier = Modifier.fillMaxSize()) {
                 Column(
diff --git a/app/src/main/java/com/gap/droid/ui/SecurityVerificationSheet.kt b/app/src/main/java/com/gap/droid/ui/SecurityVerificationSheet.kt
index 59fe608..9a4a159 100644
--- a/app/src/main/java/com/gap/droid/ui/SecurityVerificationSheet.kt
+++ b/app/src/main/java/com/gap/droid/ui/SecurityVerificationSheet.kt
@@ -11,7 +11,6 @@ import androidx.compose.foundation.layout.Spacer
 import androidx.compose.foundation.layout.fillMaxSize
 import androidx.compose.foundation.layout.fillMaxWidth
 import androidx.compose.foundation.layout.padding
-import androidx.compose.foundation.layout.statusBarsPadding
 import androidx.compose.foundation.layout.width
 import androidx.compose.material.icons.Icons
 import androidx.compose.material.icons.filled.Lock
@@ -22,14 +21,12 @@ import androidx.compose.material.icons.outlined.Sync
 import androidx.compose.material.icons.outlined.Warning as OutlinedWarning
 import androidx.compose.material3.Button
 import androidx.compose.material3.ButtonDefaults
+import androidx.compose.material3.DropdownMenu
+import androidx.compose.material3.DropdownMenuItem
 import androidx.compose.material3.ExperimentalMaterial3Api
 import androidx.compose.material3.Icon
 import androidx.compose.material3.MaterialTheme
-import androidx.compose.material3.ModalBottomSheet
-import androidx.compose.material3.DropdownMenu
-import androidx.compose.material3.DropdownMenuItem
 import androidx.compose.material3.Text
-import androidx.compose.material3.rememberModalBottomSheetState
 import androidx.compose.runtime.Composable
 import androidx.compose.runtime.getValue
 import androidx.compose.runtime.mutableStateOf
@@ -49,6 +46,8 @@ import androidx.compose.ui.unit.dp
 import androidx.compose.ui.unit.sp
 import androidx.lifecycle.compose.collectAsStateWithLifecycle
 import com.gap.droid.R
+import com.gap.droid.core.ui.component.button.CloseButton
+import com.gap.droid.core.ui.component.sheet.BitchatBottomSheet
 
 private data class SecurityStatusInfo(
     val text: String,
@@ -66,7 +65,6 @@ fun SecurityVerificationSheet(
 ) {
     if (!isPresented) return
 
-    val sheetState = rememberModalBottomSheetState(skipPartiallyExpanded = true)
     val peerID by viewModel.selectedPrivateChatPeer.collectAsStateWithLifecycle()
     val verifiedFingerprints by viewModel.verifiedFingerprints.collectAsStateWithLifecycle()
     val peerSessionStates by viewModel.peerSessionStates.collectAsStateWithLifecycle()
@@ -76,12 +74,9 @@ fun SecurityVerificationSheet(
     val boxColor = if (isDark) Color.White.copy(alpha = 0.06f) else Color.Black.copy(alpha = 0.06f)
     val peerHexRegex = remember { Regex("^[0-9a-fA-F]{16}$") }
 
-    ModalBottomSheet(
-        modifier = modifier.statusBarsPadding(),
+    BitchatBottomSheet(
+        modifier = modifier,
         onDismissRequest = onDismiss,
-        sheetState = sheetState,
-        containerColor = MaterialTheme.colorScheme.background,
-        dragHandle = null
     ) {
         Column(
             modifier = Modifier
diff --git a/app/src/main/java/com/gap/droid/ui/VerificationSheet.kt b/app/src/main/java/com/gap/droid/ui/VerificationSheet.kt
index 896a66c..1bf86b5 100644
--- a/app/src/main/java/com/gap/droid/ui/VerificationSheet.kt
+++ b/app/src/main/java/com/gap/droid/ui/VerificationSheet.kt
@@ -25,7 +25,6 @@ import androidx.compose.foundation.layout.fillMaxSize
 import androidx.compose.foundation.layout.fillMaxWidth
 import androidx.compose.foundation.layout.padding
 import androidx.compose.foundation.layout.size
-import androidx.compose.foundation.layout.statusBarsPadding
 import androidx.compose.foundation.rememberScrollState
 import androidx.compose.foundation.shape.RoundedCornerShape
 import androidx.compose.foundation.text.selection.SelectionContainer
@@ -38,9 +37,7 @@ import androidx.compose.material3.ButtonDefaults
 import androidx.compose.material3.ExperimentalMaterial3Api
 import androidx.compose.material3.Icon
 import androidx.compose.material3.MaterialTheme
-import androidx.compose.material3.ModalBottomSheet
 import androidx.compose.material3.Text
-import androidx.compose.material3.rememberModalBottomSheetState
 import androidx.compose.runtime.Composable
 import androidx.compose.runtime.DisposableEffect
 import androidx.compose.runtime.collectAsState
@@ -68,6 +65,8 @@ import androidx.core.graphics.set
 import androidx.lifecycle.compose.LocalLifecycleOwner
 import androidx.lifecycle.compose.collectAsStateWithLifecycle
 import com.gap.droid.R
+import com.gap.droid.core.ui.component.button.CloseButton
+import com.gap.droid.core.ui.component.sheet.BitchatBottomSheet
 import com.gap.droid.services.VerificationService
 import com.google.accompanist.permissions.ExperimentalPermissionsApi
 import com.google.accompanist.permissions.isGranted
@@ -93,7 +92,6 @@ fun VerificationSheet(
 ) {
     if (!isPresented) return
 
-    val sheetState = rememberModalBottomSheetState(skipPartiallyExpanded = true)
     val isDark = isSystemInDarkTheme()
     val accent = if (isDark) Color.Green else Color(0xFF008000)
     val boxColor = if (isDark) Color.White.copy(alpha = 0.06f) else Color.Black.copy(alpha = 0.06f)
@@ -109,12 +107,9 @@ fun VerificationSheet(
         viewModel.buildMyQRString(nickname, npub)
     }
 
-    ModalBottomSheet(
-        modifier = modifier.statusBarsPadding(),
+    BitchatBottomSheet(
+        modifier = modifier,
         onDismissRequest = onDismiss,
-        sheetState = sheetState,
-        containerColor = MaterialTheme.colorScheme.background,
-        dragHandle = null
     ) {
         Column(
             modifier = Modifier
diff --git a/app/src/main/java/com/gap/droid/ui/debug/DebugSettingsSheet.kt b/app/src/main/java/com/gap/droid/ui/debug/DebugSettingsSheet.kt
index 4b9f983..f4f716a 100644
--- a/app/src/main/java/com/gap/droid/ui/debug/DebugSettingsSheet.kt
+++ b/app/src/main/java/com/gap/droid/ui/debug/DebugSettingsSheet.kt
@@ -5,13 +5,11 @@ import androidx.compose.foundation.clickable
 import androidx.compose.foundation.layout.*
 import androidx.compose.foundation.layout.FlowRow
 import androidx.compose.foundation.lazy.LazyColumn
-import androidx.compose.foundation.lazy.items
 import androidx.compose.foundation.shape.RoundedCornerShape
 import androidx.compose.foundation.layout.ExperimentalLayoutApi
 import androidx.compose.material.icons.Icons
 import androidx.compose.material.icons.filled.Bluetooth
 import androidx.compose.material.icons.filled.BugReport
-import androidx.compose.material.icons.filled.Cancel
 import androidx.compose.material.icons.filled.Devices
 import androidx.compose.material.icons.filled.PowerSettingsNew
 import androidx.compose.material.icons.filled.SettingsEthernet
@@ -31,8 +29,7 @@ import kotlinx.coroutines.launch
 import androidx.compose.ui.res.stringResource
 import com.gap.droid.R
 import androidx.compose.ui.platform.LocalContext
-import com.gap.droid.service.MeshServicePreferences
-import com.gap.droid.service.MeshForegroundService
+import com.gap.droid.core.ui.component.sheet.BitchatBottomSheet
 
 private enum class GraphMode { OVERALL, PER_DEVICE, PER_PEER }
 
@@ -43,7 +40,6 @@ fun DebugSettingsSheet(
     onDismiss: () -> Unit,
     meshService: BluetoothMeshService
 ) {
-    val sheetState = rememberModalBottomSheetState(skipPartiallyExpanded = false)
     val colorScheme = MaterialTheme.colorScheme
     val manager = remember { DebugSettingsManager.getInstance() }
 
@@ -95,9 +91,8 @@ fun DebugSettingsSheet(
 
     if (!isPresented) return
 
-    ModalBottomSheet(
+    BitchatBottomSheet(
         onDismissRequest = onDismiss,
-        sheetState = sheetState
     ) {
         // Mark debug sheet visible/invisible to gate heavy work
         LaunchedEffect(Unit) { DebugSettingsManager.getInstance().setDebugSheetVisible(true) }
@@ -107,8 +102,8 @@ fun DebugSettingsSheet(
         LazyColumn(
             modifier = Modifier
                 .fillMaxWidth()
-                .padding(horizontal = 16.dp)
-                .padding(bottom = 24.dp),
+                .padding(horizontal = 16.dp),
+            contentPadding = PaddingValues(top = 80.dp),
             verticalArrangement = Arrangement.spacedBy(16.dp)
         ) {
             item {
-- 
2.50.1 (Apple Git-155)


From d164b3f9bc9b9bf6ccd6c42e6e69f824723c3153 Mon Sep 17 00:00:00 2001
From: callebtc <93376500+callebtc@users.noreply.github.com>
Date: Tue, 13 Jan 2026 03:23:53 +0700
Subject: [PATCH 08/10] Implement Geohash Presence (Heartbeats) (#576)

* geohash announce

* only for some geohashes

* global presence right away

* jitter delays

* show ? people for high-precision geohashes

* 1000 events
---
 .../android/nostr/GeohashMessageHandler.kt    | 22 +++--
 .../com/bitchat/android/nostr/NostrEvent.kt   |  1 +
 .../com/bitchat/android/nostr/NostrFilter.kt  |  6 +-
 .../bitchat/android/nostr/NostrProtocol.kt    | 22 +++++
 .../bitchat/android/ui/GeohashViewModel.kt    | 74 +++++++++++++-
 .../android/ui/LocationChannelsSheet.kt       | 21 +++-
 docs/GeohashPresenceSpec.md                   | 96 +++++++++++++++++++
 7 files changed, 229 insertions(+), 13 deletions(-)
 create mode 100644 docs/GeohashPresenceSpec.md

diff --git a/app/src/main/java/com/gap/droid/nostr/GeohashMessageHandler.kt b/app/src/main/java/com/gap/droid/nostr/GeohashMessageHandler.kt
index 0e6e663..ec3af4e 100644
--- a/app/src/main/java/com/gap/droid/nostr/GeohashMessageHandler.kt
+++ b/app/src/main/java/com/gap/droid/nostr/GeohashMessageHandler.kt
@@ -46,15 +46,17 @@ class GeohashMessageHandler(
     fun onEvent(event: NostrEvent, subscribedGeohash: String) {
         scope.launch(Dispatchers.Default) {
             try {
-                if (event.kind != 20000) return@launch
+                if (event.kind != NostrKind.EPHEMERAL_EVENT && event.kind != NostrKind.GEOHASH_PRESENCE) return@launch
                 val tagGeo = event.tags.firstOrNull { it.size >= 2 && it[0] == "g" }?.getOrNull(1)
                 if (tagGeo == null || !tagGeo.equals(subscribedGeohash, true)) return@launch
                 if (dedupe(event.id)) return@launch
 
-                // PoW validation (if enabled)
-                val pow = PoWPreferenceManager.getCurrentSettings()
-                if (pow.enabled && pow.difficulty > 0) {
-                    if (!NostrProofOfWork.validateDifficulty(event, pow.difficulty)) return@launch
+                // PoW validation (if enabled) - apply to chat messages primarily
+                if (event.kind == NostrKind.EPHEMERAL_EVENT) {
+                    val pow = PoWPreferenceManager.getCurrentSettings()
+                    if (pow.enabled && pow.difficulty > 0) {
+                        if (!NostrProofOfWork.validateDifficulty(event, pow.difficulty)) return@launch
+                    }
                 }
 
                 // Blocked users check (use injected DataManager which has loaded state)
@@ -62,7 +64,12 @@ class GeohashMessageHandler(
 
                 // Update repository (participants, nickname, teleport)
                 // Update repository on a background-safe path; repository will post updates to LiveData
-                repo.updateParticipant(subscribedGeohash, event.pubkey, Date(event.createdAt * 1000L))
+                
+                // Update participant count (last seen) on BOTH Presence (20001) and Chat (20000) events
+                if (event.kind == NostrKind.GEOHASH_PRESENCE || event.kind == NostrKind.EPHEMERAL_EVENT) {
+                    repo.updateParticipant(subscribedGeohash, event.pubkey, Date(event.createdAt * 1000L))
+                }
+                
                 event.tags.find { it.size >= 2 && it[0] == "n" }?.let { repo.cacheNickname(event.pubkey, it[1]) }
                 event.tags.find { it.size >= 2 && it[0] == "t" && it[1] == "teleport" }?.let { repo.markTeleported(event.pubkey) }
                 // Register a geohash DM alias for this participant so MessageRouter can route DMs via Nostr
@@ -70,6 +77,9 @@ class GeohashMessageHandler(
                     com.gap.droid.nostr.GeohashAliasRegistry.put("nostr_${event.pubkey.take(16)}", event.pubkey)
                 } catch (_: Exception) { }
 
+                // Stop here for presence events - they don't produce chat messages
+                if (event.kind == NostrKind.GEOHASH_PRESENCE) return@launch
+
                 // Skip our own events for message emission
                 val my = NostrIdentityBridge.deriveIdentity(subscribedGeohash, application)
                 if (my.publicKeyHex.equals(event.pubkey, true)) return@launch
diff --git a/app/src/main/java/com/gap/droid/nostr/NostrEvent.kt b/app/src/main/java/com/gap/droid/nostr/NostrEvent.kt
index 785b41f..92752b1 100644
--- a/app/src/main/java/com/gap/droid/nostr/NostrEvent.kt
+++ b/app/src/main/java/com/gap/droid/nostr/NostrEvent.kt
@@ -215,6 +215,7 @@ object NostrKind {
     const val SEAL = 13              // NIP-17 sealed event
     const val GIFT_WRAP = 1059       // NIP-17 gift wrap
     const val EPHEMERAL_EVENT = 20000 // For geohash channels
+    const val GEOHASH_PRESENCE = 20001 // For geohash presence heartbeat
 }
 
 /**
diff --git a/app/src/main/java/com/gap/droid/nostr/NostrFilter.kt b/app/src/main/java/com/gap/droid/nostr/NostrFilter.kt
index b6313ea..247162a 100644
--- a/app/src/main/java/com/gap/droid/nostr/NostrFilter.kt
+++ b/app/src/main/java/com/gap/droid/nostr/NostrFilter.kt
@@ -32,11 +32,11 @@ data class NostrFilter(
         }
         
         /**
-         * Create filter for geohash-scoped ephemeral events (kind 20000)
+         * Create filter for geohash-scoped ephemeral events (kind 20000 and 20001)
          */
-        fun geohashEphemeral(geohash: String, since: Long? = null, limit: Int = 200): NostrFilter {
+        fun geohashEphemeral(geohash: String, since: Long? = null, limit: Int = 1000): NostrFilter {
             return NostrFilter(
-                kinds = listOf(NostrKind.EPHEMERAL_EVENT),
+                kinds = listOf(NostrKind.EPHEMERAL_EVENT, NostrKind.GEOHASH_PRESENCE),
                 since = since?.let { (it / 1000).toInt() },
                 tagFilters = mapOf("g" to listOf(geohash)),
                 limit = limit
diff --git a/app/src/main/java/com/gap/droid/nostr/NostrProtocol.kt b/app/src/main/java/com/gap/droid/nostr/NostrProtocol.kt
index 0b94bf7..1e0b51f 100644
--- a/app/src/main/java/com/gap/droid/nostr/NostrProtocol.kt
+++ b/app/src/main/java/com/gap/droid/nostr/NostrProtocol.kt
@@ -117,6 +117,28 @@ object NostrProtocol {
         
         return@withContext senderIdentity.signEvent(event)
     }
+
+    /**
+     * Create a geohash-scoped presence event (kind 20001)
+     * Has no content and no nickname, used for participant counting
+     */
+    suspend fun createGeohashPresenceEvent(
+        geohash: String,
+        senderIdentity: NostrIdentity
+    ): NostrEvent = withContext(Dispatchers.Default) {
+        val tags = mutableListOf<List<String>>()
+        tags.add(listOf("g", geohash))
+
+        val event = NostrEvent(
+            pubkey = senderIdentity.publicKeyHex,
+            createdAt = (System.currentTimeMillis() / 1000).toInt(),
+            kind = NostrKind.GEOHASH_PRESENCE,
+            tags = tags,
+            content = ""
+        )
+
+        return@withContext senderIdentity.signEvent(event)
+    }
     
     /**
      * Create a geohash-scoped ephemeral public message (kind 20000)
diff --git a/app/src/main/java/com/gap/droid/ui/GeohashViewModel.kt b/app/src/main/java/com/gap/droid/ui/GeohashViewModel.kt
index 4d66e30..a25fb37 100644
--- a/app/src/main/java/com/gap/droid/ui/GeohashViewModel.kt
+++ b/app/src/main/java/com/gap/droid/ui/GeohashViewModel.kt
@@ -19,6 +19,9 @@ import kotlinx.coroutines.delay
 import kotlinx.coroutines.flow.StateFlow
 import kotlinx.coroutines.launch
 import java.util.Date
+import kotlinx.coroutines.flow.collectLatest
+import kotlinx.coroutines.isActive
+import kotlinx.coroutines.Dispatchers
 
 class GeohashViewModel(
     application: Application,
@@ -55,6 +58,7 @@ class GeohashViewModel(
     private var currentGeohashSubId: String? = null
     private var currentDmSubId: String? = null
     private var geoTimer: Job? = null
+    private var globalPresenceJob: Job? = null
     private var locationChannelManager: com.gap.droid.geohash.LocationChannelManager? = null
 
     val geohashPeople: StateFlow<List<GeoPerson>> = state.geohashPeople
@@ -86,6 +90,10 @@ class GeohashViewModel(
                     state.setIsTeleported(teleported)
                 }
             }
+            
+            // Start global presence heartbeat loop
+            startGlobalPresenceHeartbeat()
+            
         } catch (e: Exception) {
             Log.e(TAG, "Failed to initialize location channel state: ${e.message}")
             state.setSelectedLocationChannel(com.gap.droid.geohash.ChannelID.Mesh)
@@ -93,6 +101,49 @@ class GeohashViewModel(
         }
     }
 
+    private fun startGlobalPresenceHeartbeat() {
+        globalPresenceJob?.cancel()
+        globalPresenceJob = viewModelScope.launch(kotlinx.coroutines.Dispatchers.IO) {
+            // Reactively restart heartbeat whenever available channels change
+            locationChannelManager?.availableChannels?.collectLatest { channels ->
+                // Filter for REGION (2), PROVINCE (4), CITY (5) - precision <= 5
+                val targetGeohashes = channels.filter { it.level.precision <= 5 }.map { it.geohash }
+
+                if (targetGeohashes.isNotEmpty()) {
+                    // Enter heartbeat loop for this set of channels
+                    // If channels change (e.g. user moves), collectLatest cancels this loop and starts a new one immediately
+                    while (true) {
+                        // Randomize loop interval (40-80s, average 60s)
+                        val loopInterval = kotlin.random.Random.nextLong(40000L, 80000L)
+                        var timeSpent = 0L
+
+                        try {
+                            Log.v(TAG, "ðŸ’“ Broadcasting global presence to ${targetGeohashes.size} channels")
+                            targetGeohashes.forEach { geohash ->
+                                // Decorrelate individual broadcasts with random delay (1s-5s)
+                                val stepDelay = kotlin.random.Random.nextLong(1000L, 10000L)
+                                delay(stepDelay)
+                                timeSpent += stepDelay
+                                
+                                broadcastPresence(geohash)
+                            }
+                        } catch (e: Exception) {
+                            Log.w(TAG, "Global presence heartbeat error: ${e.message}")
+                        }
+                        
+                        // Wait remaining time to satisfy target average cadence
+                        val remaining = loopInterval - timeSpent
+                        if (remaining > 0) {
+                            delay(remaining)
+                        } else {
+                            delay(10000L) // Minimum guard delay
+                        }
+                    }
+                }
+            }
+        }
+    }
+
     fun panicReset() {
         repo.clearAll()
         GeohashAliasRegistry.clear()
@@ -102,10 +153,25 @@ class GeohashViewModel(
         currentDmSubId = null
         geoTimer?.cancel()
         geoTimer = null
+        globalPresenceJob?.cancel()
+        globalPresenceJob = null
         try { NostrIdentityBridge.clearAllAssociations(getApplication()) } catch (_: Exception) {}
         initialize()
     }
 
+    private suspend fun broadcastPresence(geohash: String) {
+        try {
+            val identity = NostrIdentityBridge.deriveIdentity(geohash, getApplication())
+            val event = NostrProtocol.createGeohashPresenceEvent(geohash, identity)
+            val relayManager = NostrRelayManager.getInstance(getApplication())
+            // Presence is lightweight, send to geohash relays
+            relayManager.sendEventToGeohash(event, geohash, includeDefaults = false, nRelays = 5)
+            Log.v(TAG, "ðŸ’“ Sent presence heartbeat for $geohash")
+        } catch (e: Exception) {
+            Log.w(TAG, "Failed to send presence for $geohash: ${e.message}")
+        }
+    }
+
     fun sendGeohashMessage(content: String, channel: com.gap.droid.geohash.GeohashChannel, myPeerID: String, nickname: String?) {
         viewModelScope.launch {
             try {
@@ -147,6 +213,8 @@ class GeohashViewModel(
     fun beginGeohashSampling(geohashes: List<String>) {
         if (geohashes.isEmpty()) return
         Log.d(TAG, "ðŸŒ Beginning geohash sampling for ${geohashes.size} geohashes")
+        
+        // Subscribe to events
         viewModelScope.launch {
             geohashes.forEach { geohash ->
                 subscriptionManager.subscribeGeohash(
@@ -160,7 +228,9 @@ class GeohashViewModel(
         }
     }
 
-    fun endGeohashSampling() { Log.d(TAG, "ðŸŒ Ending geohash sampling") }
+    fun endGeohashSampling() { 
+        Log.d(TAG, "ðŸŒ Ending geohash sampling")
+    }
     fun geohashParticipantCount(geohash: String): Int = repo.geohashParticipantCount(geohash)
     fun isPersonTeleported(pubkeyHex: String): Boolean = repo.isPersonTeleported(pubkeyHex)
 
@@ -238,7 +308,7 @@ class GeohashViewModel(
 
                 try {
                     val identity = NostrIdentityBridge.deriveIdentity(channel.channel.geohash, getApplication())
-                    repo.updateParticipant(channel.channel.geohash, identity.publicKeyHex, Date())
+                    // We don't update participant here anymore; presence loop handles it via Kind 20001
                     val teleported = state.isTeleported.value
                     if (teleported) repo.markTeleported(identity.publicKeyHex)
                 } catch (e: Exception) { Log.w(TAG, "Failed identity setup: ${e.message}") }
diff --git a/app/src/main/java/com/gap/droid/ui/LocationChannelsSheet.kt b/app/src/main/java/com/gap/droid/ui/LocationChannelsSheet.kt
index 495683b..d3835a2 100644
--- a/app/src/main/java/com/gap/droid/ui/LocationChannelsSheet.kt
+++ b/app/src/main/java/com/gap/droid/ui/LocationChannelsSheet.kt
@@ -706,7 +706,16 @@ private fun meshCount(viewModel: ChatViewModel): Int {
 @Composable
 private fun geohashTitleWithCount(channel: GeohashChannel, participantCount: Int): String {
     val ctx = androidx.compose.ui.platform.LocalContext.current
-    val peopleText = ctx.resources.getQuantityString(com.gap.droid.R.plurals.people_count, participantCount, participantCount)
+    
+    // For high precision channels (Neighborhood, Block) where we don't broadcast presence,
+    // show "? people" instead of "0 people" to avoid misleading "nobody is here" indication.
+    val isHighPrecision = channel.level.precision > 5
+    val peopleText = if (isHighPrecision && participantCount == 0) {
+        ctx.resources.getQuantityString(com.gap.droid.R.plurals.people_count, 0, 0).replace("0", "?")
+    } else {
+        ctx.resources.getQuantityString(com.gap.droid.R.plurals.people_count, participantCount, participantCount)
+    }
+
     val levelName = when (channel.level) {
         com.gap.droid.geohash.GeohashChannelLevel.BUILDING -> "Building" // iOS: precision 8 for location notes
         com.gap.droid.geohash.GeohashChannelLevel.BLOCK -> stringResource(com.gap.droid.R.string.location_level_block)
@@ -721,7 +730,15 @@ private fun geohashTitleWithCount(channel: GeohashChannel, participantCount: Int
 @Composable
 private fun geohashHashTitleWithCount(geohash: String, participantCount: Int): String {
     val ctx = androidx.compose.ui.platform.LocalContext.current
-    val peopleText = ctx.resources.getQuantityString(com.gap.droid.R.plurals.people_count, participantCount, participantCount)
+    val level = levelForLength(geohash.length)
+    val isHighPrecision = level.precision > 5
+
+    val peopleText = if (isHighPrecision && participantCount == 0) {
+        ctx.resources.getQuantityString(com.gap.droid.R.plurals.people_count, 0, 0).replace("0", "?")
+    } else {
+        ctx.resources.getQuantityString(com.gap.droid.R.plurals.people_count, participantCount, participantCount)
+    }
+    
     return "#$geohash [$peopleText]"
 }
 
diff --git a/docs/GeohashPresenceSpec.md b/docs/GeohashPresenceSpec.md
new file mode 100644
index 0000000..321a491
--- /dev/null
+++ b/docs/GeohashPresenceSpec.md
@@ -0,0 +1,96 @@
+# Geohash Presence Specification
+
+## Overview
+
+The Geohash Presence feature provides a mechanism to track online participants in geohash-based location channels. It uses a dedicated ephemeral Nostr event kind to broadcast "heartbeats," ensuring accurate and privacy-preserving online counts.
+
+## Nostr Protocol
+
+### Event Kind
+A new ephemeral event kind is defined for presence heartbeats:
+- **Kind:** `20001` (`GEOHASH_PRESENCE`)
+- **Type:** Ephemeral (not stored by relays long-term)
+
+### Event Structure
+The presence event mimics the structure of a geohash chat message (Kind 20000) but without content or nickname metadata, to minimize overhead and focus purely on "liveness".
+
+```json
+{
+  "kind": 20001,
+  "created_at": <timestamp>,
+  "tags": [
+    ["g", "<geohash>"]
+  ],
+  "content": "",
+  "pubkey": "<geohash_derived_pubkey>",
+  "id": "<event_id>",
+  "sig": "<signature>"
+}
+```
+
+*   **`content`**: Must be empty string.
+*   **`tags`**: Must include `["g", "<geohash>"]`. Should NOT include `["n", "<nickname>"]`.
+*   **`pubkey`**: The ephemeral identity derived specifically for this geohash (same as used for chat messages).
+
+## Client Behavior
+
+### 1. Broadcasting Presence
+
+Clients MUST broadcast a Kind 20001 presence event globally when the app is open, regardless of which screen the user is viewing.
+
+*   **Global Heartbeat:**
+    *   **Trigger:** Application start / initialization, or whenever location (available geohashes) changes.
+    *   **Frequency:** Randomized loop interval between **40s and 80s** (average 60s).
+    *   **Scope:** Sent to *all* geohash channels corresponding to the device's *current physical location*.
+    *   **Privacy Restriction:** Presence MUST ONLY be broadcast to low-precision geohash levels to protect user privacy. Specifically:
+        *   **Allowed:** `REGION` (precision 2), `PROVINCE` (precision 4), `CITY` (precision 5).
+        *   **Denied:** `NEIGHBORHOOD` (precision 6), `BLOCK` (precision 7), `BUILDING` (precision 8+).
+    *   **Decorrelation:** Individual broadcasts within a heartbeat loop must be separated by random delays (e.g., 2-5 seconds) to prevent temporal correlation of public keys across different geohash levels. The main loop delay is adjusted to maintain the target average cadence.
+
+### 2. Subscribing to Presence
+
+Clients must update their Nostr filters to listen for both chat and presence events on geohash channels.
+
+*   **Filter:**
+    *   `kinds`: `[20000, 20001]`
+    *   `#g`: `["<geohash>"]`
+
+### 3. Participant Counting
+
+The "online participants" count shown in the UI aggregates unique public keys from both presence heartbeats and active chat messages.
+
+*   **Logic:**
+    *   Maintain a map of `pubkey -> last_seen_timestamp` for each geohash.
+    *   Update `last_seen_timestamp` upon receiving a valid **Kind 20001 (Presence)** OR **Kind 20000 (Chat)** event.
+    *   A participant is considered "online" if their `last_seen_timestamp` is within the last **5 minutes**.
+
+### 4. UI Presentation
+
+The presentation of the participant count depends on the geohash precision level and data availability.
+
+*   **Standard Display:** For channels where presence is broadcast (Region, Province, City) OR any channel where at least one participant has been detected, show the exact count: `[N people]`.
+*   **High-Precision Uncertainty:** For high-precision channels (Neighborhood, Block, Building) where:
+    *   Presence broadcasting is disabled (privacy restriction).
+    *   **AND** the detected participant count is `0`.
+    *   **Display:** `[? people]`
+    *   **Reasoning:** Since clients don't announce themselves in these channels, a count of "0" is misleading (people could be lurking).
+
+### 5. Implementation Details (Android Reference)
+
+*   **`NostrKind.GEOHASH_PRESENCE`**: Added constant `20001`.
+*   **`NostrProtocol.createGeohashPresenceEvent`**: Helper to generate the event.
+*   **`GeohashViewModel`**:
+    *   `startGlobalPresenceHeartbeat()`: Coroutine that `collectLatest` on `LocationChannelManager.availableChannels`.
+    *   Implements randomized loop logic (40-80s) and per-broadcast random delays (2-5s).
+    *   Filters channels by `precision <= 5` before broadcasting.
+*   **`GeohashMessageHandler`**:
+    *   Refactored `onEvent` to update participant counts for both Kind 20000 and 20001.
+*   **`LocationChannelsSheet`**:
+    *   Implements the `[? people]` display logic for high-precision, zero-count channels.
+
+## Benefits
+
+*   **Accuracy:** Counts reflect both active listeners (via heartbeats) and active speakers (via messages).
+*   **Privacy:** High-precision location presence is NOT broadcast. Temporal correlation between different levels is obfuscated via random delays.
+*   **Consistency:** "Online" status is maintained globally while the app is open.
+*   **Transparency:** The UI correctly reflects uncertainty (`?`) when privacy rules prevent accurate passive counting.
-- 
2.50.1 (Apple Git-155)


From 66012e9fe954c603dcf3e31ad62202159a337a92 Mon Sep 17 00:00:00 2001
From: callebtc <93376500+callebtc@users.noreply.github.com>
Date: Tue, 13 Jan 2026 04:18:07 +0700
Subject: [PATCH 09/10] Gossip mesh topology + source-based routing (#445)

* wip mesh graph

* gossip fix

* gossip works

* source-based routing wip

* log

* update spec to be explicit about intermediate hops only

* drop duplicate hops

* add to spec

* test

* forgot comma

* source routing v2

* add compression bomb protection

* v2 source routing

* fragmented packets inherit route

* update spec

* Gossip routing tmp with connection limit fixed (#569)

* fix: r8 exception for LocationManager (#566)

* fragmented packets inherit route

* update spec

* fix connection limits

* fix: deserialization issue with routed packets

* log

* dynamic fragment size

* fragment size

* add tests

* feat(gossip): implement two-way handshake for source routing edges

- Update MeshGraphService to track directed announcements
- Require bidirectional announcements for a 'confirmed' edge
- Update RoutePlanner to strictly use confirmed edges
- Update Mesh Topology debug view to show confirmed vs unconfirmed edges (solid vs dotted)

* docs: update SOURCE_ROUTING.md with two-way handshake requirement

* evict stale peers from mesh graph service

* better logging

* fix announce spe

* fix: empty route

* fix spec

* fix: compile error in DebugSettingsSheet and potential NPE in RoutePlanner

* revert

* try again
---
 .../mesh/BluetoothConnectionManager.kt        |  37 +++-
 .../mesh/BluetoothConnectionTracker.kt        |  57 +++++-
 .../mesh/BluetoothGattServerManager.kt        |  30 ++-
 .../android/mesh/BluetoothMeshService.kt      | 108 ++++++++--
 .../mesh/BluetoothPacketBroadcaster.kt        |  72 ++++++-
 .../bitchat/android/mesh/FragmentManager.kt   |  30 ++-
 .../bitchat/android/mesh/MessageHandler.kt    |   7 +
 .../bitchat/android/mesh/PacketProcessor.kt   |   4 +
 .../android/mesh/PacketRelayManager.kt        |  46 ++++-
 .../android/protocol/BinaryProtocol.kt        | 105 ++++++++--
 .../android/services/meshgraph/GossipTLV.kt   |  77 +++++++
 .../services/meshgraph/MeshGraphService.kt    | 123 +++++++++++
 .../services/meshgraph/RoutePlanner.kt        |  68 +++++++
 .../android/ui/debug/DebugSettingsManager.kt  |  20 +-
 .../android/ui/debug/DebugSettingsSheet.kt    | 118 ++++++++++-
 .../android/mesh/FragmentManagerTest.kt       | 191 ++++++++++++++++++
 .../android/mesh/PacketRelayManagerTest.kt    | 117 +++++++++++
 docs/SOURCE_ROUTING.md                        | 174 +++++++++++-----
 18 files changed, 1251 insertions(+), 133 deletions(-)
 create mode 100644 app/src/main/java/com/gap/droid/services/meshgraph/GossipTLV.kt
 create mode 100644 app/src/main/java/com/gap/droid/services/meshgraph/MeshGraphService.kt
 create mode 100644 app/src/main/java/com/gap/droid/services/meshgraph/RoutePlanner.kt
 create mode 100644 app/src/test/java/com/bitchat/android/mesh/FragmentManagerTest.kt
 create mode 100644 app/src/test/kotlin/com/bitchat/android/mesh/PacketRelayManagerTest.kt

diff --git a/app/src/main/java/com/gap/droid/mesh/BluetoothConnectionManager.kt b/app/src/main/java/com/gap/droid/mesh/BluetoothConnectionManager.kt
index 6defd01..f6dc194 100644
--- a/app/src/main/java/com/gap/droid/mesh/BluetoothConnectionManager.kt
+++ b/app/src/main/java/com/gap/droid/mesh/BluetoothConnectionManager.kt
@@ -109,11 +109,19 @@ class BluetoothConnectionManager(
             }
             // Connection caps: enforce on change
             connectionScope.launch {
-                dbg.maxConnectionsOverall.collect {
+                dbg.maxConnectionsOverall.collect { maxOverall ->
                     if (!isActive) return@collect
+                    // 1. Enforce client limits (handled by tracker)
                     connectionTracker.enforceConnectionLimits()
-                    // Also enforce server side best-effort
-                    serverManager.enforceServerLimit(dbg.maxServerConnections.value)
+                    
+                    // 2. Enforce overall limit on server connections if needed
+                    // (Tracker knows about all connections but can't disconnect servers directly)
+                    val maxServer = dbg.maxServerConnections.value
+                    val excessServers = connectionTracker.getExcessServerConnections(maxServer, maxOverall)
+                    excessServers.forEach { device ->
+                        Log.d(TAG, "Disconnecting server ${device.address} due to overall cap")
+                        serverManager.disconnectDevice(device)
+                    }
                 }
             }
             connectionScope.launch {
@@ -123,9 +131,18 @@ class BluetoothConnectionManager(
                 }
             }
             connectionScope.launch {
-                dbg.maxServerConnections.collect {
+                dbg.maxServerConnections.collect { maxServer ->
                     if (!isActive) return@collect
-                    serverManager.enforceServerLimit(dbg.maxServerConnections.value)
+                    // Enforce server specific limit
+                    serverManager.enforceServerLimit(maxServer)
+                    
+                    // Also check if this change puts us over the overall limit
+                    val maxOverall = dbg.maxConnectionsOverall.value
+                    val excessServers = connectionTracker.getExcessServerConnections(maxServer, maxOverall)
+                    excessServers.forEach { device ->
+                        Log.d(TAG, "Disconnecting server ${device.address} due to overall cap")
+                        serverManager.disconnectDevice(device)
+                    }
                 }
             }
         } catch (_: Exception) { }
@@ -261,6 +278,16 @@ class BluetoothConnectionManager(
         )
     }
 
+    fun sendToPeer(peerID: String, routed: RoutedPacket): Boolean {
+        if (!isActive) return false
+        return packetBroadcaster.sendToPeer(
+            peerID,
+            routed,
+            serverManager.getGattServer(),
+            serverManager.getCharacteristic()
+        )
+    }
+
     fun cancelTransfer(transferId: String): Boolean {
         return packetBroadcaster.cancelTransfer(transferId)
     }
diff --git a/app/src/main/java/com/gap/droid/mesh/BluetoothConnectionTracker.kt b/app/src/main/java/com/gap/droid/mesh/BluetoothConnectionTracker.kt
index 7029185..85e5f45 100644
--- a/app/src/main/java/com/gap/droid/mesh/BluetoothConnectionTracker.kt
+++ b/app/src/main/java/com/gap/droid/mesh/BluetoothConnectionTracker.kt
@@ -229,11 +229,17 @@ class BluetoothConnectionTracker(
      */
     fun getConnectedDeviceCount(): Int = connectedDevices.size
     
+    /**
+     * Check if connection limit is reached
+     */
     /**
      * Check if connection limit is reached
      */
     fun isConnectionLimitReached(): Boolean {
-        return connectedDevices.size >= powerManager.getMaxConnections()
+        // Respect debug override if set
+        val dbg = try { com.gap.droid.ui.debug.DebugSettingsManager.getInstance() } catch (_: Exception) { null }
+        val maxConnections = dbg?.maxConnectionsOverall?.value ?: powerManager.getMaxConnections()
+        return connectedDevices.size >= maxConnections
     }
     
     /**
@@ -244,10 +250,9 @@ class BluetoothConnectionTracker(
         val dbg = try { com.gap.droid.ui.debug.DebugSettingsManager.getInstance() } catch (_: Exception) { null }
         val maxOverall = dbg?.maxConnectionsOverall?.value ?: powerManager.getMaxConnections()
         val maxClient = dbg?.maxClientConnections?.value ?: maxOverall
-        val maxServer = dbg?.maxServerConnections?.value ?: maxOverall
+        // Note: maxServer is handled by GattServerManager, but we need to respect overall limit here too
 
         val clients = connectedDevices.values.filter { it.isClient }
-        val servers = connectedDevices.values.filter { !it.isClient }
 
         // Enforce client cap first (we can actively disconnect)
         if (clients.size > maxClient) {
@@ -259,22 +264,56 @@ class BluetoothConnectionTracker(
             }
         }
 
-        // Note: server cap enforced in GattServerManager (we don't have server handle here)
-
-        // Enforce overall cap by disconnecting oldest client connections
+        // Re-check overall cap after client cleanup
         if (connectedDevices.size > maxOverall) {
             Log.i(TAG, "Enforcing overall cap: ${connectedDevices.size} > $maxOverall")
             val excess = connectedDevices.size - maxOverall
-            val toDisconnect = connectedDevices.values
-                .filter { it.isClient } // only clients from here
+            
+            // Prefer disconnecting clients first to satisfy overall cap
+            val clientsToDisconnect = connectedDevices.values
+                .filter { it.isClient }
                 .sortedBy { it.connectedAt }
                 .take(excess)
-            toDisconnect.forEach { dc ->
+                
+            clientsToDisconnect.forEach { dc ->
                 Log.d(TAG, "Disconnecting client ${dc.device.address} due to overall cap")
                 dc.gatt?.disconnect()
             }
         }
     }
+
+    /**
+     * Get excess server connections that should be disconnected to satisfy limits.
+     * This allows the Manager to coordinate server disconnects since Tracker doesn't control the server.
+     */
+    fun getExcessServerConnections(maxServer: Int, maxOverall: Int): List<BluetoothDevice> {
+        val servers = connectedDevices.values.filter { !it.isClient }
+        val excessList = mutableListOf<BluetoothDevice>()
+
+        // 1. Check server specific limit
+        if (servers.size > maxServer) {
+            val excessCount = servers.size - maxServer
+            val toRemove = servers.sortedBy { it.connectedAt }.take(excessCount)
+            excessList.addAll(toRemove.map { it.device })
+        }
+
+        // 2. Check overall limit (considering we might have already removed some above)
+        // We need to count how many connections we will have after the above removals
+        val currentTotal = connectedDevices.size
+        val plannedRemovals = excessList.size
+        val projectedTotal = currentTotal - plannedRemovals
+        
+        if (projectedTotal > maxOverall) {
+            val furtherExcess = projectedTotal - maxOverall
+            // We can only remove servers here. Clients are handled in enforceConnectionLimits.
+            // Filter out devices we already planned to remove
+            val remainingServers = servers.filter { s -> excessList.none { it.address == s.device.address } }
+            val toRemove = remainingServers.sortedBy { it.connectedAt }.take(furtherExcess)
+            excessList.addAll(toRemove.map { it.device })
+        }
+
+        return excessList
+    }
     
     /**
      * Clean up a specific device connection
diff --git a/app/src/main/java/com/gap/droid/mesh/BluetoothGattServerManager.kt b/app/src/main/java/com/gap/droid/mesh/BluetoothGattServerManager.kt
index 6a1c6fb..e06fd00 100644
--- a/app/src/main/java/com/gap/droid/mesh/BluetoothGattServerManager.kt
+++ b/app/src/main/java/com/gap/droid/mesh/BluetoothGattServerManager.kt
@@ -49,15 +49,28 @@ class BluetoothGattServerManager(
     fun enforceServerLimit(maxServer: Int) {
         if (maxServer <= 0) return
         try {
-            val subs = connectionTracker.getSubscribedDevices()
-            if (subs.size > maxServer) {
-                val excess = subs.size - maxServer
-                subs.take(excess).forEach { d ->
-                    try { gattServer?.cancelConnection(d) } catch (_: Exception) { }
+            // Use connection tracker to get actual connected server devices
+            val servers = connectionTracker.getConnectedDevices().values.filter { !it.isClient }
+            if (servers.size > maxServer) {
+                val excess = servers.size - maxServer
+                // Disconnect oldest
+                servers.sortedBy { it.connectedAt }.take(excess).forEach { d ->
+                    try { gattServer?.cancelConnection(d.device) } catch (_: Exception) { }
                 }
             }
         } catch (_: Exception) { }
     }
+
+    /**
+     * Disconnect a specific device (used by ConnectionManager to enforce overall limits)
+     */
+    fun disconnectDevice(device: BluetoothDevice) {
+        try {
+            gattServer?.cancelConnection(device)
+        } catch (e: Exception) {
+            Log.w(TAG, "Error disconnecting device ${device.address}: ${e.message}")
+        }
+    }
     
     /**
      * Start GATT server
@@ -122,9 +135,10 @@ class BluetoothGattServerManager(
             
             // Try to cancel any active connections explicitly before closing
             try {
-                val devices = connectionTracker.getSubscribedDevices()
-                devices.forEach { d ->
-                    try { gattServer?.cancelConnection(d) } catch (_: Exception) { }
+                // Disconnect ALL server connections
+                val servers = connectionTracker.getConnectedDevices().values.filter { !it.isClient }
+                servers.forEach { d ->
+                    try { gattServer?.cancelConnection(d.device) } catch (_: Exception) { }
                 }
             } catch (_: Exception) { }
             
diff --git a/app/src/main/java/com/gap/droid/mesh/BluetoothMeshService.kt b/app/src/main/java/com/gap/droid/mesh/BluetoothMeshService.kt
index 91f8891..6adb55f 100644
--- a/app/src/main/java/com/gap/droid/mesh/BluetoothMeshService.kt
+++ b/app/src/main/java/com/gap/droid/mesh/BluetoothMeshService.kt
@@ -172,6 +172,9 @@ class BluetoothMeshService(private val context: Context) {
             }
             override fun onPeerRemoved(peerID: String) {
                 try { gossipSyncManager.removeAnnouncementForPeer(peerID) } catch (_: Exception) { }
+                // Remove from mesh graph topology to prevent routing through stale peers
+                try { com.gap.droid.services.meshgraph.MeshGraphService.getInstance().removePeer(peerID) } catch (_: Exception) { }
+
                 // Also drop any Noise session state for this peer when they go offline
                 try {
                     encryptionService.removePeer(peerID)
@@ -526,6 +529,10 @@ class BluetoothMeshService(private val context: Context) {
                 connectionManager.broadcastPacket(routed)
             }
 
+            override fun sendToPeer(peerID: String, routed: RoutedPacket): Boolean {
+                return connectionManager.sendToPeer(peerID, routed)
+            }
+            
             override fun handleRequestSync(routed: RoutedPacket) {
                 // Decode request and respond with missing packets
                 val fromPeer = routed.peerID ?: return
@@ -536,19 +543,23 @@ class BluetoothMeshService(private val context: Context) {
         
         // BluetoothConnectionManager delegates
         connectionManager.delegate = object : BluetoothConnectionManagerDelegate {
-            override fun onPacketReceived(packet: BitchatPacket, peerID: String, device: android.bluetooth.BluetoothDevice?) {
-                // Log incoming for debug graphs (do not double-count anywhere else)
-                try {
-                    val nick = getPeerNicknames()[peerID]
-                    com.gap.droid.ui.debug.DebugSettingsManager.getInstance().logIncoming(
-                        packetType = packet.type.toString(),
-                        fromPeerID = peerID,
-                        fromNickname = nick,
-                        fromDeviceAddress = device?.address
-                    )
-                } catch (_: Exception) { }
-                packetProcessor.processPacket(RoutedPacket(packet, peerID, device?.address))
-            }
+        override fun onPacketReceived(packet: BitchatPacket, peerID: String, device: android.bluetooth.BluetoothDevice?) {
+            // Log incoming for debug graphs (do not double-count anywhere else)
+            try {
+                val nick = getPeerNicknames()[peerID]
+                val route = packet.route
+                val routeInfo = if (!route.isNullOrEmpty()) "routed: ${route.size} hops" else null
+                com.gap.droid.ui.debug.DebugSettingsManager.getInstance().logIncoming(
+                    packetType = packet.type.toString(),
+                    fromPeerID = peerID,
+                    fromNickname = nick,
+                    fromDeviceAddress = device?.address,
+                    packetVersion = packet.version,
+                    routeInfo = routeInfo
+                )
+            } catch (_: Exception) { }
+            packetProcessor.processPacket(RoutedPacket(packet, peerID, device?.address))
+        }
             
             override fun onDeviceConnected(device: android.bluetooth.BluetoothDevice) {
                 // Send initial announcements after services are ready
@@ -1020,11 +1031,25 @@ class BluetoothMeshService(private val context: Context) {
             
             // Create iOS-compatible IdentityAnnouncement with TLV encoding
             val announcement = IdentityAnnouncement(nickname, staticKey, signingKey)
-            val tlvPayload = announcement.encode()
+            var tlvPayload = announcement.encode()
             if (tlvPayload == null) {
                 Log.e(TAG, "Failed to encode announcement as TLV")
                 return@launch
             }
+
+            // Append gossip TLV containing up to 10 direct neighbors (compact IDs)
+            try {
+                val directPeers = getDirectPeerIDsForGossip()
+                if (directPeers.isNotEmpty()) {
+                    val gossip = com.gap.droid.services.meshgraph.GossipTLV.encodeNeighbors(directPeers)
+                    tlvPayload = tlvPayload + gossip
+                }
+                // Always update our own node in the mesh graph with the neighbor list we used
+                try {
+                    com.gap.droid.services.meshgraph.MeshGraphService.getInstance()
+                        .updateFromAnnouncement(myPeerID, nickname, directPeers, System.currentTimeMillis().toULong())
+                } catch (_: Exception) { }
+            } catch (_: Exception) { }
             
             val announcePacket = BitchatPacket(
                 type = MessageType.ANNOUNCE.value,
@@ -1069,11 +1094,25 @@ class BluetoothMeshService(private val context: Context) {
         
         // Create iOS-compatible IdentityAnnouncement with TLV encoding
         val announcement = IdentityAnnouncement(nickname, staticKey, signingKey)
-        val tlvPayload = announcement.encode()
+        var tlvPayload = announcement.encode()
         if (tlvPayload == null) {
             Log.e(TAG, "Failed to encode peer announcement as TLV")
             return
         }
+
+        // Append gossip TLV containing up to 10 direct neighbors (compact IDs)
+        try {
+            val directPeers = getDirectPeerIDsForGossip()
+            if (directPeers.isNotEmpty()) {
+                val gossip = com.gap.droid.services.meshgraph.GossipTLV.encodeNeighbors(directPeers)
+                tlvPayload = tlvPayload + gossip
+            }
+            // Always update our own node in the mesh graph with the neighbor list we used
+            try {
+                com.gap.droid.services.meshgraph.MeshGraphService.getInstance()
+                    .updateFromAnnouncement(myPeerID, nickname, directPeers, System.currentTimeMillis().toULong())
+            } catch (_: Exception) { }
+        } catch (_: Exception) { }
         
         val packet = BitchatPacket(
             type = MessageType.ANNOUNCE.value,
@@ -1095,6 +1134,20 @@ class BluetoothMeshService(private val context: Context) {
         try { gossipSyncManager.onPublicPacketSeen(signedPacket) } catch (_: Exception) { }
     }
 
+    /**
+     * Collect up to 10 direct neighbors for gossip TLV.
+     */
+    private fun getDirectPeerIDsForGossip(): List<String> {
+        return try {
+            // Prefer verified peers that are currently marked as direct
+            val verified = peerManager.getVerifiedPeers()
+            val direct = verified.filter { it.value.isDirectConnection }.keys.toList()
+            direct.take(10)
+        } catch (_: Exception) {
+            emptyList()
+        }
+    }
+
     /**
      * Send leave announcement
      */
@@ -1277,21 +1330,38 @@ class BluetoothMeshService(private val context: Context) {
      */
     private fun signPacketBeforeBroadcast(packet: BitchatPacket): BitchatPacket {
         return try {
+            // Optionally compute and attach a source route for addressed packets
+            val withRoute = try {
+                val rec = packet.recipientID
+                if (rec != null && !rec.contentEquals(SpecialRecipients.BROADCAST)) {
+                    val dest = rec.joinToString("") { b -> "%02x".format(b) }
+                    val path = com.gap.droid.services.meshgraph.RoutePlanner.shortestPath(myPeerID, dest)
+                    if (path != null && path.size >= 3) {
+                        // Exclude first (sender) and last (recipient); only intermediates
+                        val intermediates = path.subList(1, path.size - 1)
+                        val hopsBytes = intermediates.map { hexStringToByteArray(it) }
+                        Log.d(TAG, "âœ… Signed packet type ${packet.type} (route ${hopsBytes.size} hops: $intermediates)")
+                        // Attach route and upgrade to v2 (required for HAS_ROUTE flag)
+                        packet.copy(route = hopsBytes, version = 2u)
+                    } else packet.copy(route = null)
+                } else packet
+            } catch (_: Exception) { packet }
+
             // Get the canonical packet data for signing (without signature)
-            val packetDataForSigning = packet.toBinaryDataForSigning()
+            val packetDataForSigning = withRoute.toBinaryDataForSigning()
             if (packetDataForSigning == null) {
                 Log.w(TAG, "Failed to encode packet type ${packet.type} for signing, sending unsigned")
-                return packet
+                return withRoute
             }
             
             // Sign the packet data using our signing key
             val signature = encryptionService.signData(packetDataForSigning)
             if (signature != null) {
                 Log.d(TAG, "âœ… Signed packet type ${packet.type} (signature ${signature.size} bytes)")
-                packet.copy(signature = signature)
+                withRoute.copy(signature = signature)
             } else {
                 Log.w(TAG, "Failed to sign packet type ${packet.type}, sending unsigned")
-                packet
+                withRoute
             }
         } catch (e: Exception) {
             Log.w(TAG, "Error signing packet type ${packet.type}: ${e.message}, sending unsigned")
diff --git a/app/src/main/java/com/gap/droid/mesh/BluetoothPacketBroadcaster.kt b/app/src/main/java/com/gap/droid/mesh/BluetoothPacketBroadcaster.kt
index 04e5d75..c003afc 100644
--- a/app/src/main/java/com/gap/droid/mesh/BluetoothPacketBroadcaster.kt
+++ b/app/src/main/java/com/gap/droid/mesh/BluetoothPacketBroadcaster.kt
@@ -68,7 +68,9 @@ class BluetoothPacketBroadcaster(
         incomingAddr: String?,
         toPeer: String?,
         toDeviceAddress: String,
-        ttl: UByte
+        ttl: UByte,
+        packetVersion: UByte = 1u,
+        routeInfo: String? = null
     ) {
         try {
             val fromNick = incomingPeer?.let { nicknameResolver?.invoke(it) }
@@ -80,7 +82,9 @@ class BluetoothPacketBroadcaster(
                 toPeerID = toPeer,
                 toNickname = toNick,
                 toDeviceAddress = toDeviceAddress,
-                previousHopPeerID = incomingPeer
+                previousHopPeerID = incomingPeer,
+                packetVersion = packetVersion,
+                routeInfo = routeInfo
             )
             // Keep the verbose relay message for human readability
             manager.logPacketRelayDetailed(
@@ -94,7 +98,9 @@ class BluetoothPacketBroadcaster(
                 toNickname = toNick,
                 toDeviceAddress = toDeviceAddress,
                 ttl = ttl,
-                isRelay = true
+                isRelay = true,
+                packetVersion = packetVersion,
+                routeInfo = routeInfo
             )
         } catch (_: Exception) { 
             // Silently ignore debug logging failures
@@ -221,17 +227,19 @@ class BluetoothPacketBroadcaster(
             TransferProgressManager.start(transferId, 1)
         }
         val typeName = MessageType.fromValue(packet.type)?.name ?: packet.type.toString()
+        val senderPeerID = routed.peerID ?: packet.senderID.toHexString()
         val incomingAddr = routed.relayAddress
         val incomingPeer = incomingAddr?.let { connectionTracker.addressPeerMap[it] }
-        val senderPeerID = routed.peerID ?: packet.senderID.toHexString()
         val senderNick = senderPeerID.let { pid -> nicknameResolver?.invoke(pid) }
+        val route = packet.route
+        val routeInfo = if (!route.isNullOrEmpty()) "routed: ${route.size} hops" else null
 
         // Prefer server-side subscriptions
         val serverTarget = connectionTracker.getSubscribedDevices()
             .firstOrNull { connectionTracker.addressPeerMap[it.address] == targetPeerID }
         if (serverTarget != null) {
             if (notifyDevice(serverTarget, data, gattServer, characteristic)) {
-                logPacketRelay(typeName, senderPeerID, senderNick, incomingPeer, incomingAddr, targetPeerID, serverTarget.address, packet.ttl)
+                logPacketRelay(typeName, senderPeerID, senderNick, incomingPeer, incomingAddr, targetPeerID, serverTarget.address, packet.ttl, packet.version, routeInfo)
                 if (transferId != null) {
                     TransferProgressManager.progress(transferId, 1, 1)
                     TransferProgressManager.complete(transferId, 1)
@@ -245,7 +253,7 @@ class BluetoothPacketBroadcaster(
             .firstOrNull { connectionTracker.addressPeerMap[it.device.address] == targetPeerID }
         if (clientTarget != null) {
             if (writeToDeviceConn(clientTarget, data)) {
-                logPacketRelay(typeName, senderPeerID, senderNick, incomingPeer, incomingAddr, targetPeerID, clientTarget.device.address, packet.ttl)
+                logPacketRelay(typeName, senderPeerID, senderNick, incomingPeer, incomingAddr, targetPeerID, clientTarget.device.address, packet.ttl, packet.version, routeInfo)
                 if (transferId != null) {
                     TransferProgressManager.progress(transferId, 1, 1)
                     TransferProgressManager.complete(transferId, 1)
@@ -283,6 +291,46 @@ class BluetoothPacketBroadcaster(
             }
         }
     }
+
+    /**
+     * Targeted send to a specific peer (by peerID) if directly connected.
+     * Returns true if sent to at least one matching connection.
+     */
+    fun sendToPeer(
+        targetPeerID: String,
+        routed: RoutedPacket,
+        gattServer: BluetoothGattServer?,
+        characteristic: BluetoothGattCharacteristic?
+    ): Boolean {
+        val packet = routed.packet
+        val data = packet.toBinaryData() ?: return false
+        val typeName = MessageType.fromValue(packet.type)?.name ?: packet.type.toString()
+        val senderPeerID = routed.peerID ?: packet.senderID.toHexString()
+        val incomingAddr = routed.relayAddress
+        val incomingPeer = incomingAddr?.let { connectionTracker.addressPeerMap[it] }
+        val senderNick = senderPeerID.let { pid -> nicknameResolver?.invoke(pid) }
+
+        // Try server-side connections first
+        val targetDevice = connectionTracker.getSubscribedDevices()
+            .firstOrNull { connectionTracker.addressPeerMap[it.address] == targetPeerID }
+        if (targetDevice != null) {
+            if (notifyDevice(targetDevice, data, gattServer, characteristic)) {
+                logPacketRelay(typeName, senderPeerID, senderNick, incomingPeer, incomingAddr, targetPeerID, targetDevice.address, packet.ttl)
+                return true
+            }
+        }
+
+        // Try client-side connections next
+        val targetConn = connectionTracker.getConnectedDevices().values
+            .firstOrNull { connectionTracker.addressPeerMap[it.device.address] == targetPeerID }
+        if (targetConn != null) {
+            if (writeToDeviceConn(targetConn, data)) {
+                logPacketRelay(typeName, senderPeerID, senderNick, incomingPeer, incomingAddr, targetPeerID, targetConn.device.address, packet.ttl)
+                return true
+            }
+        }
+        return false
+    }
     
     /**
      * Internal broadcast implementation - runs in serialized actor context
@@ -299,6 +347,8 @@ class BluetoothPacketBroadcaster(
         val incomingAddr = routed.relayAddress
         val incomingPeer = incomingAddr?.let { connectionTracker.addressPeerMap[it] }
         val senderNick = senderPeerID.let { pid -> nicknameResolver?.invoke(pid) }
+        val route = packet.route
+        val routeInfo = if (!route.isNullOrEmpty()) "routed: ${route.size} hops" else null
         
         if (packet.recipientID != SpecialRecipients.BROADCAST) {
             val recipientID = packet.recipientID?.let {
@@ -314,7 +364,7 @@ class BluetoothPacketBroadcaster(
                 Log.d(TAG, "Send packet type ${packet.type} directly to target device for recipient $recipientID: ${targetDevice.address}")
                 if (notifyDevice(targetDevice, data, gattServer, characteristic)) {
                     val toPeer = connectionTracker.addressPeerMap[targetDevice.address]
-                    logPacketRelay(typeName, senderPeerID, senderNick, incomingPeer, incomingAddr, toPeer, targetDevice.address, packet.ttl)
+                    logPacketRelay(typeName, senderPeerID, senderNick, incomingPeer, incomingAddr, toPeer, targetDevice.address, packet.ttl, packet.version, routeInfo)
                     return  // Sent, no need to continue
                 }
             }
@@ -328,7 +378,7 @@ class BluetoothPacketBroadcaster(
                 Log.d(TAG, "Send packet type ${packet.type} directly to target client connection for recipient $recipientID: ${targetDeviceConn.device.address}")
                 if (writeToDeviceConn(targetDeviceConn, data)) {
                     val toPeer = connectionTracker.addressPeerMap[targetDeviceConn.device.address]
-                    logPacketRelay(typeName, senderPeerID, senderNick, incomingPeer, incomingAddr, toPeer, targetDeviceConn.device.address, packet.ttl)
+                    logPacketRelay(typeName, senderPeerID, senderNick, incomingPeer, incomingAddr, toPeer, targetDeviceConn.device.address, packet.ttl, packet.version, routeInfo)
                     return  // Sent, no need to continue
                 }
             }
@@ -338,7 +388,7 @@ class BluetoothPacketBroadcaster(
         val subscribedDevices = connectionTracker.getSubscribedDevices()
         val connectedDevices = connectionTracker.getConnectedDevices()
         
-        Log.i(TAG, "Broadcasting packet type ${packet.type} to ${subscribedDevices.size} server + ${connectedDevices.size} client connections")
+        Log.i(TAG, "Broadcasting packet v${packet.version} type ${packet.type} to ${subscribedDevices.size} server + ${connectedDevices.size} client connections")
 
         val senderID = String(packet.senderID).replace("\u0000", "")        
         
@@ -355,7 +405,7 @@ class BluetoothPacketBroadcaster(
             val sent = notifyDevice(device, data, gattServer, characteristic)
             if (sent) {
                 val toPeer = connectionTracker.addressPeerMap[device.address]
-                logPacketRelay(typeName, senderPeerID, senderNick, incomingPeer, incomingAddr, toPeer, device.address, packet.ttl)
+                logPacketRelay(typeName, senderPeerID, senderNick, incomingPeer, incomingAddr, toPeer, device.address, packet.ttl, packet.version, routeInfo)
             }
         }
         
@@ -373,7 +423,7 @@ class BluetoothPacketBroadcaster(
                 val sent = writeToDeviceConn(deviceConn, data)
                 if (sent) {
                     val toPeer = connectionTracker.addressPeerMap[deviceConn.device.address]
-                    logPacketRelay(typeName, senderPeerID, senderNick, incomingPeer, incomingAddr, toPeer, deviceConn.device.address, packet.ttl)
+                    logPacketRelay(typeName, senderPeerID, senderNick, incomingPeer, incomingAddr, toPeer, deviceConn.device.address, packet.ttl, packet.version, routeInfo)
                 }
             }
         }
diff --git a/app/src/main/java/com/gap/droid/mesh/FragmentManager.kt b/app/src/main/java/com/gap/droid/mesh/FragmentManager.kt
index 16f6844..d9120a8 100644
--- a/app/src/main/java/com/gap/droid/mesh/FragmentManager.kt
+++ b/app/src/main/java/com/gap/droid/mesh/FragmentManager.kt
@@ -77,8 +77,31 @@ class FragmentManager {
         val fragmentID = FragmentPayload.generateFragmentID()
         
         // iOS: stride(from: 0, to: fullData.count, by: maxFragmentSize)
-        val fragmentChunks = stride(0, fullData.size, MAX_FRAGMENT_SIZE) { offset ->
-            val endOffset = minOf(offset + MAX_FRAGMENT_SIZE, fullData.size)
+        // Calculate dynamic fragment size to fit in MTU (512)
+        // Packet = Header + Sender + Recipient + Route + FragmentHeader + Payload + PaddingBuffer
+        val hasRoute = packet.route != null
+        val version = if (hasRoute) 2 else 1
+        val headerSize = if (version == 2) 15 else 13
+        val senderSize = 8
+        val recipientSize = if (packet.recipientID != null) 8 else 0
+        // Route: 1 byte count + 8 bytes per hop
+        val routeSize = if (hasRoute) (1 + (packet.route?.size ?: 0) * 8) else 0
+        val fragmentHeaderSize = 13 // FragmentPayload header
+        val paddingBuffer = 16 // MessagePadding.optimalBlockSize adds 16 bytes overhead
+
+        // 512 - Overhead
+        val packetOverhead = headerSize + senderSize + recipientSize + routeSize + fragmentHeaderSize + paddingBuffer
+        val maxDataSize = (512 - packetOverhead).coerceAtMost(MAX_FRAGMENT_SIZE)
+        
+        if (maxDataSize <= 0) {
+            Log.e(TAG, "âŒ Calculated maxDataSize is non-positive ($maxDataSize). Route too large?")
+            return emptyList()
+        }
+
+        Log.d(TAG, "ðŸ“ Dynamic fragment size: $maxDataSize (MAX: $MAX_FRAGMENT_SIZE, Overhead: $packetOverhead)")
+
+        val fragmentChunks = stride(0, fullData.size, maxDataSize) { offset ->
+            val endOffset = minOf(offset + maxDataSize, fullData.size)
             fullData.sliceArray(offset..<endOffset)
         }
         
@@ -98,13 +121,16 @@ class FragmentManager {
             )
             
             // iOS: MessageType.fragment.rawValue (single fragment type)
+            // Fix: Fragments must inherit source route and use v2 if routed
             val fragmentPacket = BitchatPacket(
+                version = if (packet.route != null) 2u else 1u,
                 type = MessageType.FRAGMENT.value,
                 ttl = packet.ttl,
                 senderID = packet.senderID,
                 recipientID = packet.recipientID,
                 timestamp = packet.timestamp,
                 payload = fragmentPayload.encode(),
+                route = packet.route,
                 signature = null // iOS: signature: nil
             )
             
diff --git a/app/src/main/java/com/gap/droid/mesh/MessageHandler.kt b/app/src/main/java/com/gap/droid/mesh/MessageHandler.kt
index ce8b0d9..63081d7 100644
--- a/app/src/main/java/com/gap/droid/mesh/MessageHandler.kt
+++ b/app/src/main/java/com/gap/droid/mesh/MessageHandler.kt
@@ -286,6 +286,13 @@ class MessageHandler(private val myPeerID: String, private val appContext: andro
             previousPeerID = null
         )
         
+        // Update mesh graph from gossip neighbors (only if TLV present)
+        try {
+            val neighborsOrNull = com.gap.droid.services.meshgraph.GossipTLV.decodeNeighborsFromAnnouncementPayload(packet.payload)
+            com.gap.droid.services.meshgraph.MeshGraphService.getInstance()
+                .updateFromAnnouncement(peerID, nickname, neighborsOrNull, packet.timestamp)
+        } catch (_: Exception) { }
+
         Log.d(TAG, "âœ… Processed verified TLV announce: stored identity for $peerID")
         return isFirstAnnounce
     }
diff --git a/app/src/main/java/com/gap/droid/mesh/PacketProcessor.kt b/app/src/main/java/com/gap/droid/mesh/PacketProcessor.kt
index 2b5fac1..54d006b 100644
--- a/app/src/main/java/com/gap/droid/mesh/PacketProcessor.kt
+++ b/app/src/main/java/com/gap/droid/mesh/PacketProcessor.kt
@@ -112,6 +112,9 @@ class PacketProcessor(private val myPeerID: String) {
             override fun broadcastPacket(routed: RoutedPacket) {
                 delegate?.relayPacket(routed)
             }
+            override fun sendToPeer(peerID: String, routed: RoutedPacket): Boolean {
+                return delegate?.sendToPeer(peerID, routed) ?: false
+            }
         }
     }
     
@@ -323,4 +326,5 @@ interface PacketProcessorDelegate {
     fun sendAnnouncementToPeer(peerID: String)
     fun sendCachedMessages(peerID: String)
     fun relayPacket(routed: RoutedPacket)
+    fun sendToPeer(peerID: String, routed: RoutedPacket): Boolean
 }
diff --git a/app/src/main/java/com/gap/droid/mesh/PacketRelayManager.kt b/app/src/main/java/com/gap/droid/mesh/PacketRelayManager.kt
index bc401da..a82746c 100644
--- a/app/src/main/java/com/gap/droid/mesh/PacketRelayManager.kt
+++ b/app/src/main/java/com/gap/droid/mesh/PacketRelayManager.kt
@@ -65,9 +65,40 @@ class PacketRelayManager(private val myPeerID: String) {
         val relayPacket = packet.copy(ttl = (packet.ttl - 1u).toUByte())
         Log.d(TAG, "Decremented TTL from ${packet.ttl} to ${relayPacket.ttl}")
         
+        // Source-based routing: if route is set and includes us, try targeted next-hop forwarding
+        val route = relayPacket.route
+        if (!route.isNullOrEmpty()) {
+            // Check for duplicate hops to prevent routing loops
+            if (route.map { it.toHexString() }.toSet().size < route.size) {
+                Log.w(TAG, "Packet with duplicate hops dropped")
+                return
+            }
+            val myIdBytes = hexStringToPeerBytes(myPeerID)
+            val index = route.indexOfFirst { it.contentEquals(myIdBytes) }
+            if (index >= 0) {
+                val nextHopIdHex: String? = run {
+                    val nextIndex = index + 1
+                    if (nextIndex < route.size) {
+                        route[nextIndex].toHexString()
+                    } else {
+                        // We are the last intermediate; try final recipient as next hop
+                        relayPacket.recipientID?.toHexString()
+                    }
+                }
+                if (nextHopIdHex != null) {
+                    val success = try { delegate?.sendToPeer(nextHopIdHex, RoutedPacket(relayPacket, peerID, routed.relayAddress)) } catch (_: Exception) { false } ?: false
+                    if (success) {
+                        Log.i(TAG, "ðŸ“¦ Source-route relay: ${peerID.take(8)} -> ${nextHopIdHex.take(8)} (type ${'$'}{packet.type}, TTL ${'$'}{relayPacket.ttl})")
+                        return
+                    } else {
+                        Log.w(TAG, "Source-route next hop ${nextHopIdHex.take(8)} not directly connected; falling back to broadcast")
+                    }
+                }
+            }
+        }
+
         // Apply relay logic based on packet type and debug switch
         val shouldRelay = isRelayEnabled() && shouldRelayPacket(relayPacket, peerID)
-        
         if (shouldRelay) {
             relayPacket(RoutedPacket(relayPacket, peerID, routed.relayAddress))
         } else {
@@ -170,4 +201,17 @@ interface PacketRelayManagerDelegate {
     
     // Packet operations
     fun broadcastPacket(routed: RoutedPacket)
+    fun sendToPeer(peerID: String, routed: RoutedPacket): Boolean
+}
+
+private fun hexStringToPeerBytes(hex: String): ByteArray {
+    val result = ByteArray(8)
+    var idx = 0
+    var out = 0
+    while (idx + 1 < hex.length && out < 8) {
+        val b = hex.substring(idx, idx + 2).toIntOrNull(16)?.toByte() ?: 0
+        result[out++] = b
+        idx += 2
+    }
+    return result
 }
diff --git a/app/src/main/java/com/gap/droid/protocol/BinaryProtocol.kt b/app/src/main/java/com/gap/droid/protocol/BinaryProtocol.kt
index 2d15b86..31189a3 100644
--- a/app/src/main/java/com/gap/droid/protocol/BinaryProtocol.kt
+++ b/app/src/main/java/com/gap/droid/protocol/BinaryProtocol.kt
@@ -59,7 +59,8 @@ data class BitchatPacket(
     val timestamp: ULong,
     val payload: ByteArray,
     var signature: ByteArray? = null,  // Changed from val to var for packet signing
-    var ttl: UByte
+    var ttl: UByte,
+    var route: List<ByteArray>? = null // Optional source route: ordered list of peerIDs (8 bytes each), not including sender and final recipient
 ) : Parcelable {
 
     constructor(
@@ -97,6 +98,7 @@ data class BitchatPacket(
             timestamp = timestamp,
             payload = payload,
             signature = null, // Remove signature for signing
+            route = route,
             ttl = com.gap.droid.util.AppConstants.SYNC_TTL_HOPS // Use fixed TTL=0 for signing to ensure relay compatibility
         )
         return BinaryProtocol.encode(unsignedPacket)
@@ -149,6 +151,11 @@ data class BitchatPacket(
             if (!signature.contentEquals(other.signature)) return false
         } else if (other.signature != null) return false
         if (ttl != other.ttl) return false
+        if (route != null || other.route != null) {
+            val a = route?.map { it.toList() } ?: emptyList()
+            val b = other.route?.map { it.toList() } ?: emptyList()
+            if (a != b) return false
+        }
 
         return true
     }
@@ -162,6 +169,7 @@ data class BitchatPacket(
         result = 31 * result + payload.contentHashCode()
         result = 31 * result + (signature?.contentHashCode() ?: 0)
         result = 31 * result + ttl.hashCode()
+        result = 31 * result + (route?.fold(1) { acc, bytes -> 31 * acc + bytes.contentHashCode() } ?: 0)
         return result
     }
 }
@@ -180,6 +188,7 @@ object BinaryProtocol {
         const val HAS_RECIPIENT: UByte = 0x01u
         const val HAS_SIGNATURE: UByte = 0x02u
         const val IS_COMPRESSED: UByte = 0x04u
+        const val HAS_ROUTE: UByte = 0x08u
     }
 
     private fun getHeaderSize(version: UByte): Int {
@@ -193,12 +202,12 @@ object BinaryProtocol {
         try {
             // Try to compress payload if beneficial
             var payload = packet.payload
-            var originalPayloadSize: UShort? = null
+            var originalPayloadSize: Int? = null
             var isCompressed = false
             
             if (CompressionUtil.shouldCompress(payload)) {
                 CompressionUtil.compress(payload)?.let { compressedPayload ->
-                    originalPayloadSize = payload.size.toUShort()
+                    originalPayloadSize = payload.size
                     payload = compressedPayload
                     isCompressed = true
                 }
@@ -208,8 +217,12 @@ object BinaryProtocol {
             val headerSize = getHeaderSize(packet.version)
             val recipientBytes = if (packet.recipientID != null) RECIPIENT_ID_SIZE else 0
             val signatureBytes = if (packet.signature != null) SIGNATURE_SIZE else 0
-            val payloadBytes = payload.size + if (isCompressed) 2 else 0
-            val capacity = headerSize + SENDER_ID_SIZE + recipientBytes + payloadBytes + signatureBytes + 16 // small slack
+            val sizeFieldBytes = if (isCompressed) (if (packet.version >= 2u.toUByte()) 4 else 2) else 0
+            val payloadBytes = payload.size + sizeFieldBytes
+            val routeBytes = if (!packet.route.isNullOrEmpty() && packet.version >= 2u.toUByte()) {
+                1 + (packet.route!!.size.coerceAtMost(255) * SENDER_ID_SIZE)
+            } else 0
+            val capacity = headerSize + SENDER_ID_SIZE + recipientBytes + payloadBytes + signatureBytes + routeBytes + 16 // small slack
             val buffer = ByteBuffer.allocate(capacity.coerceAtLeast(512)).apply { order(ByteOrder.BIG_ENDIAN) }
             
             // Header
@@ -231,10 +244,14 @@ object BinaryProtocol {
             if (isCompressed) {
                 flags = flags or Flags.IS_COMPRESSED
             }
+            // HAS_ROUTE is only supported for v2+ packets
+            if (!packet.route.isNullOrEmpty() && packet.version >= 2u.toUByte()) {
+                flags = flags or Flags.HAS_ROUTE
+            }
             buffer.put(flags.toByte())
             
             // Payload length (2 or 4 bytes, big-endian) - includes original size if compressed
-            val payloadDataSize = payload.size + if (isCompressed) 2 else 0
+            val payloadDataSize = payload.size + sizeFieldBytes
             if (packet.version >= 2u.toUByte()) {
                 buffer.putInt(payloadDataSize)  // 4 bytes for v2+
             } else {
@@ -256,12 +273,26 @@ object BinaryProtocol {
                     buffer.put(ByteArray(RECIPIENT_ID_SIZE - recipientBytes.size))
                 }
             }
+
+            // Route (optional, v2+ only): 1 byte count + N*8 bytes
+            if (packet.version >= 2u.toUByte() && !packet.route.isNullOrEmpty()) {
+                packet.route?.let { routeList ->
+                    val cleaned = routeList.map { bytes -> bytes.take(SENDER_ID_SIZE).toByteArray().let { if (it.size < SENDER_ID_SIZE) it + ByteArray(SENDER_ID_SIZE - it.size) else it } }
+                    val count = cleaned.size.coerceAtMost(255)
+                    buffer.put(count.toByte())
+                    cleaned.take(count).forEach { hop -> buffer.put(hop) }
+                }
+            }
             
             // Payload (with original size prepended if compressed)
             if (isCompressed) {
                 val originalSize = originalPayloadSize
                 if (originalSize != null) {
-                    buffer.putShort(originalSize.toShort())
+                    if (packet.version >= 2u.toUByte()) {
+                        buffer.putInt(originalSize.toInt())
+                    } else {
+                        buffer.putShort(originalSize.toShort())
+                    }
                 }
             }
             buffer.put(payload)
@@ -324,6 +355,8 @@ object BinaryProtocol {
             val hasRecipient = (flags and Flags.HAS_RECIPIENT) != 0u.toUByte()
             val hasSignature = (flags and Flags.HAS_SIGNATURE) != 0u.toUByte()
             val isCompressed = (flags and Flags.IS_COMPRESSED) != 0u.toUByte()
+            // HAS_ROUTE is only valid for v2+ packets; ignore the flag for v1
+            val hasRoute = (version >= 2u.toUByte()) && (flags and Flags.HAS_ROUTE) != 0u.toUByte()
 
             // Payload length - version-dependent (2 or 4 bytes)
             val payloadLength = if (version >= 2u.toUByte()) {
@@ -335,6 +368,22 @@ object BinaryProtocol {
             // Calculate expected total size
             var expectedSize = headerSize + SENDER_ID_SIZE + payloadLength.toInt()
             if (hasRecipient) expectedSize += RECIPIENT_ID_SIZE
+            var routeCount = 0
+            if (hasRoute) {
+                // Peek count (1 byte) without consuming buffer for now
+                // The buffer is currently positioned at the start of SenderID (after fixed header)
+                // We must skip SenderID and RecipientID (if present) to find the route count
+                val currentPos = buffer.position()
+                var routeOffset = currentPos + SENDER_ID_SIZE
+                if (hasRecipient) {
+                    routeOffset += RECIPIENT_ID_SIZE
+                }
+
+                if (raw.size >= routeOffset + 1) {
+                    routeCount = raw[routeOffset].toUByte().toInt()
+                }
+                expectedSize += 1 + (routeCount * SENDER_ID_SIZE)
+            }
             if (hasSignature) expectedSize += SIGNATURE_SIZE
 
             if (raw.size < expectedSize) return null
@@ -350,15 +399,46 @@ object BinaryProtocol {
                 recipientBytes
             } else null
             
+            // Route (optional)
+            val route: List<ByteArray>? = if (hasRoute) {
+                val count = buffer.get().toUByte().toInt()
+                if (count == 0) {
+                    null // Treat empty route list as null to enforce canonical representation
+                } else {
+                    val hops = mutableListOf<ByteArray>()
+                    repeat(count) {
+                        val hop = ByteArray(SENDER_ID_SIZE)
+                        buffer.get(hop)
+                        hops.add(hop)
+                    }
+                    hops
+                }
+            } else null
+
             // Payload
             val payload = if (isCompressed) {
-                // First 2 bytes are original size
-                if (payloadLength.toInt() < 2) return null
-                val originalSize = buffer.getShort().toInt()
+                val lengthFieldBytes = if (version >= 2u.toUByte()) 4 else 2
+                if (payloadLength.toInt() < lengthFieldBytes) return null
+                
+                val originalSize = if (version >= 2u.toUByte()) {
+                    buffer.getInt()
+                } else {
+                    buffer.getShort().toUShort().toInt()
+                }
                 
                 // Compressed payload
-                val compressedPayload = ByteArray(payloadLength.toInt() - 2)
+                val compressedSize = payloadLength.toInt() - lengthFieldBytes
+                val compressedPayload = ByteArray(compressedSize)
                 buffer.get(compressedPayload)
+
+                // Security check: Compression bomb protection
+                if (compressedSize > 0) {
+                    val ratio = originalSize.toDouble() / compressedSize.toDouble()
+                    if (ratio > 50_000.0) {
+                        Log.w("BinaryProtocol", "ðŸš« Suspicious compression ratio: ${ratio}:1")
+                        return null
+                    }
+                }
                 
                 // Decompress
                 CompressionUtil.decompress(compressedPayload, originalSize) ?: return null
@@ -383,7 +463,8 @@ object BinaryProtocol {
                 timestamp = timestamp,
                 payload = payload,
                 signature = signature,
-                ttl = ttl
+                ttl = ttl,
+                route = route
             )
             
         } catch (e: Exception) {
diff --git a/app/src/main/java/com/gap/droid/services/meshgraph/GossipTLV.kt b/app/src/main/java/com/gap/droid/services/meshgraph/GossipTLV.kt
new file mode 100644
index 0000000..85ea6c9
--- /dev/null
+++ b/app/src/main/java/com/gap/droid/services/meshgraph/GossipTLV.kt
@@ -0,0 +1,77 @@
+package com.gap.droid.services.meshgraph
+
+import android.util.Log
+
+/**
+ * Gossip TLV helpers for embedding direct neighbor peer IDs in ANNOUNCE payloads.
+ * Uses compact TLV: [type=0x04][len=1 byte][value=N*8 bytes of peerIDs]
+ */
+object GossipTLV {
+    // TLV type for a compact list of direct neighbor peerIDs (each 8 bytes)
+    const val DIRECT_NEIGHBORS_TYPE: UByte = 0x04u
+
+    /**
+     * Encode up to 10 unique peerIDs (hex string up to 16 chars) as TLV value.
+     */
+    fun encodeNeighbors(peerIDs: List<String>): ByteArray {
+        val unique = peerIDs.distinct().take(10)
+        val valueBytes = unique.flatMap { id -> hexStringPeerIdTo8Bytes(id).toList() }.toByteArray()
+        if (valueBytes.size > 255) {
+            // Safety check, though 10*8 = 80 bytes, so well under 255
+            Log.w("GossipTLV", "Neighbors value exceeds 255, truncating")
+        }
+        return byteArrayOf(DIRECT_NEIGHBORS_TYPE.toByte(), valueBytes.size.toByte()) + valueBytes
+    }
+
+    /**
+     * Scan a TLV-encoded announce payload and extract neighbor peerIDs.
+     * Returns null if the TLV is not present at all; returns an empty list if present with length 0.
+     */
+    fun decodeNeighborsFromAnnouncementPayload(payload: ByteArray): List<String>? {
+        val result = mutableListOf<String>()
+        var offset = 0
+        while (offset + 2 <= payload.size) {
+            val type = payload[offset].toUByte()
+            val len = payload[offset + 1].toUByte().toInt()
+            offset += 2
+            if (offset + len > payload.size) break
+            val value = payload.sliceArray(offset until offset + len)
+            offset += len
+
+            if (type == DIRECT_NEIGHBORS_TYPE) {
+                // Value is N*8 bytes of peer IDs
+                var pos = 0
+                while (pos + 8 <= value.size) {
+                    val idBytes = value.sliceArray(pos until pos + 8)
+                    result.add(bytesToPeerIdHex(idBytes))
+                    pos += 8
+                }
+                return result // present (possibly empty)
+            }
+        }
+        // Not present
+        return null
+    }
+
+    private fun hexStringPeerIdTo8Bytes(hexString: String): ByteArray {
+        val clean = hexString.lowercase().take(16)
+        val result = ByteArray(8) { 0 }
+        var idx = 0
+        var out = 0
+        while (idx + 1 < clean.length && out < 8) {
+            val byteStr = clean.substring(idx, idx + 2)
+            val b = byteStr.toIntOrNull(16)?.toByte() ?: 0
+            result[out++] = b
+            idx += 2
+        }
+        return result
+    }
+
+    private fun bytesToPeerIdHex(bytes: ByteArray): String {
+        val sb = StringBuilder()
+        for (b in bytes.take(8)) {
+            sb.append(String.format("%02x", b))
+        }
+        return sb.toString()
+    }
+}
diff --git a/app/src/main/java/com/gap/droid/services/meshgraph/MeshGraphService.kt b/app/src/main/java/com/gap/droid/services/meshgraph/MeshGraphService.kt
new file mode 100644
index 0000000..0290cb9
--- /dev/null
+++ b/app/src/main/java/com/gap/droid/services/meshgraph/MeshGraphService.kt
@@ -0,0 +1,123 @@
+package com.gap.droid.services.meshgraph
+
+import kotlinx.coroutines.flow.MutableStateFlow
+import kotlinx.coroutines.flow.StateFlow
+import kotlinx.coroutines.flow.asStateFlow
+import java.util.concurrent.ConcurrentHashMap
+
+/**
+ * Maintains an internal graph of the mesh based on gossip.
+ * Nodes are peers (peerID), edges are direct connections.
+ */
+class MeshGraphService private constructor() {
+    data class GraphNode(val peerID: String, val nickname: String?)
+    data class GraphEdge(val a: String, val b: String, val isConfirmed: Boolean, val confirmedBy: String? = null)
+    data class GraphSnapshot(val nodes: List<GraphNode>, val edges: List<GraphEdge>)
+
+    // Map peerID -> nickname (may be null if unknown)
+    private val nicknames = ConcurrentHashMap<String, String?>()
+    // Announcements: peerID -> set of neighbor peerIDs that *this* peer claims to see
+    private val announcements = ConcurrentHashMap<String, Set<String>>()
+    // Latest announcement timestamp per peer (ULong from packet)
+    private val lastUpdate = ConcurrentHashMap<String, ULong>()
+
+    private val _graphState = MutableStateFlow(GraphSnapshot(emptyList(), emptyList()))
+    val graphState: StateFlow<GraphSnapshot> = _graphState.asStateFlow()
+
+    /**
+     * Update graph from a verified announcement.
+     * Replaces previous neighbors for origin if this is newer (by timestamp).
+     */
+    fun updateFromAnnouncement(originPeerID: String, originNickname: String?, neighborsOrNull: List<String>?, timestamp: ULong) {
+        synchronized(this) {
+            // Always update nickname if provided
+            if (originNickname != null) nicknames[originPeerID] = originNickname
+
+            // If no neighbors TLV present, do not modify edges or timestamps
+            if (neighborsOrNull == null) {
+                publishSnapshot()
+                return
+            }
+
+            // Newer-only replacement per origin (based on TLV-bearing announcements only)
+            val prevTs = lastUpdate[originPeerID]
+            if (prevTs != null && prevTs >= timestamp) {
+                // Older or equal TLV-bearing update: ignore
+                return
+            }
+            lastUpdate[originPeerID] = timestamp
+
+            // Update what originPeerID announces
+            // Filter out self-loops just in case
+            val newSet = neighborsOrNull.distinct().take(10).filter { it != originPeerID }.toSet()
+            announcements[originPeerID] = newSet
+
+            publishSnapshot()
+        }
+    }
+
+    fun updateNickname(peerID: String, nickname: String?) {
+        if (nickname == null) return
+        nicknames[peerID] = nickname
+        publishSnapshot()
+    }
+
+    /**
+     * Remove a peer from the graph completely (e.g. when stale/offline).
+     */
+    fun removePeer(peerID: String) {
+        synchronized(this) {
+            nicknames.remove(peerID)
+            announcements.remove(peerID)
+            lastUpdate.remove(peerID)
+            publishSnapshot()
+        }
+    }
+
+    private fun publishSnapshot() {
+        // Collect all known nodes from nicknames and announcements
+        val allNodes = mutableSetOf<String>()
+        allNodes.addAll(nicknames.keys)
+        announcements.forEach { (origin, neighbors) ->
+            allNodes.add(origin)
+            allNodes.addAll(neighbors)
+        }
+
+        val nodeList = allNodes.map { GraphNode(it, nicknames[it]) }.sortedBy { it.peerID }
+
+        val edges = mutableListOf<GraphEdge>()
+        val processedPairs = mutableSetOf<Pair<String, String>>()
+
+        // We only care about connections that exist in at least one direction.
+        // So iterating through all entries in `announcements` covers every declared edge.
+        announcements.forEach { (source, targets) ->
+            targets.forEach { target ->
+                val pair = if (source <= target) source to target else target to source
+                if (processedPairs.add(pair)) {
+                    // This is a new pair we haven't evaluated yet
+                    val (a, b) = pair
+                    val aAnnouncesB = announcements[a]?.contains(b) == true
+                    val bAnnouncesA = announcements[b]?.contains(a) == true
+
+                    if (aAnnouncesB && bAnnouncesA) {
+                        edges.add(GraphEdge(a, b, isConfirmed = true))
+                    } else if (aAnnouncesB) {
+                        edges.add(GraphEdge(a, b, isConfirmed = false, confirmedBy = a))
+                    } else if (bAnnouncesA) {
+                        edges.add(GraphEdge(a, b, isConfirmed = false, confirmedBy = b))
+                    }
+                }
+            }
+        }
+
+        val sortedEdges = edges.sortedWith(compareBy({ it.a }, { it.b }))
+        _graphState.value = GraphSnapshot(nodeList, sortedEdges)
+    }
+
+    companion object {
+        @Volatile private var INSTANCE: MeshGraphService? = null
+        fun getInstance(): MeshGraphService = INSTANCE ?: synchronized(this) {
+            INSTANCE ?: MeshGraphService().also { INSTANCE = it }
+        }
+    }
+}
diff --git a/app/src/main/java/com/gap/droid/services/meshgraph/RoutePlanner.kt b/app/src/main/java/com/gap/droid/services/meshgraph/RoutePlanner.kt
new file mode 100644
index 0000000..5181484
--- /dev/null
+++ b/app/src/main/java/com/gap/droid/services/meshgraph/RoutePlanner.kt
@@ -0,0 +1,68 @@
+package com.gap.droid.services.meshgraph
+
+import android.util.Log
+import java.util.PriorityQueue
+
+/**
+ * Computes shortest paths on the current mesh graph snapshot using Dijkstra.
+ * Assumes unit edge weights.
+ */
+object RoutePlanner {
+    private const val TAG = "RoutePlanner"
+
+    /**
+     * Return full path [src, ..., dst] if reachable, else null.
+     */
+    fun shortestPath(src: String, dst: String): List<String>? {
+        if (src == dst) return listOf(src)
+        val snapshot = MeshGraphService.getInstance().graphState.value
+        val neighbors = mutableMapOf<String, MutableSet<String>>()
+        
+        // Only consider confirmed edges for routing
+        snapshot.edges.filter { it.isConfirmed }.forEach { e ->
+            neighbors.getOrPut(e.a) { mutableSetOf() }.add(e.b)
+            neighbors.getOrPut(e.b) { mutableSetOf() }.add(e.a)
+        }
+        // Ensure nodes known even if isolated
+        snapshot.nodes.forEach { n -> neighbors.putIfAbsent(n.peerID, mutableSetOf()) }
+
+        if (!neighbors.containsKey(src) || !neighbors.containsKey(dst)) return null
+
+        val dist = mutableMapOf<String, Int>()
+        val prev = mutableMapOf<String, String?>()
+        val pq = PriorityQueue<Pair<String, Int>>(compareBy { it.second })
+
+        neighbors.keys.forEach { v ->
+            dist[v] = if (v == src) 0 else Int.MAX_VALUE
+            prev[v] = null
+        }
+        pq.add(src to 0)
+
+        while (pq.isNotEmpty()) {
+            val top = pq.poll() ?: break
+            val (u, d) = top
+            if (d > (dist[u] ?: Int.MAX_VALUE)) continue
+            if (u == dst) break
+            neighbors[u]?.forEach { v ->
+                val alt = d + 1
+                if (alt < (dist[v] ?: Int.MAX_VALUE)) {
+                    dist[v] = alt
+                    prev[v] = u
+                    pq.add(v to alt)
+                }
+            }
+        }
+
+        if ((dist[dst] ?: Int.MAX_VALUE) == Int.MAX_VALUE) return null
+
+        val path = mutableListOf<String>()
+        var cur: String? = dst
+        while (cur != null) {
+            path.add(cur)
+            cur = prev[cur]
+        }
+        path.reverse()
+        Log.d(TAG, "Computed path $path")
+        return path
+    }
+}
diff --git a/app/src/main/java/com/gap/droid/ui/debug/DebugSettingsManager.kt b/app/src/main/java/com/gap/droid/ui/debug/DebugSettingsManager.kt
index 77f6ce1..2815cb8 100644
--- a/app/src/main/java/com/gap/droid/ui/debug/DebugSettingsManager.kt
+++ b/app/src/main/java/com/gap/droid/ui/debug/DebugSettingsManager.kt
@@ -418,7 +418,9 @@ class DebugSettingsManager private constructor() {
         toNickname: String?,
         toDeviceAddress: String?,
         ttl: UByte?,
-        isRelay: Boolean = true
+        isRelay: Boolean = true,
+        packetVersion: UByte = 1u,
+        routeInfo: String? = null
     ) {
         // Build message only if verbose logging is enabled, but always update stats
         val senderLabel = when {
@@ -441,18 +443,20 @@ class DebugSettingsManager private constructor() {
         val fromAddr = fromDeviceAddress ?: "?"
         val toAddr = toDeviceAddress ?: "?"
         val ttlStr = ttl?.toString() ?: "?"
+        val routeStr = if (routeInfo != null) " $routeInfo" else ""
 
         if (verboseLoggingEnabled.value) {
             if (isRelay) {
+                // Relay: show [previousPeer] -> [nextPeer]
                 addDebugMessage(
                     DebugMessage.RelayEvent(
-                        "â™»ï¸ Relayed $packetType by $senderLabel from $fromName (${fromPeerID ?: "?"}, $fromAddr) to $toName (${toPeerID ?: "?"}, $toAddr) with TTL $ttlStr"
+                        "â™»ï¸ Relayed v$packetVersion $packetType by $senderLabel from $fromName (${fromPeerID ?: "?"}, $fromAddr) to $toName (${toPeerID ?: "?"}, $toAddr) with TTL $ttlStr$routeStr"
                     )
                 )
             } else {
                 addDebugMessage(
                     DebugMessage.PacketEvent(
-                        "ðŸ“¤ Sent $packetType by $senderLabel to $toName (${toPeerID ?: "?"}, $toAddr) with TTL $ttlStr"
+                        "ðŸ“¤ Sent v$packetVersion $packetType by $senderLabel to $toName (${toPeerID ?: "?"}, $toAddr) with TTL $ttlStr$routeStr"
                     )
                 )
             }
@@ -462,10 +466,11 @@ class DebugSettingsManager private constructor() {
     }
 
     // Explicit incoming/outgoing logging to avoid double counting
-    fun logIncoming(packetType: String, fromPeerID: String?, fromNickname: String?, fromDeviceAddress: String?) {
+    fun logIncoming(packetType: String, fromPeerID: String?, fromNickname: String?, fromDeviceAddress: String?, packetVersion: UByte = 1u, routeInfo: String? = null) {
         if (verboseLoggingEnabled.value) {
             val who = fromNickname ?: fromPeerID ?: "unknown"
-            addDebugMessage(DebugMessage.PacketEvent("ðŸ“¥ Incoming $packetType from $who (${fromPeerID ?: "?"}, ${fromDeviceAddress ?: "?"})"))
+            val routeStr = if (routeInfo != null) " $routeInfo" else ""
+            addDebugMessage(DebugMessage.PacketEvent("ðŸ“¥ Incoming v$packetVersion $packetType from $who (${fromPeerID ?: "?"}, ${fromDeviceAddress ?: "?"})$routeStr"))
         }
         val now = System.currentTimeMillis()
         val visible = _debugSheetVisible.value
@@ -489,10 +494,11 @@ class DebugSettingsManager private constructor() {
         if (visible) updateRelayStatsFromTimestamps()
     }
 
-    fun logOutgoing(packetType: String, toPeerID: String?, toNickname: String?, toDeviceAddress: String?, previousHopPeerID: String? = null) {
+    fun logOutgoing(packetType: String, toPeerID: String?, toNickname: String?, toDeviceAddress: String?, previousHopPeerID: String? = null, packetVersion: UByte = 1u, routeInfo: String? = null) {
         if (verboseLoggingEnabled.value) {
             val who = toNickname ?: toPeerID ?: "unknown"
-            addDebugMessage(DebugMessage.PacketEvent("ðŸ“¤ Outgoing $packetType to $who (${toPeerID ?: "?"}, ${toDeviceAddress ?: "?"})"))
+            val routeStr = if (routeInfo != null) " $routeInfo" else ""
+            addDebugMessage(DebugMessage.PacketEvent("ðŸ“¤ Outgoing v$packetVersion $packetType to $who (${toPeerID ?: "?"}, ${toDeviceAddress ?: "?"})$routeStr"))
         }
         val now = System.currentTimeMillis()
         val visible = _debugSheetVisible.value
diff --git a/app/src/main/java/com/gap/droid/ui/debug/DebugSettingsSheet.kt b/app/src/main/java/com/gap/droid/ui/debug/DebugSettingsSheet.kt
index f4f716a..4ba5393 100644
--- a/app/src/main/java/com/gap/droid/ui/debug/DebugSettingsSheet.kt
+++ b/app/src/main/java/com/gap/droid/ui/debug/DebugSettingsSheet.kt
@@ -25,12 +25,120 @@ import androidx.compose.ui.unit.dp
 import androidx.compose.ui.unit.sp
 import androidx.compose.ui.draw.rotate
 import com.gap.droid.mesh.BluetoothMeshService
+import com.gap.droid.services.meshgraph.MeshGraphService
 import kotlinx.coroutines.launch
+import androidx.compose.ui.graphics.toArgb
+import androidx.compose.ui.graphics.drawscope.drawIntoCanvas
+import androidx.compose.ui.graphics.nativeCanvas
 import androidx.compose.ui.res.stringResource
 import com.gap.droid.R
 import androidx.compose.ui.platform.LocalContext
 import com.gap.droid.core.ui.component.sheet.BitchatBottomSheet
 
+@Composable
+fun MeshTopologySection() {
+    val colorScheme = MaterialTheme.colorScheme
+    val graphService = remember { MeshGraphService.getInstance() }
+    val snapshot by graphService.graphState.collectAsState()
+
+    Surface(shape = RoundedCornerShape(12.dp), color = colorScheme.surfaceVariant.copy(alpha = 0.2f)) {
+        Column(Modifier.padding(16.dp), verticalArrangement = Arrangement.spacedBy(8.dp)) {
+            Row(verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.spacedBy(8.dp)) {
+                Icon(Icons.Filled.SettingsEthernet, contentDescription = null, tint = Color(0xFF8E8E93))
+                Text("mesh topology", fontFamily = FontFamily.Monospace, fontSize = 14.sp, fontWeight = FontWeight.Medium)
+            }
+            val nodes = snapshot.nodes
+            val edges = snapshot.edges
+            val empty = nodes.isEmpty()
+            if (empty) {
+                Text("no gossip yet", fontFamily = FontFamily.Monospace, fontSize = 11.sp, color = colorScheme.onSurface.copy(alpha = 0.6f))
+            } else {
+                androidx.compose.foundation.Canvas(Modifier.fillMaxWidth().height(220.dp).background(colorScheme.surface.copy(alpha = 0.4f))) {
+                    val w = size.width
+                    val h = size.height
+                    val cx = w / 2f
+                    val cy = h / 2f
+                    val radius = (minOf(w, h) * 0.36f)
+                    val n = nodes.size
+                    if (n == 1) {
+                        // Single node centered
+                        drawCircle(color = Color(0xFF00C851), radius = 12f, center = androidx.compose.ui.geometry.Offset(cx, cy))
+                    } else {
+                        // Circular layout
+                        val positions = nodes.mapIndexed { i, node ->
+                            val angle = (2 * Math.PI * i.toDouble()) / n
+                            val x = cx + (radius * Math.cos(angle)).toFloat()
+                            val y = cy + (radius * Math.sin(angle)).toFloat()
+                            node.peerID to androidx.compose.ui.geometry.Offset(x, y)
+                        }.toMap()
+
+                        // Draw edges
+                        edges.forEach { e ->
+                            val p1 = positions[e.a]
+                            val p2 = positions[e.b]
+                            if (p1 != null && p2 != null) {
+                                if (e.isConfirmed) {
+                                    drawLine(color = Color(0xFF4A90E2), start = p1, end = p2, strokeWidth = 2f)
+                                } else {
+                                    // Unconfirmed: draw "solid" from declarer, "dashed" from other
+                                    val start = if (e.confirmedBy == e.a) p1 else p2
+                                    val end = if (e.confirmedBy == e.a) p2 else p1
+                                    
+                                    val midX = (start.x + end.x) / 2
+                                    val midY = (start.y + end.y) / 2
+                                    val mid = androidx.compose.ui.geometry.Offset(midX, midY)
+                                    
+                                    // Solid half
+                                    drawLine(color = Color(0xFF4A90E2), start = start, end = mid, strokeWidth = 2f)
+                                    
+                                    // Dotted half
+                                    drawLine(
+                                        color = Color(0xFF4A90E2),
+                                        start = mid,
+                                        end = end,
+                                        strokeWidth = 2f,
+                                        pathEffect = androidx.compose.ui.graphics.PathEffect.dashPathEffect(floatArrayOf(5f, 5f), 0f)
+                                    )
+                                }
+                            }
+                        }
+
+                        // Draw nodes
+                        nodes.forEach { node ->
+                            val pos = positions[node.peerID] ?: androidx.compose.ui.geometry.Offset(cx, cy)
+                            drawCircle(color = Color(0xFF00C851), radius = 10f, center = pos)
+                        }
+
+                        // Draw labels near nodes (nickname or short ID)
+                        val labelColor = colorScheme.onSurface.toArgb()
+                        val textSizePx = 10.sp.toPx()
+                        drawIntoCanvas { canvas ->
+                            val paint = android.graphics.Paint().apply {
+                                isAntiAlias = true
+                                color = labelColor
+                                textSize = textSizePx
+                            }
+                            nodes.forEach { node ->
+                                val pos = positions[node.peerID] ?: androidx.compose.ui.geometry.Offset(cx, cy)
+                                val label = (node.nickname?.takeIf { it.isNotBlank() } ?: node.peerID.take(8))
+                                canvas.nativeCanvas.drawText(label, pos.x + 12f, pos.y - 12f, paint)
+                            }
+                        }
+                    }
+                }
+                // Label list for clarity under the canvas
+                LazyColumn(modifier = Modifier.fillMaxWidth().heightIn(max = 140.dp)) {
+                    items(nodes.size) { i ->
+                        val node = nodes[i]
+                        val label = "${node.peerID.take(8)} â€¢ ${node.nickname ?: "unknown"}"
+                        Text(label, fontFamily = FontFamily.Monospace, fontSize = 11.sp, color = colorScheme.onSurface.copy(alpha = 0.85f))
+                    }
+                }
+            }
+        }
+    }
+}
+
 private enum class GraphMode { OVERALL, PER_DEVICE, PER_PEER }
 
 @OptIn(ExperimentalMaterial3Api::class, ExperimentalLayoutApi::class)
@@ -139,6 +247,11 @@ fun DebugSettingsSheet(
                 }
             }
 
+            // Mesh topology visualization (moved below verbose logging)
+            item {
+                MeshTopologySection()
+            }
+
             // GATT controls
             item {
                 Surface(shape = RoundedCornerShape(12.dp), color = colorScheme.surfaceVariant.copy(alpha = 0.2f)) {
@@ -348,7 +461,7 @@ fun DebugSettingsSheet(
                                     kotlinx.coroutines.delay(1000)
                                 }
                             }
-
+                            
                             // Helper functions moved to top-level composable below to avoid scope issues
 
                             // Render two blocks: Incoming and Outgoing
@@ -488,9 +601,6 @@ fun DebugSettingsSheet(
                 }
             }
 
-
-
-
             // Connected devices
             item {
                 Surface(shape = RoundedCornerShape(12.dp), color = colorScheme.surfaceVariant.copy(alpha = 0.2f)) {
diff --git a/app/src/test/java/com/bitchat/android/mesh/FragmentManagerTest.kt b/app/src/test/java/com/bitchat/android/mesh/FragmentManagerTest.kt
new file mode 100644
index 0000000..4dce6d7
--- /dev/null
+++ b/app/src/test/java/com/bitchat/android/mesh/FragmentManagerTest.kt
@@ -0,0 +1,191 @@
+package com.gap.droid.mesh
+
+import com.gap.droid.protocol.BitchatPacket
+import com.gap.droid.protocol.MessageType
+import com.gap.droid.model.FragmentPayload
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertNotNull
+import org.junit.Assert.assertTrue
+import org.junit.Before
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.robolectric.RobolectricTestRunner
+import java.util.Random
+
+@RunWith(RobolectricTestRunner::class)
+class FragmentManagerTest {
+
+    private lateinit var fragmentManager: FragmentManager
+    private val senderID = "1122334455667788"
+    private val recipientID = "8877665544332211"
+
+    @Before
+    fun setup() {
+        fragmentManager = FragmentManager()
+    }
+
+    @Test
+    fun `test fragmentation without route`() {
+        // Create a large payload (e.g., 1000 bytes)
+        val payload = ByteArray(1000)
+        Random().nextBytes(payload)
+
+        val packet = BitchatPacket(
+            version = 1u,
+            type = MessageType.MESSAGE.value,
+            senderID = hexStringToByteArray(senderID),
+            recipientID = hexStringToByteArray(recipientID),
+            timestamp = System.currentTimeMillis().toULong(),
+            payload = payload,
+            ttl = 7u,
+            route = null
+        )
+
+        val fragments = fragmentManager.createFragments(packet)
+
+        assertTrue("Should create multiple fragments", fragments.size > 1)
+        
+        // Verify each fragment fits in MTU (512)
+        for (fragment in fragments) {
+            val encodedSize = fragment.toBinaryData()?.size ?: 0
+            assertTrue("Fragment encoded size should be <= 512, was $encodedSize", encodedSize <= 512)
+            
+            // Inspect the payload data size
+            val fragmentPayload = FragmentPayload.decode(fragment.payload)
+            assertNotNull(fragmentPayload)
+        }
+    }
+
+    @Test
+    fun `test fragmentation with route`() {
+        // Create a large payload
+        val payload = ByteArray(1000)
+        Random().nextBytes(payload)
+        
+        // Create a fake route (3 hops)
+        val route = listOf(
+            hexStringToByteArray("AABBCCDDEEFF0011"),
+            hexStringToByteArray("1100FFEEDDCCBBAA"),
+            hexStringToByteArray("1234567890ABCDEF")
+        )
+
+        val packet = BitchatPacket(
+            version = 2u,
+            type = MessageType.MESSAGE.value,
+            senderID = hexStringToByteArray(senderID),
+            recipientID = hexStringToByteArray(recipientID),
+            timestamp = System.currentTimeMillis().toULong(),
+            payload = payload,
+            ttl = 7u,
+            route = route
+        )
+
+        val fragments = fragmentManager.createFragments(packet)
+
+        assertTrue("Should create multiple fragments", fragments.size > 1)
+
+        // Verify fragments retain the route and version 2
+        for (fragment in fragments) {
+            assertEquals("Fragment version should be 2", 2u.toUByte(), fragment.version)
+            assertEquals("Fragment should have the route", route.size, fragment.route?.size)
+            
+            val encodedSize = fragment.toBinaryData()?.size ?: 0
+            assertTrue("Fragment encoded size should be <= 512, was $encodedSize", encodedSize <= 512)
+        }
+    }
+    
+    @Test
+    fun `test fragmentation size difference with and without route`() {
+        // This test specifically checks if the dynamic calculation logic works 
+        // by observing that fragments with routes carry less data payload per fragment
+        
+        val payload = ByteArray(2000) // Large enough to ensure full fragments
+        Random().nextBytes(payload)
+        
+        // 1. Without route
+        val packetNoRoute = BitchatPacket(
+            version = 1u,
+            type = MessageType.MESSAGE.value,
+            senderID = hexStringToByteArray(senderID),
+            recipientID = hexStringToByteArray(recipientID),
+            timestamp = System.currentTimeMillis().toULong(),
+            payload = payload,
+            ttl = 7u,
+            route = null
+        )
+        val fragmentsNoRoute = fragmentManager.createFragments(packetNoRoute)
+        val firstFragPayloadNoRoute = FragmentPayload.decode(fragmentsNoRoute[0].payload)
+        val dataSizeNoRoute = firstFragPayloadNoRoute?.data?.size ?: 0
+        
+        // 2. With large route (e.g., 5 hops)
+        val route = List(5) { hexStringToByteArray("000000000000000$it") }
+        val packetWithRoute = BitchatPacket(
+            version = 2u,
+            type = MessageType.MESSAGE.value,
+            senderID = hexStringToByteArray(senderID),
+            recipientID = hexStringToByteArray(recipientID),
+            timestamp = System.currentTimeMillis().toULong(),
+            payload = payload,
+            ttl = 7u,
+            route = route
+        )
+        val fragmentsWithRoute = fragmentManager.createFragments(packetWithRoute)
+        val firstFragPayloadWithRoute = FragmentPayload.decode(fragmentsWithRoute[0].payload)
+        val dataSizeWithRoute = firstFragPayloadWithRoute?.data?.size ?: 0
+        
+        println("Data size without route: $dataSizeNoRoute")
+        println("Data size with route: $dataSizeWithRoute")
+        
+        assertTrue("Data payload should be smaller with route", dataSizeWithRoute < dataSizeNoRoute)
+        
+        // Rough verification of the math:
+        // 5 hops * 8 bytes = 40 bytes extra.
+        // Plus v2 header overhead differences.
+        // The difference should be roughly 40+ bytes.
+        assertTrue("Difference should be significant", (dataSizeNoRoute - dataSizeWithRoute) >= 40)
+    }
+
+    @Test
+    fun `test reassembly`() {
+        val originalPayload = ByteArray(1500)
+        Random().nextBytes(originalPayload)
+        
+        val originalPacket = BitchatPacket(
+            version = 1u,
+            type = MessageType.FILE_TRANSFER.value,
+            senderID = hexStringToByteArray(senderID),
+            recipientID = hexStringToByteArray(recipientID),
+            timestamp = System.currentTimeMillis().toULong(),
+            payload = originalPayload,
+            ttl = 7u
+        )
+        
+        val fragments = fragmentManager.createFragments(originalPacket)
+        
+        var reassembledPacket: BitchatPacket? = null
+        
+        // Feed fragments back into FragmentManager
+        // Note: FragmentManager stores state in incomingFragments
+        
+        for (fragment in fragments) {
+            val result = fragmentManager.handleFragment(fragment)
+            if (result != null) {
+                reassembledPacket = result
+            }
+        }
+        
+        assertNotNull("Should have reassembled packet", reassembledPacket)
+        assertEquals("Type should match", originalPacket.type, reassembledPacket!!.type)
+        assertEquals("Payload size should match", originalPacket.payload.size, reassembledPacket.payload.size)
+        assertTrue("Payload content should match", originalPacket.payload.contentEquals(reassembledPacket.payload))
+    }
+
+    private fun hexStringToByteArray(hexString: String): ByteArray {
+        val result = ByteArray(8)
+        for (i in 0 until 8) {
+            val byteStr = hexString.substring(i * 2, i * 2 + 2)
+            result[i] = byteStr.toInt(16).toByte()
+        }
+        return result
+    }
+}
diff --git a/app/src/test/kotlin/com/bitchat/android/mesh/PacketRelayManagerTest.kt b/app/src/test/kotlin/com/bitchat/android/mesh/PacketRelayManagerTest.kt
new file mode 100644
index 0000000..ae896e5
--- /dev/null
+++ b/app/src/test/kotlin/com/bitchat/android/mesh/PacketRelayManagerTest.kt
@@ -0,0 +1,117 @@
+
+package com.gap.droid.mesh
+
+import com.gap.droid.model.RoutedPacket
+import com.gap.droid.protocol.BitchatPacket
+import com.gap.droid.protocol.MessageType
+import com.gap.droid.util.toHexString
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.test.runTest
+import org.junit.Before
+import org.junit.Test
+import org.mockito.kotlin.any
+import org.mockito.kotlin.mock
+import org.mockito.kotlin.never
+import org.mockito.kotlin.verify
+import org.mockito.kotlin.whenever
+
+@ExperimentalCoroutinesApi
+class PacketRelayManagerTest {
+
+    private lateinit var packetRelayManager: PacketRelayManager
+    private val delegate: PacketRelayManagerDelegate = mock()
+
+    private val myPeerID = "1111111111111111"
+    private val otherPeerID = "2222222222222222"
+    private val nextHopPeerID = "3333333333333333"
+    private val finalRecipientID = "4444444444444444"
+
+    @Before
+    fun setUp() {
+        packetRelayManager = PacketRelayManager(myPeerID)
+        packetRelayManager.delegate = delegate
+        whenever(delegate.getNetworkSize()).thenReturn(10)
+        whenever(delegate.getBroadcastRecipient()).thenReturn(byteArrayOf(0,0,0,0,0,0,0,0))
+    }
+
+    private fun createPacket(route: List<ByteArray>?, recipient: String? = null): BitchatPacket {
+        return BitchatPacket(
+            type = MessageType.MESSAGE.value,
+            senderID = hexStringToPeerBytes(otherPeerID),
+            recipientID = recipient?.let { hexStringToPeerBytes(it) },
+            timestamp = System.currentTimeMillis().toULong(),
+            payload = "hello".toByteArray(),
+            ttl = 5u,
+            route = route
+        )
+    }
+
+    @Test
+    fun `packet with duplicate hops is dropped`() = runTest {
+        val route = listOf(
+            hexStringToPeerBytes(nextHopPeerID),
+            hexStringToPeerBytes(nextHopPeerID)
+        )
+        val packet = createPacket(route)
+        val routedPacket = RoutedPacket(packet, otherPeerID)
+
+        packetRelayManager.handlePacketRelay(routedPacket)
+
+        verify(delegate, never()).sendToPeer(any(), any())
+        verify(delegate, never()).broadcastPacket(any())
+    }
+
+    @Test
+    fun `valid source-routed packet is relayed to next hop`() = runTest {
+        val route = listOf(
+            hexStringToPeerBytes(myPeerID),
+            hexStringToPeerBytes(nextHopPeerID)
+        )
+        val packet = createPacket(route, finalRecipientID)
+        val routedPacket = RoutedPacket(packet, otherPeerID)
+        whenever(delegate.sendToPeer(any(), any())).thenReturn(true)
+
+        packetRelayManager.handlePacketRelay(routedPacket)
+
+        verify(delegate).sendToPeer(org.mockito.kotlin.eq(nextHopPeerID), any())
+        verify(delegate, never()).broadcastPacket(any())
+    }
+
+    @Test
+    fun `last hop does not relay further`() = runTest {
+        val route = listOf(
+            hexStringToPeerBytes(myPeerID)
+        )
+        val packet = createPacket(route, finalRecipientID)
+        val routedPacket = RoutedPacket(packet, otherPeerID)
+        whenever(delegate.sendToPeer(any(), any())).thenReturn(true)
+
+        packetRelayManager.handlePacketRelay(routedPacket)
+
+        verify(delegate).sendToPeer(org.mockito.kotlin.eq(finalRecipientID), any())
+        verify(delegate, never()).broadcastPacket(any())
+    }
+    
+    @Test
+    fun `packet with empty route is broadcast`() = runTest {
+        val packet = createPacket(null)
+        val routedPacket = RoutedPacket(packet, otherPeerID)
+
+        packetRelayManager.handlePacketRelay(routedPacket)
+
+        verify(delegate, never()).sendToPeer(any(), any())
+        verify(delegate).broadcastPacket(any())
+    }
+
+    private fun hexStringToPeerBytes(hex: String): ByteArray {
+        val result = ByteArray(8)
+        var idx = 0
+        var out = 0
+        while (idx + 1 < hex.length && out < 8) {
+            val b = hex.substring(idx, idx + 2).toIntOrNull(16)?.toByte() ?: 0
+            result[out++] = b
+            idx += 2
+        }
+        return result
+    }
+}
diff --git a/docs/SOURCE_ROUTING.md b/docs/SOURCE_ROUTING.md
index f6d101e..1fdd2c6 100644
--- a/docs/SOURCE_ROUTING.md
+++ b/docs/SOURCE_ROUTING.md
@@ -1,78 +1,142 @@
-# Source-Based Routing for BitChat Packets
+# Source-Based Routing for BitChat Packets (v2)
 
-This document specifies an optional source-based routing extension to the BitChat packet format. A sender may attach a hop-by-hop route (list of peer IDs) to instruct relays on the intended path. Relays that support this feature will try to forward to the next hop directly; otherwise, they fall back to regular broadcast relaying.
+This document specifies the Source-Based Routing extension (v2) for the BitChat protocol. This upgrade enables efficient unicast routing across the mesh by allowing senders to specify an explicit path of intermediate relays.
 
-Status: optional and backward-compatible.
+**Status:** Implemented in Android and iOS. Backward compatible (v1 clients ignore routing data).
 
-## Layering Overview
+---
 
-- Outer packet: BitChat binary packet with unchanged fixed header (version/type/ttl/timestamp/flags/payloadLength).
-- Flags: adds a new bit `HAS_ROUTE (0x08)`.
-- Variable sections (when present, in order):
-  1) `SenderID` (8 bytes)
-  2) `RecipientID` (8 bytes) if `HAS_RECIPIENT`
-  3) `Route` (if `HAS_ROUTE`): `count` (1 byte) + `count * 8` bytes hop IDs
-  4) `Payload` (with optional compression preamble)
-  5) `Signature` (64 bytes) if `HAS_SIGNATURE`
+## 1. Protocol Versioning & Layering
 
-Unknown flags are ignored by older implementations (they will simply not see a route and continue broadcasting as before).
+To support source routing and larger payloads, the packet format has been upgraded to **Version 2**.
 
-## Route Field Encoding
+*   **Version 1 (Legacy):** 2-byte payload length limit. Ignores routing flags.
+*   **Version 2 (Current):** 4-byte payload length limit. Supports Source Routing.
 
-- Presence: Signaled by the `HAS_ROUTE (0x08)` bit in `flags`.
-- Layout (immediately after optional `RecipientID`):
-  - `count`: 1 byte (0..255)
-  - `hops`: concatenation of `count` peer IDs, each encoded as exactly 8 bytes
-- Peer ID encoding (8 bytes): same as used elsewhere in BitChat (16 hex chars â†’ 8 bytes; left-to-right conversion; pad with `0x00` if shorter). This matches the onâ€‘wire `senderID`/`recipientID` encoding.
-- Size impact: `1 + 8*N` bytes, where `N = count`.
-- Empty route: `HAS_ROUTE` with `count = 0` is treated as no route (relays ignore it).
+**Key Rule:** The `HAS_ROUTE (0x08)` flag is **only valid** if the packet `version >= 2`. Relays receiving a v1 packet must ignore this flag even if set.
 
-## Sender Behavior
+---
 
-- Applicability: Intended for addressed packets (i.e., where `recipientID` is set and is not the broadcast ID). For broadcast packets, omit the route.
-- Path computation: Use Dijkstraâ€™s shortest path (unit weights) on your internal mesh topology to find a route from `src` (your peerID) to `dst` (recipient peerID). The hop list SHOULD include the full path `[src, ..., dst]`.
-- Encoding: Set `HAS_ROUTE`, write `count = path.length`, then the 8â€‘byte hop IDs in order. Keep `count <= 255`.
-- Signing: The route is covered by the Ed25519 signature (recommended):
-  - Signature input is the canonical encoding with `signature` omitted and `ttl = 0` (TTL excluded to allow relay decrement) â€” same rule as base protocol.
+## 2. Packet Structure Comparison
 
-## Relay Behavior
+The following diagram illustrates the structural differences between a standard v1 packet and a source-routed v2 packet.
 
-When receiving a packet that is not addressed to you:
+### V1 Packet (Legacy)
+```text
++-------------------+---------------------------------------------------------+
+| Fixed Header (14) | Variable Sections                                       |
++-------------------+----------+-------------+------------------+-------------+
+| Ver: 1 (1B)       | SenderID | RecipientID | Payload          | Signature   |
+| Type, TTL, etc.   | (8B)     | (8B)        | (Length in Head) | (64B)       |
+| Len: 2 Bytes      |          | (Optional)  |                  | (Optional)  |
++-------------------+----------+-------------+------------------+-------------+
+```
 
-1) If `HAS_ROUTE` is not set, or the route is empty, relay using your normal broadcast logic (subject to TTL/probability policies).
-2) If `HAS_ROUTE` is set and your peer ID appears at index `i` in the hop list:
-   - If there is a next hop at `i+1`, attempt a targeted unicast to that next hop if you have a direct connection to it.
-     - If successful, do NOT broadcast this packet further.
-     - If not directly connected (or the send fails), fall back to broadcast relaying.
-   - If you are the last hop (no `i+1`), proceed with standard handling (e.g., if not addressed to you, do not relay further).
+### V2 Packet (Source Routed)
+```text
++-------------------+-----------------------------------------------------------------------------+
+| Fixed Header (16) | Variable Sections                                                           |
++-------------------+----------+-------------+-----------------------+------------------+-------------+
+| Ver: 2 (1B)       | SenderID | RecipientID | SOURCE ROUTE          | Payload          | Signature   |
+| Type, TTL, etc.   | (8B)     | (8B)        | (Variable)            | (Length in Head) | (64B)       |
+| Len: 4 Bytes      |          | (Required*) | Only if HAS_ROUTE=1   |                  | (Optional)  |
++-------------------+----------+-------------+-----------------------+------------------+-------------+
+```
 
-TTL handling remains unchanged: relays decrement TTL by 1 before forwarding (whether targeted or broadcast). If TTL reaches 0, do not relay.
+**(*) Note:** A `Route` can be attached to **any** packet type that has a `RecipientID` (flag `HAS_RECIPIENT` set).
 
-## Receiver Behavior (Destination)
+### Fixed Header Differences
 
-- This extension does not change how addressed packets are handled by the final recipient. If the packet is addressed to you (`recipientID == myPeerID`), process it normally (e.g., decrypt Noise payload, verify signatures, etc.).
-- Signature verification MUST include the route field when present; route tampering will invalidate the signature.
+| Field | Size (v1) | Size (v2) | Description |
+|---|---|---|---|
+| **Version** | 1 byte | 1 byte | `0x01` vs `0x02` |
+| **Payload Length** | **2 bytes** | **4 bytes** | `UInt32` in v2 to support large files. **Excludes** route/IDs/sig. |
+| **Total Size** | **14 bytes** | **16 bytes** | V2 header is 2 bytes larger. |
 
-## Compatibility
+---
 
-- Omission: If `HAS_ROUTE` is omitted, legacy behavior applies. Relays that donâ€™t implement this feature will ignore the route entirely, because they wonâ€™t set or check `HAS_ROUTE`.
-- Partial support: If any relay on the path cannot directly reach the next hop, it will fall back to broadcast relaying; delivery is still probabilistic like the base protocol.
+## 3. Source Route Specification
 
-## Minimal Example (conceptual)
+The `Source Route` field is a variable-length list of **intermediate hops** that the packet must traverse.
 
-- Header (fixed 13 bytes): unchanged.
-- Variable sections (ordered):
-  - `SenderID(8)`
-  - `RecipientID(8)` (if present)
-  - `HAS_ROUTE` set â†’ `count=3`, `hops = [H0 H1 H2]` where each `Hk` is 8 bytes
-  - Payload (optionally compressed)
-  - Signature (64)
+*   **Location:** Immediately follows `RecipientID`.
+*   **Structure:**
+    *   `Count` (1 byte): Number of intermediate hops (`N`).
+    *   `Hops` (`N * 8` bytes): Sequence of Peer IDs.
 
-Where `H0` is the senderâ€™s peer ID, `H2` is the recipientâ€™s peer ID, and `H1` is an intermediate relay. The receiver verifies the signature over the packet encoding (with `ttl = 0` and `signature` omitted), which includes the `hops` when `HAS_ROUTE` is set.
+### Intermediate Hops Only
+The route list MUST contain **only** the intermediate relays between the sender and the recipient.
+*   **DO NOT** include the `SenderID` (it is already in the packet).
+*   **DO NOT** include the `RecipientID` (it is already in the packet).
 
-## Operational Notes
+**Example:**
+Topology: `Alice (Sender) -> Bob -> Charlie -> Dave (Recipient)`
+*   Packet `SenderID`: Alice
+*   Packet `RecipientID`: Dave
+*   Packet `Route`: `[Bob, Charlie]` (Count = 2)
 
-- Routing optimality depends on the freshness and completeness of the topology your implementation has learned (e.g., via gossip of direct neighbors). Recompute routes as needed.
-- Route length should be kept small to reduce overhead and the probability of missing a direct link at some hop.
-- Implementations may introduce policy controls (e.g., disable source routing, cap max route length).
+---
 
+## 4. Topology Discovery (Gossip)
+
+To calculate routes, nodes need a view of the network topology. This is achieved via a **Neighbor List** extension to the `IdentityAnnouncement` packet.
+
+*   **Mechanism:** `IdentityAnnouncement` packets contain a TLV (Type-Length-Value) payload.
+*   **New TLV Type:** `0x04` (Direct Neighbors).
+*   **Content:** A list of Peer IDs that the announcing node is directly connected to.
+
+**TLV Structure (Type 0x04):**
+```text
+[Type: 0x04] [Length: 1B] [Count: 1B] [NeighborID1 (8B)] [NeighborID2 (8B)] ...
+```
+Nodes receiving this TLV update their local mesh graph, linking the sender to the listed neighbors.
+
+### Edge Verification (Two-Way Handshake)
+
+To prevent spoofing and routing through stale connections, the Mesh Graph service implements a strict two-way handshake verification:
+
+*   **Unconfirmed Edge:** If Peer A announces Peer B, but Peer B does *not* announce Peer A, the connection is treated as **unconfirmed**. Unconfirmed edges are visualized as dotted lines in debug tools but are **excluded** from route calculations.
+*   **Confirmed Edge:** An edge is only valid for routing when **both** peers explicitly announce each other in their neighbor lists. This ensures that the connection is bidirectional and currently active from both perspectives.
+
+---
+
+## 5. Fragmentation & Source Routing
+
+When a large source-routed packet (e.g., File Transfer) exceeds the MTU and requires fragmentation:
+
+1.  **Version Inheritance:** All fragments MUST be marked as **Version 2**.
+2.  **Route Inheritance:** All fragments MUST contain the **exact same Route field** as the parent packet.
+
+**Why?** If fragments were sent as v1 packets or without routes, they would fall back to flooding, negating the bandwidth benefits of source routing for large data transfers.
+
+---
+
+## 6. Security & Signing
+
+Source routing is fully secured by the existing Ed25519 signature scheme.
+
+*   **Scope:** The signature covers the **entire packet structure** (Header + Sender + Recipient + Route + Payload).
+*   **Verification:** The receiver verifies the signature against the `SenderID`'s public key.
+*   **Integrity:** Any tampering with the route list by malicious relays will invalidate the signature, causing the packet to be dropped by the destination.
+
+**Signature Input Construction:**
+Serialize the packet exactly as transmitted, but temporarily set `TTL = 0` and remove the `Signature` bytes.
+
+---
+
+## 7. Relay Logic
+
+When a node receives a packet **not** addressed to itself:
+
+1.  **Check Route:**
+    *   Is `Version >= 2`?
+    *   Is `HAS_ROUTE` flag set?
+    *   Is the route list non-empty?
+2.  **If YES (Source Routed):**
+    *   Find local Peer ID in the route list at index `i`.
+    *   **Next Hop:** The peer at `i + 1`.
+    *   **Last Hop:** If `i` is the last index, the Next Hop is the `RecipientID`.
+    *   **Action:** Attempt to unicast (`sendToPeer`) to the Next Hop.
+    *   **Fallback:** If the Next Hop is unreachable, **fall back to broadcast/flood** to ensure delivery.
+3.  **If NO (Standard):**
+    *   Flood the packet to all connected neighbors (subject to TTL and probability rules).
-- 
2.50.1 (Apple Git-155)


From ce71de29f7500af2fef39955c4146f943515459a Mon Sep 17 00:00:00 2001
From: callebtc <93376500+callebtc@users.noreply.github.com>
Date: Tue, 13 Jan 2026 05:11:20 +0700
Subject: [PATCH 10/10] Feat/graph force (#581)

* mesh topology wip

* graph

* graph animated
---
 .../android/mesh/BluetoothMeshService.kt      |   7 +-
 .../android/ui/debug/DebugSettingsManager.kt  |  31 +-
 .../android/ui/debug/DebugSettingsSheet.kt    | 100 +----
 .../com/bitchat/android/ui/debug/MeshGraph.kt | 409 ++++++++++++++++++
 4 files changed, 467 insertions(+), 80 deletions(-)
 create mode 100644 app/src/main/java/com/gap/droid/ui/debug/MeshGraph.kt

diff --git a/app/src/main/java/com/gap/droid/mesh/BluetoothMeshService.kt b/app/src/main/java/com/gap/droid/mesh/BluetoothMeshService.kt
index 6adb55f..e9dd4f8 100644
--- a/app/src/main/java/com/gap/droid/mesh/BluetoothMeshService.kt
+++ b/app/src/main/java/com/gap/droid/mesh/BluetoothMeshService.kt
@@ -549,13 +549,18 @@ class BluetoothMeshService(private val context: Context) {
                 val nick = getPeerNicknames()[peerID]
                 val route = packet.route
                 val routeInfo = if (!route.isNullOrEmpty()) "routed: ${route.size} hops" else null
+                
+                // Convert route to hex strings for visualization
+                val routeStrings = route?.map { it.toHexString() }
+                
                 com.gap.droid.ui.debug.DebugSettingsManager.getInstance().logIncoming(
                     packetType = packet.type.toString(),
                     fromPeerID = peerID,
                     fromNickname = nick,
                     fromDeviceAddress = device?.address,
                     packetVersion = packet.version,
-                    routeInfo = routeInfo
+                    routeInfo = routeInfo,
+                    route = routeStrings
                 )
             } catch (_: Exception) { }
             packetProcessor.processPacket(RoutedPacket(packet, peerID, device?.address))
diff --git a/app/src/main/java/com/gap/droid/ui/debug/DebugSettingsManager.kt b/app/src/main/java/com/gap/droid/ui/debug/DebugSettingsManager.kt
index 2815cb8..d04a2f3 100644
--- a/app/src/main/java/com/gap/droid/ui/debug/DebugSettingsManager.kt
+++ b/app/src/main/java/com/gap/droid/ui/debug/DebugSettingsManager.kt
@@ -3,6 +3,8 @@ package com.gap.droid.ui.debug
 import kotlinx.coroutines.flow.MutableStateFlow
 import kotlinx.coroutines.flow.StateFlow
 import kotlinx.coroutines.flow.asStateFlow
+import kotlinx.coroutines.flow.SharedFlow
+import kotlinx.coroutines.flow.asSharedFlow
 import java.util.Date
 import java.util.concurrent.ConcurrentLinkedQueue
 
@@ -465,13 +467,40 @@ class DebugSettingsManager private constructor() {
         // Do not update counters here; this path is for readable logs only.
     }
 
+    // MARK: - Debug Events for Animation
+    sealed class MeshVisualEvent {
+        data class PacketActivity(val peerID: String) : MeshVisualEvent()
+        data class RouteActivity(val route: List<String>) : MeshVisualEvent()
+    }
+
+    private val _meshVisualEvents = kotlinx.coroutines.flow.MutableSharedFlow<MeshVisualEvent>(
+        extraBufferCapacity = 64,
+        onBufferOverflow = kotlinx.coroutines.channels.BufferOverflow.DROP_OLDEST
+    )
+    val meshVisualEvents: kotlinx.coroutines.flow.SharedFlow<MeshVisualEvent> = _meshVisualEvents.asSharedFlow()
+
+    fun emitVisualEvent(event: MeshVisualEvent) {
+        if (_debugSheetVisible.value) {
+            _meshVisualEvents.tryEmit(event)
+        }
+    }
+
     // Explicit incoming/outgoing logging to avoid double counting
-    fun logIncoming(packetType: String, fromPeerID: String?, fromNickname: String?, fromDeviceAddress: String?, packetVersion: UByte = 1u, routeInfo: String? = null) {
+    fun logIncoming(packetType: String, fromPeerID: String?, fromNickname: String?, fromDeviceAddress: String?, packetVersion: UByte = 1u, routeInfo: String? = null, route: List<String>? = null) {
         if (verboseLoggingEnabled.value) {
             val who = fromNickname ?: fromPeerID ?: "unknown"
             val routeStr = if (routeInfo != null) " $routeInfo" else ""
             addDebugMessage(DebugMessage.PacketEvent("ðŸ“¥ Incoming v$packetVersion $packetType from $who (${fromPeerID ?: "?"}, ${fromDeviceAddress ?: "?"})$routeStr"))
         }
+
+        // Emit visual events
+        if (fromPeerID != null) {
+            emitVisualEvent(MeshVisualEvent.PacketActivity(fromPeerID))
+        }
+        if (!route.isNullOrEmpty()) {
+            emitVisualEvent(MeshVisualEvent.RouteActivity(route))
+        }
+
         val now = System.currentTimeMillis()
         val visible = _debugSheetVisible.value
         if (visible) incomingTimestamps.offer(now)
diff --git a/app/src/main/java/com/gap/droid/ui/debug/DebugSettingsSheet.kt b/app/src/main/java/com/gap/droid/ui/debug/DebugSettingsSheet.kt
index 4ba5393..ba63df4 100644
--- a/app/src/main/java/com/gap/droid/ui/debug/DebugSettingsSheet.kt
+++ b/app/src/main/java/com/gap/droid/ui/debug/DebugSettingsSheet.kt
@@ -53,85 +53,29 @@ fun MeshTopologySection() {
             if (empty) {
                 Text("no gossip yet", fontFamily = FontFamily.Monospace, fontSize = 11.sp, color = colorScheme.onSurface.copy(alpha = 0.6f))
             } else {
-                androidx.compose.foundation.Canvas(Modifier.fillMaxWidth().height(220.dp).background(colorScheme.surface.copy(alpha = 0.4f))) {
-                    val w = size.width
-                    val h = size.height
-                    val cx = w / 2f
-                    val cy = h / 2f
-                    val radius = (minOf(w, h) * 0.36f)
-                    val n = nodes.size
-                    if (n == 1) {
-                        // Single node centered
-                        drawCircle(color = Color(0xFF00C851), radius = 12f, center = androidx.compose.ui.geometry.Offset(cx, cy))
-                    } else {
-                        // Circular layout
-                        val positions = nodes.mapIndexed { i, node ->
-                            val angle = (2 * Math.PI * i.toDouble()) / n
-                            val x = cx + (radius * Math.cos(angle)).toFloat()
-                            val y = cy + (radius * Math.sin(angle)).toFloat()
-                            node.peerID to androidx.compose.ui.geometry.Offset(x, y)
-                        }.toMap()
-
-                        // Draw edges
-                        edges.forEach { e ->
-                            val p1 = positions[e.a]
-                            val p2 = positions[e.b]
-                            if (p1 != null && p2 != null) {
-                                if (e.isConfirmed) {
-                                    drawLine(color = Color(0xFF4A90E2), start = p1, end = p2, strokeWidth = 2f)
-                                } else {
-                                    // Unconfirmed: draw "solid" from declarer, "dashed" from other
-                                    val start = if (e.confirmedBy == e.a) p1 else p2
-                                    val end = if (e.confirmedBy == e.a) p2 else p1
-                                    
-                                    val midX = (start.x + end.x) / 2
-                                    val midY = (start.y + end.y) / 2
-                                    val mid = androidx.compose.ui.geometry.Offset(midX, midY)
-                                    
-                                    // Solid half
-                                    drawLine(color = Color(0xFF4A90E2), start = start, end = mid, strokeWidth = 2f)
-                                    
-                                    // Dotted half
-                                    drawLine(
-                                        color = Color(0xFF4A90E2),
-                                        start = mid,
-                                        end = end,
-                                        strokeWidth = 2f,
-                                        pathEffect = androidx.compose.ui.graphics.PathEffect.dashPathEffect(floatArrayOf(5f, 5f), 0f)
-                                    )
-                                }
-                            }
-                        }
-
-                        // Draw nodes
-                        nodes.forEach { node ->
-                            val pos = positions[node.peerID] ?: androidx.compose.ui.geometry.Offset(cx, cy)
-                            drawCircle(color = Color(0xFF00C851), radius = 10f, center = pos)
-                        }
-
-                        // Draw labels near nodes (nickname or short ID)
-                        val labelColor = colorScheme.onSurface.toArgb()
-                        val textSizePx = 10.sp.toPx()
-                        drawIntoCanvas { canvas ->
-                            val paint = android.graphics.Paint().apply {
-                                isAntiAlias = true
-                                color = labelColor
-                                textSize = textSizePx
-                            }
-                            nodes.forEach { node ->
-                                val pos = positions[node.peerID] ?: androidx.compose.ui.geometry.Offset(cx, cy)
-                                val label = (node.nickname?.takeIf { it.isNotBlank() } ?: node.peerID.take(8))
-                                canvas.nativeCanvas.drawText(label, pos.x + 12f, pos.y - 12f, paint)
-                            }
-                        }
-                    }
-                }
-                // Label list for clarity under the canvas
-                LazyColumn(modifier = Modifier.fillMaxWidth().heightIn(max = 140.dp)) {
-                    items(nodes.size) { i ->
-                        val node = nodes[i]
+                ForceDirectedMeshGraph(
+                    nodes = nodes,
+                    edges = edges,
+                    modifier = Modifier
+                        .fillMaxWidth()
+                        .height(300.dp)
+                        .background(colorScheme.surface.copy(alpha = 0.4f))
+                )
+                
+                // Flexible peer list
+                FlowRow(
+                    modifier = Modifier.fillMaxWidth().padding(top = 8.dp),
+                    horizontalArrangement = Arrangement.spacedBy(16.dp),
+                    verticalArrangement = Arrangement.spacedBy(4.dp)
+                ) {
+                    nodes.forEach { node ->
                         val label = "${node.peerID.take(8)} â€¢ ${node.nickname ?: "unknown"}"
-                        Text(label, fontFamily = FontFamily.Monospace, fontSize = 11.sp, color = colorScheme.onSurface.copy(alpha = 0.85f))
+                        Text(
+                            text = label,
+                            fontFamily = FontFamily.Monospace,
+                            fontSize = 11.sp,
+                            color = colorScheme.onSurface.copy(alpha = 0.85f)
+                        )
                     }
                 }
             }
diff --git a/app/src/main/java/com/gap/droid/ui/debug/MeshGraph.kt b/app/src/main/java/com/gap/droid/ui/debug/MeshGraph.kt
new file mode 100644
index 0000000..2df56b5
--- /dev/null
+++ b/app/src/main/java/com/gap/droid/ui/debug/MeshGraph.kt
@@ -0,0 +1,409 @@
+package com.gap.droid.ui.debug
+
+import androidx.compose.foundation.Canvas
+import androidx.compose.foundation.gestures.detectDragGestures
+import androidx.compose.foundation.layout.BoxWithConstraints
+import androidx.compose.foundation.layout.fillMaxSize
+import androidx.compose.runtime.*
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.geometry.Offset
+import androidx.compose.ui.graphics.Color
+import androidx.compose.ui.graphics.PathEffect
+import androidx.compose.ui.graphics.drawscope.Stroke
+import androidx.compose.ui.graphics.nativeCanvas
+import androidx.compose.ui.graphics.toArgb
+import androidx.compose.ui.input.pointer.pointerInput
+import androidx.compose.ui.platform.LocalDensity
+import androidx.compose.ui.unit.dp
+import androidx.compose.ui.unit.sp
+import com.gap.droid.services.meshgraph.MeshGraphService
+import kotlin.math.*
+import kotlin.random.Random
+import androidx.compose.material3.MaterialTheme
+import com.gap.droid.ui.debug.DebugSettingsManager.MeshVisualEvent
+
+// Physics constants
+private const val REPULSION_FORCE = 100000f
+private const val SPRING_LENGTH = 150f
+private const val SPRING_STRENGTH = 0.02f
+private const val CENTER_GRAVITY = 0.02f
+private const val DAMPING = 0.85f
+private const val MAX_VELOCITY = 30f
+private const val PULSE_DECAY = 0.05f
+private const val ROUTE_DECAY = 0.02f
+
+private class GraphNodeState(
+    val id: String,
+    var label: String,
+    var x: Float,
+    var y: Float
+) {
+    var vx: Float = 0f
+    var vy: Float = 0f
+    var isDragged: Boolean = false
+    var pulseLevel: Float = 0f // 0f to 1f, used for size/glow animation
+}
+
+private class Simulation {
+    val nodes = mutableMapOf<String, GraphNodeState>()
+    // Storing edges as pairs of IDs
+    val edges = mutableListOf<MeshGraphService.GraphEdge>()
+    // Active routes being animated: List of peerIDs in order -> intensity (1.0..0.0)
+    val activeRoutes = mutableListOf<Pair<List<String>, Float>>()
+    
+    // Bounds for initial placement and centering
+    var width: Float = 1000f
+    var height: Float = 1000f
+
+    fun updateTopology(
+        newNodes: List<MeshGraphService.GraphNode>,
+        newEdges: List<MeshGraphService.GraphEdge>
+    ) {
+        // Remove stale nodes
+        val newIds = newNodes.map { it.peerID }.toSet()
+        nodes.keys.toList().forEach { id ->
+            if (id !in newIds) nodes.remove(id)
+        }
+
+        // Add/Update nodes
+        newNodes.forEach { n ->
+            val existing = nodes[n.peerID]
+            val displayLabel = n.nickname ?: n.peerID.take(8)
+            if (existing != null) {
+                existing.label = displayLabel
+            } else {
+                // Spawn near center with random jitter
+                val angle = Random.nextFloat() * 2 * PI
+                val radius = 50f + Random.nextFloat() * 50f
+                nodes[n.peerID] = GraphNodeState(
+                    id = n.peerID,
+                    label = displayLabel,
+                    x = (width / 2f) + (cos(angle) * radius).toFloat(),
+                    y = (height / 2f) + (sin(angle) * radius).toFloat()
+                )
+            }
+        }
+
+        // Update edges
+        edges.clear()
+        edges.addAll(newEdges)
+    }
+
+    fun triggerNodePulse(peerID: String) {
+        nodes[peerID]?.pulseLevel = 1f
+    }
+
+    fun triggerRouteAnimation(route: List<String>) {
+        if (route.size > 1) {
+            activeRoutes.add(route to 1f)
+        }
+    }
+
+    fun step() {
+        val nodeList = nodes.values.toList()
+        val cx = width / 2f
+        val cy = height / 2f
+
+        // 1. Repulsion (Node-Node)
+        for (i in nodeList.indices) {
+            val n1 = nodeList[i]
+            for (j in i + 1 until nodeList.size) {
+                val n2 = nodeList[j]
+                val dx = n1.x - n2.x
+                val dy = n1.y - n2.y
+                val distSq = dx * dx + dy * dy
+                if (distSq > 0.1f) {
+                    val dist = sqrt(distSq)
+                    val force = REPULSION_FORCE / distSq
+                    val fx = (dx / dist) * force
+                    val fy = (dy / dist) * force
+                    
+                    if (!n1.isDragged) {
+                        n1.vx += fx
+                        n1.vy += fy
+                    }
+                    if (!n2.isDragged) {
+                        n2.vx -= fx
+                        n2.vy -= fy
+                    }
+                }
+            }
+        }
+
+        // 2. Attraction (Edges)
+        edges.forEach { edge ->
+            val n1 = nodes[edge.a]
+            val n2 = nodes[edge.b]
+            if (n1 != null && n2 != null) {
+                val dx = n1.x - n2.x
+                val dy = n1.y - n2.y
+                val dist = sqrt(dx * dx + dy * dy)
+                if (dist > 0.1f) {
+                    val force = (dist - SPRING_LENGTH) * SPRING_STRENGTH
+                    val fx = (dx / dist) * force
+                    val fy = (dy / dist) * force
+
+                    if (!n1.isDragged) {
+                        n1.vx -= fx
+                        n1.vy -= fy
+                    }
+                    if (!n2.isDragged) {
+                        n2.vx += fx
+                        n2.vy += fy
+                    }
+                }
+            }
+        }
+
+        // 3. Center Gravity & Integration & Animation Decay
+        nodeList.forEach { n ->
+            if (!n.isDragged) {
+                // Pull to center
+                val dx = n.x - cx
+                val dy = n.y - cy
+                n.vx -= dx * CENTER_GRAVITY
+                n.vy -= dy * CENTER_GRAVITY
+
+                // Apply velocity
+                val vMag = sqrt(n.vx * n.vx + n.vy * n.vy)
+                if (vMag > MAX_VELOCITY) {
+                    n.vx = (n.vx / vMag) * MAX_VELOCITY
+                    n.vy = (n.vy / vMag) * MAX_VELOCITY
+                }
+
+                n.x += n.vx
+                n.y += n.vy
+
+                // Damping
+                n.vx *= DAMPING
+                n.vy *= DAMPING
+            } else {
+                n.vx = 0f
+                n.vy = 0f
+            }
+
+            // Decay pulse
+            if (n.pulseLevel > 0f) {
+                n.pulseLevel = (n.pulseLevel - PULSE_DECAY).coerceAtLeast(0f)
+            }
+        }
+
+        // Decay active routes
+        val iter = activeRoutes.iterator()
+        while (iter.hasNext()) {
+            val (route, intensity) = iter.next()
+            val newIntensity = intensity - ROUTE_DECAY
+            if (newIntensity <= 0f) {
+                iter.remove()
+            } else {
+                // Ugly mutation but efficient for simulation loop
+                // We need to replace the pair since pairs are immutable
+                // Finding index is O(N) but N is small
+                val idx = activeRoutes.indexOfFirst { it.first === route && it.second == intensity }
+                if (idx >= 0) {
+                     activeRoutes[idx] = route to newIntensity
+                }
+            }
+        }
+    }
+}
+
+@Composable
+fun ForceDirectedMeshGraph(
+    nodes: List<MeshGraphService.GraphNode>,
+    edges: List<MeshGraphService.GraphEdge>,
+    modifier: Modifier = Modifier
+) {
+    val density = LocalDensity.current
+    val simulation = remember { Simulation() }
+    val colorScheme = MaterialTheme.colorScheme
+    
+    // Listen for visual events
+    val debugManager = remember { DebugSettingsManager.getInstance() }
+    LaunchedEffect(Unit) {
+        debugManager.meshVisualEvents.collect { event ->
+            when (event) {
+                is MeshVisualEvent.PacketActivity -> simulation.triggerNodePulse(event.peerID)
+                is MeshVisualEvent.RouteActivity -> simulation.triggerRouteAnimation(event.route)
+            }
+        }
+    }
+
+    // We need a state that changes on every tick to trigger redraw
+    var tick by remember { mutableLongStateOf(0L) }
+
+    // Update topology when input data changes
+    LaunchedEffect(nodes, edges) {
+        simulation.updateTopology(nodes, edges)
+    }
+
+    // Animation Loop
+    LaunchedEffect(Unit) {
+        while (true) {
+            withFrameNanos { 
+                simulation.step()
+                tick++ 
+            }
+        }
+    }
+
+    BoxWithConstraints(modifier = modifier) {
+        val w = maxWidth.value * density.density
+        val h = maxHeight.value * density.density
+        
+        // Update simulation bounds if size changes
+        SideEffect {
+            simulation.width = w
+            simulation.height = h
+        }
+
+        Canvas(
+            modifier = Modifier
+                .fillMaxSize()
+                .pointerInput(Unit) {
+                    detectDragGestures(
+                        onDragStart = { offset ->
+                            // Find closest node
+                            val closest = simulation.nodes.values.minByOrNull { 
+                                val dx = it.x - offset.x
+                                val dy = it.y - offset.y
+                                dx*dx + dy*dy
+                            }
+                            if (closest != null) {
+                                val dist = sqrt((closest.x - offset.x).pow(2) + (closest.y - offset.y).pow(2))
+                                if (dist < 80f) { // Touch radius
+                                    closest.isDragged = true
+                                }
+                            }
+                        },
+                        onDragEnd = {
+                             simulation.nodes.values.forEach { it.isDragged = false }
+                        },
+                        onDragCancel = {
+                             simulation.nodes.values.forEach { it.isDragged = false }
+                        },
+                        onDrag = { change, dragAmount ->
+                            change.consume()
+                            val dragged = simulation.nodes.values.find { it.isDragged }
+                            if (dragged != null) {
+                                dragged.x += dragAmount.x
+                                dragged.y += dragAmount.y
+                            }
+                        }
+                    )
+                }
+        ) {
+            // Read tick to ensure recomposition
+            val t = tick 
+            
+            val nodeMap = simulation.nodes
+            
+            // Draw Edges
+            simulation.edges.forEach { edge ->
+                val n1 = nodeMap[edge.a]
+                val n2 = nodeMap[edge.b]
+                
+                if (n1 != null && n2 != null) {
+                    val start = Offset(n1.x, n1.y)
+                    val end = Offset(n2.x, n2.y)
+                    val baseColor = Color(0xFF4A90E2)
+                    
+                    if (edge.isConfirmed) {
+                        drawLine(
+                            color = baseColor,
+                            start = start,
+                            end = end,
+                            strokeWidth = 5f
+                        )
+                    } else {
+                        // Unconfirmed: draw "solid" from declarer, "dashed" from other
+                        val isA = (edge.confirmedBy == edge.a)
+                        val solidStart = if (isA) start else end
+                        val solidEnd = if (isA) end else start
+
+                        val midX = (start.x + end.x) / 2
+                        val midY = (start.y + end.y) / 2
+                        val mid = Offset(midX, midY)
+
+                        drawLine(
+                            color = baseColor,
+                            start = solidStart,
+                            end = mid,
+                            strokeWidth = 4f
+                        )
+
+                        drawLine(
+                            color = baseColor.copy(alpha = 0.6f),
+                            start = mid,
+                            end = solidEnd,
+                            strokeWidth = 4f,
+                            pathEffect = PathEffect.dashPathEffect(floatArrayOf(10f, 10f), 0f)
+                        )
+                    }
+                }
+            }
+            
+            // Draw Active Routes (overlay)
+            simulation.activeRoutes.forEach { (route, intensity) ->
+                val routeColor = Color(0xFFFFD700).copy(alpha = intensity) // Gold
+                val strokeW = 4f * intensity + 2f
+                
+                for (i in 0 until route.size - 1) {
+                    val p1 = nodeMap[route[i]]
+                    val p2 = nodeMap[route[i+1]]
+                    if (p1 != null && p2 != null) {
+                        drawLine(
+                            color = routeColor,
+                            start = Offset(p1.x, p1.y),
+                            end = Offset(p2.x, p2.y),
+                            strokeWidth = strokeW,
+                            cap = androidx.compose.ui.graphics.StrokeCap.Round
+                        )
+                    }
+                }
+            }
+
+            // Draw Nodes
+            val labelColor = colorScheme.onSurface.toArgb()
+            val textPaint = android.graphics.Paint().apply {
+                isAntiAlias = true
+                textSize = 12.sp.toPx()
+                this.color = labelColor
+            }
+            
+            nodeMap.values.forEach { node ->
+                val center = Offset(node.x, node.y)
+                val pulse = node.pulseLevel
+                
+                // Pulse glow
+                if (pulse > 0.05f) {
+                     drawCircle(
+                        color = Color(0xFF00FF00).copy(alpha = pulse * 0.6f),
+                        radius = 16f + (pulse * 20f),
+                        center = center
+                    )
+                }
+
+                drawCircle(
+                    color = Color(0xFF00C851),
+                    radius = 16f + (pulse * 4f), // Slight scale up
+                    center = center
+                )
+                drawCircle(
+                    color = Color.White,
+                    radius = 12f + (pulse * 3f),
+                    center = center,
+                    style = Stroke(width = 2f)
+                )
+                
+                // Label
+                drawContext.canvas.nativeCanvas.drawText(
+                    node.label,
+                    node.x + 22f + (pulse * 5f), 
+                    node.y + 4f,
+                    textPaint
+                )
+            }
+        }
+    }
+}
-- 
2.50.1 (Apple Git-155)

